{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ArquivosUFS Bem vindo ao site de ARQUIVOS DA UFS Reposit\u00f3rio com anota\u00e7\u00f5es de disciplinas dos cursos de Computa\u00e7\u00e3o da UFS Disciplinas Disciplina Programa\u00e7\u00e3o Funcional Programa\u00e7\u00e3o Imperativa Programa\u00e7\u00e3o Orientada a Objetos Feito por Gustavo Gomes","title":"ArquivosUFS"},{"location":"#arquivosufs","text":"Bem vindo ao site de ARQUIVOS DA UFS Reposit\u00f3rio com anota\u00e7\u00f5es de disciplinas dos cursos de Computa\u00e7\u00e3o da UFS","title":"ArquivosUFS"},{"location":"#disciplinas","text":"Disciplina Programa\u00e7\u00e3o Funcional Programa\u00e7\u00e3o Imperativa Programa\u00e7\u00e3o Orientada a Objetos Feito por Gustavo Gomes","title":"Disciplinas"},{"location":"Sem%20t%C3%ADtulo/","text":"","title":"Sem t\u00edtulo"},{"location":"Estruturas%20de%20Dados/00%20-%20Ementa/","text":"Bruno. Ementa Escrever ementa","title":"Bruno."},{"location":"Estruturas%20de%20Dados/00%20-%20Ementa/#bruno","text":"","title":"Bruno."},{"location":"Estruturas%20de%20Dados/00%20-%20Ementa/#ementa","text":"Escrever ementa","title":"Ementa"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/","text":"Revis\u00e3o e introdu\u00e7\u00e3o Tipos Existem diversos tipos (tipos primitivos), (float, int, char, long int, etc ), de forma que cada um ocupa espa\u00e7os diferentes na mem\u00f3ria. tipo Bits Bytes Alcance (m\u00e1x e min) char 8 1 $-2^{7} \\leftrightarrow 2^{7}-1$ int* 16-64 2-8 $-2^{63} \\leftrightarrow 2^{63} -1$ long int* 32-64 4-8 $-2^{63} \\leftrightarrow 2^{63} -1$ long long int* 64 8 $-2^{63} \\leftrightarrow 2^{63} -1$ short int 16 2 $-2^{15} \\leftrightarrow 2^{15}-1$ float 32 4 $1.2^{-38}\\leftrightarrow 3.4^{38}$ double 64 8 $2.3^{-308}\\leftrightarrow 1.7^{308}$ long double* 80-128 10-16 $3.4^{-4932}\\leftrightarrow 1.1^{4932}$ * tamanho e alcance dependentes da plataforma Agora, temos os tipos unsigned , cujo valor vai de 0 at\u00e9 o seu valor m\u00e1ximo positivo, ao contr\u00e1rio dos tipos signed , que possuem valores negativos e positivos. tipo Bits Bytes Alcance (m\u00e1x e min) unsigned char 8 1 $0 \\leftrightarrow 2^{8}-1$ unsigned int* 16-64 2-8 $0 \\leftrightarrow 2^{64}-1$ unsigned long int* 32-64 4-8 $0 \\leftrightarrow 2^{64}-1$ unsigned long long int* 64 8 $0 \\leftrightarrow 2^{64}-1$ unsigned short int 16 2 $0 \\leftrightarrow 2^{16}-1$ * tamanho e alcance dependentes da plataforma A partir do tamanho desses tipos, \u00e9 poss\u00edvel alocar a quantidade necess\u00e1ria de mem\u00f3ria para um valor que se deseja armazenar ou um grupo de valores, seja essa aloca\u00e7\u00e3o est\u00e1tica ou din\u00e2mica. [!Dica] Existe uma biblioteca chamada stdint.h que padroniza o tamanho dos inteiros, garantindo que a precis\u00e3o e o tamanho m\u00e1ximo dos n\u00fameros seja o mesmo em todas as plataformas executadas, e assim, que c\u00f3digo seja port\u00e1vel. Organiza\u00e7\u00e3o dos bytes na mem\u00f3ria ( endianess ) Endianess \u00e9 o termo que se refere \u00e0 organiza\u00e7\u00e3o sequencial dos bytes de alguma estrutura na mem\u00f3ria. Essa organiza\u00e7\u00e3o \u00e9 importante para que os dados sejam trocados corretamente entre programas e sistemas diferentes. [!Importante] A ordem de import\u00e2ncia (byte mais ou menos significativo) \u00e9 determinada olhando para os dados e observando a ordem dos bytes. Ent\u00e3o por exemplo, no n\u00famero 0x12345678 , em que 0x12 , 0x34 , 0x56 e 0x78 s\u00e3o bytes diferentes, 0x12 \u00e9 o byte mais significativo e 0x78 , o menos significativo. Existem dois tipos de endianess: Little endian No formato little endian , o byte menos significativo \u00e9 armazenado primeiro, e os outros bytes s\u00e3o armazenados em ordem crescente de import\u00e2ncia. Suponha um dado 0xAABBCCDD (cada letra representa um byte ). Na nota\u00e7\u00e3o little endian , isso seria armazenado da seguinte maneira ordem 0 1 2 3 bytes 0xDD 0xCC 0xBB 0xAA Big endian Na formata\u00e7\u00e3o big endian , o contr\u00e1rio acontece. Isto \u00e9, o byte mais significativo \u00e9 armazenado primeiro, e os outros s\u00e3o armazenados em ordem decrescente de import\u00e2ncia. Podemos representar 0xAABBCCDD na nota\u00e7\u00e3o Big endian da seguinte forma: ordem 0 1 2 3 bytes 0xAA 0xBB 0xCC 0xDD [!NOTE] A ordem dos bits em qualquer byte geralmente segue o formato little endian Para descobrir a endianess de um sistema, basta utilizar o c\u00f3digo a seguir: int main(void) { unsigned int i = 1; char *c; c = (char *) &i; } Caso o Segmentos de mem\u00f3ria Pilha A pilha (stack) \u00e9 a regi\u00e3o da mem\u00f3ria onde s\u00e3o armazenadas as vari\u00e1veis locais no escopo executado em determinado momento, as chamadas de fun\u00e7\u00f5es e par\u00e2metros. Assim que esses processos ou vari\u00e1veis terminam de ser executados ou usados, a pilha \u00e9 liberada. A pilha j\u00e1 possui tamanho predefinido, e \u00e9 gerenciada pelo pr\u00f3prio computador, n\u00e3o requerendo interven\u00e7\u00e3o do programador para liberar mem\u00f3ria. A ordem em que os dados s\u00e3o processados \u00e9 chamadas de LIFO (Last In, First Out), que significa que os \u00faltimos dados adicionados ser\u00e3o os primeiros processados. Na pr\u00e1tica, para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o que requer outra para funcionar, n\u00e3o faz sentido que a primeira seja executada antes da segunda, pois faltaria informa\u00e7\u00e3o. [!Erro associado \u00e0 pilha] Quando recebemos um erro de \"Stack Overflow\" (estouro de pilha), \u00e9 porque muitas chamadas foram feitas, de forma que o espa\u00e7o requerido para armazen\u00e1-las \u00e9 maior do que h\u00e1 na pilha. Isso pode acontecer com fun\u00e7\u00f5es recursivas mal elaboradas, por exemplo. Heap O heap \u00e9 a parte da mem\u00f3ria alocada dinamicamente durante a execu\u00e7\u00e3o do programa. Ao contr\u00e1rio da pilha, ela \u00e9 controlada pelo programador ou por um garbage collector , pois n\u00e3o \u00e9 liberada automaticamente. Para acessar dados armazenados no heap, utilizamos tipos de dados que apontam (sim, ponteiros) para os endere\u00e7os nesse espa\u00e7o da mem\u00f3ria, permitindo que diferentes tipos de dados sejam armazenados ali. O heap \u00e9 mais lento que a pilha, devido \u00e0 aloca\u00e7\u00e3o e \u00e0 libera\u00e7\u00e3o manual, mas \u00e9 mais flex\u00edvel, pois permite o armazenamento de cole\u00e7\u00f5es de dados (arrays) ou de classes e objetos. Ao mexer com o heap, \u00e9 necess\u00e1rio ter cuidado com vazamentos de mem\u00f3ria. Como a aloca\u00e7\u00e3o \u00e9 realizada dinamicamente, um programa com memory leaks pode ocupar toda a mem\u00f3ria do computador se rodar por tempo suficiente para isso. [!Erro associado a ponteiros] Quando recebemos um erro de \"Segmentation Fault\" (Falha de segmenta\u00e7\u00e3o), \u00e9 porque algum ponteiro est\u00e1 tentando acessar um local indevido (ou nulo) da mem\u00f3ria. Por exemplo, se tentamos escrever uma parte da mem\u00f3ria destinada apenas a leitura, ocupada por outro programa, ou at\u00e9 mesmo, nula. Dados A mem\u00f3ria de dados possui as vari\u00e1veis est\u00e1ticas declaradas no programa, com valores inicializados ou definidos pela plataforma C\u00f3digo A mem\u00f3ria de c\u00f3digo possui as opera\u00e7\u00f5es l\u00f3gicas e aritm\u00e9ticas, junto com os controles de fluxo (condicionais e loops), chamadas de fun\u00e7\u00f5es, entre outros. \u00c9 a parte compilada do programa. Ponteiros Ponteiros s\u00e3o tipos de dados que armazenam um endere\u00e7o de mem\u00f3ria . Esse endere\u00e7o de mem\u00f3ria \u00e9 onde est\u00e1 localizado algum conte\u00fado a ser acessado por meio desse ponteiro. int num = 24; //vari\u00e1vel do tipo int int *pointer; //ponteiro para vari\u00e1vel int inicializado pointer = &num; //o ponteiro px recebe o endere\u00e7o da vari\u00e1vel num Assim como os outros tipos de vari\u00e1veis, os ponteiros s\u00e3o armazenados na pilha, possuindo endere\u00e7os pr\u00f3prios. Ent\u00e3o \u00e9 poss\u00edvel, por exemplo, que exista um ponteiro apontando para outro ponteiro. [!Dica] Uma boa pr\u00e1tica para a declara\u00e7\u00e3o de ponteiros \u00e9 apont\u00e1-los para um endere\u00e7o nulo, utilizando a palavra reservada NULL . Sem isso, o ponteiro apenas declarado pode apontar para qualquer lugar, inclusive locais aleat\u00f3rios (e indesejados). [!Dica] \u00c9 importante que o tipo do ponteiro seja o mesmo da vari\u00e1vel para a qual ele aponta, pois um ponteiro int , por exemplo, pode acessar o byte inicial da vari\u00e1vel e os 3 seguintes, mas se o ponteiro for char , ele s\u00f3 acessar\u00e1 o byte inicial (vari\u00e1vel char possui 1 byte). Operadores Operador * (desreferenciamento) O operador * serve para desreferenciar o ponteiro, ou seja, acessar a informa\u00e7\u00e3o armazenada no endere\u00e7o de mem\u00f3ria que o ponteiro guarda. ... int num = 24; //armazenado em 0x87654321 int *pointer; pointer = &num; printf(\"Pointer: %p \\t Value: %d\", pointer, *pointer); ... Sa\u00edda: Pointer: 0x87654321 Value: 24 No exemplo acima, \u00e9 poss\u00edvel observar que, caso utilizemos apenas o nome do ponteiro pointer , o valor impresso \u00e9 o endere\u00e7o armazenado no ponteiro. Utilizando *pointer , imprimimos o valor armazenado no endere\u00e7o armazenado do ponteiro. Operador & (endere\u00e7amento) O operador & serve para obter o endere\u00e7o de uma vari\u00e1vel. No exemplo anterior, &num representa o endere\u00e7o da vari\u00e1vel num. Passagem de par\u00e2metros por valor e por refer\u00eancia Por valor Podemos, na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, passar um par\u00e2metro por valor. Ou seja, passamos diretamente o valor daquela vari\u00e1vel. ... void func(int x){ x*=3; printf(\"func: %d\\n\", x); } int main(){ int x = 10; func(x); printf(\"main: %d\\n\", x); ... } Retorno: func: 30 main: 10 Com o exemplo acima, \u00e9 poss\u00edvel perceber que, na passagem por valor, os valores passados s\u00e3o \"copiados\" para uma vari\u00e1vel interna \u00e0 fun\u00e7\u00e3o, e a vari\u00e1vel original se mant\u00e9m inalterada. Apesar de ter seus usos, para muitas aplica\u00e7\u00f5es, a passagem por valor n\u00e3o \u00e9 adequada. Por isso, temos a passagem de par\u00e2metros por refer\u00eancia Por refer\u00eancia Aqui, ao inv\u00e9s de passarmos a vari\u00e1vel diretamente, passamos o endere\u00e7o daquela vari\u00e1vel, permitindo que ela seja modificada. diretamente o valor daquela vari\u00e1vel. ... void func(int *x){ *x *=3; printf(\"func: %d\\n\", *x); } int main(){ int x = 10; func(&x); printf(\"main: %d\\n\", x); } Retorno: func: 30 main: 30 Diferente do exemplo anterior, aqui, o valor da vari\u00e1vel foi alterado para quaisquer escopos que a acessem, pois o valor passado n\u00e3o foi o valor da vari\u00e1vel, mas sim, o endere\u00e7o daquela vari\u00e1vel na mem\u00f3ria, cujo valor armazenado foi alterado pela fun\u00e7\u00e3o. Modificador const O uso de const antes do tipo da vari\u00e1vel garante que o valor n\u00e3o seja alterado, mesmo na passagem por refer\u00eancia, por exemplo. Caso haja uma tentativa de modifica\u00e7\u00e3o do valor, o compilador aponta um erro, pois o valor \u00e9 de somente leitura . Ponteiro de ponteiro \u00c9 poss\u00edvel que um ponteiro aponte para outro ponteiro. Assim, um ponteiro duplo (como tamb\u00e9m pode ser chamado) \u00e9 um ponteiro que aponta para o endere\u00e7o de outro ponteiro, e este aponta para o endere\u00e7o de alguma vari\u00e1vel ou algum outro dado. int main(){ char letra = 'l'; char* pont1 = &letra; char** pont2 = &pont1; } No excerto acima, o ponteiro pont2 aponta para o endere\u00e7o de pont1 , e esse aponta para o endere\u00e7o de letra . argc e argv (em C) A fun\u00e7\u00e3o main em C pode possuir os argumentos argc e argv . Enquanto argc \u00e9 o n\u00famero de argumentos para a execu\u00e7\u00e3o do c\u00f3digo, argv representa os argumentos recebidos. Detalhe que argc por padr\u00e3o \u00e9 1, que representa o nome do programa. Esse n\u00famero pode aumentar a depender da quantidade de argumentos utilizados. Por exemplo, o programa pessoas , demonstrado abaixo: #include <stdio.h> #include <string.h> int main(int argc, char* argv[]){ //informa\u00e7\u00f5es sobre cada pessoa char nome[3][10] = {\"Gustavo\",\"Joao\", \"Gabriel\"}; int idade[3] = {23,15,20}; char status[3][13] = {\"Dormindo\",\"Acordado\",\"Trabalhando\"}; //Caso o n\u00famero de argumentos seja menor que 2 (apenas o nome do programa) if(argc < 2){ printf(\"Insira um nome!!\\nSaindo...\\n\"); return 1; } else{ for(int i=0; i<argc+1; i++){ //compara o segundo elemento do argv com cada item da lista de nomes if(!strcmp(nome[i],argv[1])){ printf(\"Nome: %s\\n\", nome[i]); printf(\"Idade: %d\\n\", idade[i]); printf(\"Status: %s\\n\", status[i]); return 0; //acaba o programa aqui } } //caso o segundo argumento n\u00e3o corresponda a nenhum nome printf(\"Nome inv\u00e1lido\\n\"); } return 0; } Nesse exemplo, com tr\u00eas listas, cada entrada correspondente \u00e0 informa\u00e7\u00e3o de uma pessoa, quando executado no terminal, o programa compilado requer um nome. Ent\u00e3o um caso poss\u00edvel \u00e9: `$:./pessoas Gustavo e o retorno disso seria: Nome: Gustavo Idade: 23 Status: Dormindo [!Dica] Note que argv \u00e9 um ponteiro de um ponteiro, pois representa uma lista de strings. Como strings em C s\u00e3o listas de caracteres, a lista de argumentos \u00e9 um array bidimensional de caracteres, e cada \"linha\" da lista \u00e9 separada por um espa\u00e7o, na entrada desses argumentos. Ponteiro de fun\u00e7\u00e3o Aloca\u00e7\u00e3o din\u00e2mica x est\u00e1tica Aqui temos uma tabela que compara, em termos gerais, os dois tipos de aloca\u00e7\u00e3o Aloca\u00e7\u00e3o din\u00e2mica Aloca\u00e7\u00e3o est\u00e1tica Vari\u00e1veis de tamanho conhecido em tempo de execu\u00e7\u00e3o Vari\u00e1veis de tamanho fixo previamente conhecido Alocada dinamicamente no heap Alocada estaticamente nos segmentos .data e .bss Gerenciada pelo programador Gerenciada automaticamente pelo computados Limitado pela mem\u00f3ria dispon\u00edvel no sistema Limitado pelo compilador e pelo sistema operacional Aloca\u00e7\u00e3o din\u00e2mica na pr\u00e1tica em C Com a aloca\u00e7\u00e3o din\u00e2mica, podemos utilizar algumas fun\u00e7\u00f5es \u00fateis: - o sizeof() permite que descubramos o tamanho de uma vari\u00e1vel pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura). (padding) - o malloc() \u00e9 a fun\u00e7\u00e3o utilizada para alocar mem\u00f3ria. Ele aloca o tamanho requisitado (utilizano) - o calloc() - o realloc() - o free() O sizeof() O sizeof() permite que descubramos o tamanho de uma vari\u00e1vel pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura). [!Dica] Caso voc\u00ea possua uma struct tipo com, por exemplo, uma vari\u00e1vel do tipo float (de tamanho 4) e outra do tipo char (de tamanho 1), e voc\u00ea utilizar sizeof(tipo) , o valor retornado ser\u00e1 8, e n\u00e3o 5. Isso acontece devido ao padding , que \u00e9 o preenchimento de espa\u00e7os inutilizados da mem\u00f3ria, nesse caso, dos 3 bytes inutilizados. Esses bytes s\u00e3o preenchidos assim pois \u00e9 mais f\u00e1cil para o computador trabalhar com m\u00faltiplos e pot\u00eancias de 2. Assim, um struct com 2 floats e um char possui 16 bytes, e n\u00e3o 9. O malloc() O malloc() \u00e9 a fun\u00e7\u00e3o utilizada para alocar mem\u00f3ria. Ele aloca o tamanho requisitado (utilizando, inclusive, o retorno da fun\u00e7\u00e3o sizeof() ). Note que ele n\u00e3o altera os valores alocados na mem\u00f3ria, mesmo se eles possu\u00edrem algum tipo de lixo. int main(){ //declara\u00e7\u00e3o do ponteiro int *pont //alocamento de mem\u00f3ria para 2 n\u00fameros inteiros. pont = (int*) malloc(2*sizeof(int)); // inicializando os espa\u00e7os do ponteiro p[0] = 2; p[1] = 13; //imprimindo os valores for(int i = 0; i<2; i++){ printf(\"%d \", p[i]); } } Retorno 2 13 . O calloc() Assim como o malloc() , o calloc() tamb\u00e9m serve para alocar mem\u00f3ria. Diferente do malloc() , que funciona com aritm\u00e9tica de ponteiros, o calloc() recebe a quantidade de elementos com o tamanho requisitado. Outra diferen\u00e7a \u00e9 que o calloc() torna os valores de todos o espa\u00e7o alocado para 0 (nulo), impedindo que algum lixo seja capturado na mem\u00f3ria. Um fator importante \u00e9 que isso consome mais processamento, portanto demandando mais tempo para ser feito. int main(){ //declara\u00e7\u00e3o do ponteiro int *pont //alocamento de mem\u00f3ria para 2 n\u00fameros inteiros. pont = (int*) calloc(2,sizeof(int)); // inicializando os espa\u00e7os do ponteiro p[0] = 2; //imprimindo os valores for(int i = 0; i<2; i++){ printf(\"%d \", p[i]); } } Retorno: 2 0 . O realloc() O realloc() , diferente do malloc() e do calloc() , permite alterar a quantidade de mem\u00f3ria alocada O free()","title":"Revis\u00e3o e introdu\u00e7\u00e3o"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#revisao-e-introducao","text":"","title":"Revis\u00e3o e introdu\u00e7\u00e3o"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#tipos","text":"Existem diversos tipos (tipos primitivos), (float, int, char, long int, etc ), de forma que cada um ocupa espa\u00e7os diferentes na mem\u00f3ria. tipo Bits Bytes Alcance (m\u00e1x e min) char 8 1 $-2^{7} \\leftrightarrow 2^{7}-1$ int* 16-64 2-8 $-2^{63} \\leftrightarrow 2^{63} -1$ long int* 32-64 4-8 $-2^{63} \\leftrightarrow 2^{63} -1$ long long int* 64 8 $-2^{63} \\leftrightarrow 2^{63} -1$ short int 16 2 $-2^{15} \\leftrightarrow 2^{15}-1$ float 32 4 $1.2^{-38}\\leftrightarrow 3.4^{38}$ double 64 8 $2.3^{-308}\\leftrightarrow 1.7^{308}$ long double* 80-128 10-16 $3.4^{-4932}\\leftrightarrow 1.1^{4932}$ * tamanho e alcance dependentes da plataforma Agora, temos os tipos unsigned , cujo valor vai de 0 at\u00e9 o seu valor m\u00e1ximo positivo, ao contr\u00e1rio dos tipos signed , que possuem valores negativos e positivos. tipo Bits Bytes Alcance (m\u00e1x e min) unsigned char 8 1 $0 \\leftrightarrow 2^{8}-1$ unsigned int* 16-64 2-8 $0 \\leftrightarrow 2^{64}-1$ unsigned long int* 32-64 4-8 $0 \\leftrightarrow 2^{64}-1$ unsigned long long int* 64 8 $0 \\leftrightarrow 2^{64}-1$ unsigned short int 16 2 $0 \\leftrightarrow 2^{16}-1$ * tamanho e alcance dependentes da plataforma A partir do tamanho desses tipos, \u00e9 poss\u00edvel alocar a quantidade necess\u00e1ria de mem\u00f3ria para um valor que se deseja armazenar ou um grupo de valores, seja essa aloca\u00e7\u00e3o est\u00e1tica ou din\u00e2mica. [!Dica] Existe uma biblioteca chamada stdint.h que padroniza o tamanho dos inteiros, garantindo que a precis\u00e3o e o tamanho m\u00e1ximo dos n\u00fameros seja o mesmo em todas as plataformas executadas, e assim, que c\u00f3digo seja port\u00e1vel.","title":"Tipos"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#organizacao-dos-bytes-na-memoria-endianess","text":"Endianess \u00e9 o termo que se refere \u00e0 organiza\u00e7\u00e3o sequencial dos bytes de alguma estrutura na mem\u00f3ria. Essa organiza\u00e7\u00e3o \u00e9 importante para que os dados sejam trocados corretamente entre programas e sistemas diferentes. [!Importante] A ordem de import\u00e2ncia (byte mais ou menos significativo) \u00e9 determinada olhando para os dados e observando a ordem dos bytes. Ent\u00e3o por exemplo, no n\u00famero 0x12345678 , em que 0x12 , 0x34 , 0x56 e 0x78 s\u00e3o bytes diferentes, 0x12 \u00e9 o byte mais significativo e 0x78 , o menos significativo. Existem dois tipos de endianess:","title":"Organiza\u00e7\u00e3o dos bytes na mem\u00f3ria (endianess)"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#little-endian","text":"No formato little endian , o byte menos significativo \u00e9 armazenado primeiro, e os outros bytes s\u00e3o armazenados em ordem crescente de import\u00e2ncia. Suponha um dado 0xAABBCCDD (cada letra representa um byte ). Na nota\u00e7\u00e3o little endian , isso seria armazenado da seguinte maneira ordem 0 1 2 3 bytes 0xDD 0xCC 0xBB 0xAA","title":"Little endian"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#big-endian","text":"Na formata\u00e7\u00e3o big endian , o contr\u00e1rio acontece. Isto \u00e9, o byte mais significativo \u00e9 armazenado primeiro, e os outros s\u00e3o armazenados em ordem decrescente de import\u00e2ncia. Podemos representar 0xAABBCCDD na nota\u00e7\u00e3o Big endian da seguinte forma: ordem 0 1 2 3 bytes 0xAA 0xBB 0xCC 0xDD [!NOTE] A ordem dos bits em qualquer byte geralmente segue o formato little endian Para descobrir a endianess de um sistema, basta utilizar o c\u00f3digo a seguir: int main(void) { unsigned int i = 1; char *c; c = (char *) &i; } Caso o","title":"Big endian"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#segmentos-de-memoria","text":"","title":"Segmentos de mem\u00f3ria"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#pilha","text":"A pilha (stack) \u00e9 a regi\u00e3o da mem\u00f3ria onde s\u00e3o armazenadas as vari\u00e1veis locais no escopo executado em determinado momento, as chamadas de fun\u00e7\u00f5es e par\u00e2metros. Assim que esses processos ou vari\u00e1veis terminam de ser executados ou usados, a pilha \u00e9 liberada. A pilha j\u00e1 possui tamanho predefinido, e \u00e9 gerenciada pelo pr\u00f3prio computador, n\u00e3o requerendo interven\u00e7\u00e3o do programador para liberar mem\u00f3ria. A ordem em que os dados s\u00e3o processados \u00e9 chamadas de LIFO (Last In, First Out), que significa que os \u00faltimos dados adicionados ser\u00e3o os primeiros processados. Na pr\u00e1tica, para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o que requer outra para funcionar, n\u00e3o faz sentido que a primeira seja executada antes da segunda, pois faltaria informa\u00e7\u00e3o. [!Erro associado \u00e0 pilha] Quando recebemos um erro de \"Stack Overflow\" (estouro de pilha), \u00e9 porque muitas chamadas foram feitas, de forma que o espa\u00e7o requerido para armazen\u00e1-las \u00e9 maior do que h\u00e1 na pilha. Isso pode acontecer com fun\u00e7\u00f5es recursivas mal elaboradas, por exemplo.","title":"Pilha"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#heap","text":"O heap \u00e9 a parte da mem\u00f3ria alocada dinamicamente durante a execu\u00e7\u00e3o do programa. Ao contr\u00e1rio da pilha, ela \u00e9 controlada pelo programador ou por um garbage collector , pois n\u00e3o \u00e9 liberada automaticamente. Para acessar dados armazenados no heap, utilizamos tipos de dados que apontam (sim, ponteiros) para os endere\u00e7os nesse espa\u00e7o da mem\u00f3ria, permitindo que diferentes tipos de dados sejam armazenados ali. O heap \u00e9 mais lento que a pilha, devido \u00e0 aloca\u00e7\u00e3o e \u00e0 libera\u00e7\u00e3o manual, mas \u00e9 mais flex\u00edvel, pois permite o armazenamento de cole\u00e7\u00f5es de dados (arrays) ou de classes e objetos. Ao mexer com o heap, \u00e9 necess\u00e1rio ter cuidado com vazamentos de mem\u00f3ria. Como a aloca\u00e7\u00e3o \u00e9 realizada dinamicamente, um programa com memory leaks pode ocupar toda a mem\u00f3ria do computador se rodar por tempo suficiente para isso. [!Erro associado a ponteiros] Quando recebemos um erro de \"Segmentation Fault\" (Falha de segmenta\u00e7\u00e3o), \u00e9 porque algum ponteiro est\u00e1 tentando acessar um local indevido (ou nulo) da mem\u00f3ria. Por exemplo, se tentamos escrever uma parte da mem\u00f3ria destinada apenas a leitura, ocupada por outro programa, ou at\u00e9 mesmo, nula.","title":"Heap"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#dados","text":"A mem\u00f3ria de dados possui as vari\u00e1veis est\u00e1ticas declaradas no programa, com valores inicializados ou definidos pela plataforma","title":"Dados"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#codigo","text":"A mem\u00f3ria de c\u00f3digo possui as opera\u00e7\u00f5es l\u00f3gicas e aritm\u00e9ticas, junto com os controles de fluxo (condicionais e loops), chamadas de fun\u00e7\u00f5es, entre outros. \u00c9 a parte compilada do programa.","title":"C\u00f3digo"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#ponteiros","text":"Ponteiros s\u00e3o tipos de dados que armazenam um endere\u00e7o de mem\u00f3ria . Esse endere\u00e7o de mem\u00f3ria \u00e9 onde est\u00e1 localizado algum conte\u00fado a ser acessado por meio desse ponteiro. int num = 24; //vari\u00e1vel do tipo int int *pointer; //ponteiro para vari\u00e1vel int inicializado pointer = &num; //o ponteiro px recebe o endere\u00e7o da vari\u00e1vel num Assim como os outros tipos de vari\u00e1veis, os ponteiros s\u00e3o armazenados na pilha, possuindo endere\u00e7os pr\u00f3prios. Ent\u00e3o \u00e9 poss\u00edvel, por exemplo, que exista um ponteiro apontando para outro ponteiro. [!Dica] Uma boa pr\u00e1tica para a declara\u00e7\u00e3o de ponteiros \u00e9 apont\u00e1-los para um endere\u00e7o nulo, utilizando a palavra reservada NULL . Sem isso, o ponteiro apenas declarado pode apontar para qualquer lugar, inclusive locais aleat\u00f3rios (e indesejados). [!Dica] \u00c9 importante que o tipo do ponteiro seja o mesmo da vari\u00e1vel para a qual ele aponta, pois um ponteiro int , por exemplo, pode acessar o byte inicial da vari\u00e1vel e os 3 seguintes, mas se o ponteiro for char , ele s\u00f3 acessar\u00e1 o byte inicial (vari\u00e1vel char possui 1 byte).","title":"Ponteiros"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#operadores","text":"","title":"Operadores"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#operador-desreferenciamento","text":"O operador * serve para desreferenciar o ponteiro, ou seja, acessar a informa\u00e7\u00e3o armazenada no endere\u00e7o de mem\u00f3ria que o ponteiro guarda. ... int num = 24; //armazenado em 0x87654321 int *pointer; pointer = &num; printf(\"Pointer: %p \\t Value: %d\", pointer, *pointer); ... Sa\u00edda: Pointer: 0x87654321 Value: 24 No exemplo acima, \u00e9 poss\u00edvel observar que, caso utilizemos apenas o nome do ponteiro pointer , o valor impresso \u00e9 o endere\u00e7o armazenado no ponteiro. Utilizando *pointer , imprimimos o valor armazenado no endere\u00e7o armazenado do ponteiro.","title":"Operador * (desreferenciamento)"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#operador-enderecamento","text":"O operador & serve para obter o endere\u00e7o de uma vari\u00e1vel. No exemplo anterior, &num representa o endere\u00e7o da vari\u00e1vel num.","title":"Operador &amp; (endere\u00e7amento)"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#passagem-de-parametros-por-valor-e-por-referencia","text":"","title":"Passagem de par\u00e2metros por valor e por refer\u00eancia"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#por-valor","text":"Podemos, na execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, passar um par\u00e2metro por valor. Ou seja, passamos diretamente o valor daquela vari\u00e1vel. ... void func(int x){ x*=3; printf(\"func: %d\\n\", x); } int main(){ int x = 10; func(x); printf(\"main: %d\\n\", x); ... } Retorno: func: 30 main: 10 Com o exemplo acima, \u00e9 poss\u00edvel perceber que, na passagem por valor, os valores passados s\u00e3o \"copiados\" para uma vari\u00e1vel interna \u00e0 fun\u00e7\u00e3o, e a vari\u00e1vel original se mant\u00e9m inalterada. Apesar de ter seus usos, para muitas aplica\u00e7\u00f5es, a passagem por valor n\u00e3o \u00e9 adequada. Por isso, temos a passagem de par\u00e2metros por refer\u00eancia","title":"Por valor"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#por-referencia","text":"Aqui, ao inv\u00e9s de passarmos a vari\u00e1vel diretamente, passamos o endere\u00e7o daquela vari\u00e1vel, permitindo que ela seja modificada. diretamente o valor daquela vari\u00e1vel. ... void func(int *x){ *x *=3; printf(\"func: %d\\n\", *x); } int main(){ int x = 10; func(&x); printf(\"main: %d\\n\", x); } Retorno: func: 30 main: 30 Diferente do exemplo anterior, aqui, o valor da vari\u00e1vel foi alterado para quaisquer escopos que a acessem, pois o valor passado n\u00e3o foi o valor da vari\u00e1vel, mas sim, o endere\u00e7o daquela vari\u00e1vel na mem\u00f3ria, cujo valor armazenado foi alterado pela fun\u00e7\u00e3o.","title":"Por refer\u00eancia"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#modificador-const","text":"O uso de const antes do tipo da vari\u00e1vel garante que o valor n\u00e3o seja alterado, mesmo na passagem por refer\u00eancia, por exemplo. Caso haja uma tentativa de modifica\u00e7\u00e3o do valor, o compilador aponta um erro, pois o valor \u00e9 de somente leitura .","title":"Modificador const"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#ponteiro-de-ponteiro","text":"\u00c9 poss\u00edvel que um ponteiro aponte para outro ponteiro. Assim, um ponteiro duplo (como tamb\u00e9m pode ser chamado) \u00e9 um ponteiro que aponta para o endere\u00e7o de outro ponteiro, e este aponta para o endere\u00e7o de alguma vari\u00e1vel ou algum outro dado. int main(){ char letra = 'l'; char* pont1 = &letra; char** pont2 = &pont1; } No excerto acima, o ponteiro pont2 aponta para o endere\u00e7o de pont1 , e esse aponta para o endere\u00e7o de letra .","title":"Ponteiro de ponteiro"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#argc-e-argv-em-c","text":"A fun\u00e7\u00e3o main em C pode possuir os argumentos argc e argv . Enquanto argc \u00e9 o n\u00famero de argumentos para a execu\u00e7\u00e3o do c\u00f3digo, argv representa os argumentos recebidos. Detalhe que argc por padr\u00e3o \u00e9 1, que representa o nome do programa. Esse n\u00famero pode aumentar a depender da quantidade de argumentos utilizados. Por exemplo, o programa pessoas , demonstrado abaixo: #include <stdio.h> #include <string.h> int main(int argc, char* argv[]){ //informa\u00e7\u00f5es sobre cada pessoa char nome[3][10] = {\"Gustavo\",\"Joao\", \"Gabriel\"}; int idade[3] = {23,15,20}; char status[3][13] = {\"Dormindo\",\"Acordado\",\"Trabalhando\"}; //Caso o n\u00famero de argumentos seja menor que 2 (apenas o nome do programa) if(argc < 2){ printf(\"Insira um nome!!\\nSaindo...\\n\"); return 1; } else{ for(int i=0; i<argc+1; i++){ //compara o segundo elemento do argv com cada item da lista de nomes if(!strcmp(nome[i],argv[1])){ printf(\"Nome: %s\\n\", nome[i]); printf(\"Idade: %d\\n\", idade[i]); printf(\"Status: %s\\n\", status[i]); return 0; //acaba o programa aqui } } //caso o segundo argumento n\u00e3o corresponda a nenhum nome printf(\"Nome inv\u00e1lido\\n\"); } return 0; } Nesse exemplo, com tr\u00eas listas, cada entrada correspondente \u00e0 informa\u00e7\u00e3o de uma pessoa, quando executado no terminal, o programa compilado requer um nome. Ent\u00e3o um caso poss\u00edvel \u00e9: `$:./pessoas Gustavo e o retorno disso seria: Nome: Gustavo Idade: 23 Status: Dormindo [!Dica] Note que argv \u00e9 um ponteiro de um ponteiro, pois representa uma lista de strings. Como strings em C s\u00e3o listas de caracteres, a lista de argumentos \u00e9 um array bidimensional de caracteres, e cada \"linha\" da lista \u00e9 separada por um espa\u00e7o, na entrada desses argumentos.","title":"argc e argv (em C)"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#ponteiro-de-funcao","text":"","title":"Ponteiro de fun\u00e7\u00e3o"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#alocacao-dinamica-x-estatica","text":"Aqui temos uma tabela que compara, em termos gerais, os dois tipos de aloca\u00e7\u00e3o Aloca\u00e7\u00e3o din\u00e2mica Aloca\u00e7\u00e3o est\u00e1tica Vari\u00e1veis de tamanho conhecido em tempo de execu\u00e7\u00e3o Vari\u00e1veis de tamanho fixo previamente conhecido Alocada dinamicamente no heap Alocada estaticamente nos segmentos .data e .bss Gerenciada pelo programador Gerenciada automaticamente pelo computados Limitado pela mem\u00f3ria dispon\u00edvel no sistema Limitado pelo compilador e pelo sistema operacional","title":"Aloca\u00e7\u00e3o din\u00e2mica x est\u00e1tica"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#alocacao-dinamica-na-pratica-em-c","text":"Com a aloca\u00e7\u00e3o din\u00e2mica, podemos utilizar algumas fun\u00e7\u00f5es \u00fateis: - o sizeof() permite que descubramos o tamanho de uma vari\u00e1vel pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura). (padding) - o malloc() \u00e9 a fun\u00e7\u00e3o utilizada para alocar mem\u00f3ria. Ele aloca o tamanho requisitado (utilizano) - o calloc() - o realloc() - o free()","title":"Aloca\u00e7\u00e3o din\u00e2mica na pr\u00e1tica em C"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#o-sizeof","text":"O sizeof() permite que descubramos o tamanho de uma vari\u00e1vel pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura). [!Dica] Caso voc\u00ea possua uma struct tipo com, por exemplo, uma vari\u00e1vel do tipo float (de tamanho 4) e outra do tipo char (de tamanho 1), e voc\u00ea utilizar sizeof(tipo) , o valor retornado ser\u00e1 8, e n\u00e3o 5. Isso acontece devido ao padding , que \u00e9 o preenchimento de espa\u00e7os inutilizados da mem\u00f3ria, nesse caso, dos 3 bytes inutilizados. Esses bytes s\u00e3o preenchidos assim pois \u00e9 mais f\u00e1cil para o computador trabalhar com m\u00faltiplos e pot\u00eancias de 2. Assim, um struct com 2 floats e um char possui 16 bytes, e n\u00e3o 9.","title":"O sizeof()"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#o-malloc","text":"O malloc() \u00e9 a fun\u00e7\u00e3o utilizada para alocar mem\u00f3ria. Ele aloca o tamanho requisitado (utilizando, inclusive, o retorno da fun\u00e7\u00e3o sizeof() ). Note que ele n\u00e3o altera os valores alocados na mem\u00f3ria, mesmo se eles possu\u00edrem algum tipo de lixo. int main(){ //declara\u00e7\u00e3o do ponteiro int *pont //alocamento de mem\u00f3ria para 2 n\u00fameros inteiros. pont = (int*) malloc(2*sizeof(int)); // inicializando os espa\u00e7os do ponteiro p[0] = 2; p[1] = 13; //imprimindo os valores for(int i = 0; i<2; i++){ printf(\"%d \", p[i]); } } Retorno 2 13 .","title":"O malloc()"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#o-calloc","text":"Assim como o malloc() , o calloc() tamb\u00e9m serve para alocar mem\u00f3ria. Diferente do malloc() , que funciona com aritm\u00e9tica de ponteiros, o calloc() recebe a quantidade de elementos com o tamanho requisitado. Outra diferen\u00e7a \u00e9 que o calloc() torna os valores de todos o espa\u00e7o alocado para 0 (nulo), impedindo que algum lixo seja capturado na mem\u00f3ria. Um fator importante \u00e9 que isso consome mais processamento, portanto demandando mais tempo para ser feito. int main(){ //declara\u00e7\u00e3o do ponteiro int *pont //alocamento de mem\u00f3ria para 2 n\u00fameros inteiros. pont = (int*) calloc(2,sizeof(int)); // inicializando os espa\u00e7os do ponteiro p[0] = 2; //imprimindo os valores for(int i = 0; i<2; i++){ printf(\"%d \", p[i]); } } Retorno: 2 0 .","title":"O calloc()"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#o-realloc","text":"O realloc() , diferente do malloc() e do calloc() , permite alterar a quantidade de mem\u00f3ria alocada","title":"O realloc()"},{"location":"Estruturas%20de%20Dados/01%20-%20Revis%C3%A3o%20de%20ponteiros%20e%20apresenta%C3%A7%C3%A3o/#o-free","text":"","title":"O free()"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/","text":"An\u00e1lise de complexidade O que \u00e9 efici\u00eancia \u00c9 a otimiza\u00e7\u00e3o dos recursos e do tempo para realizar algo. Assim, as coisas com maior efici\u00eancia demandam menos tempo e recursos para se obter um resultado significativo. Historicamente, computadores eram ineficientes, chegando a tomar o espa\u00e7o de um pr\u00e9dio (ENIAC) e consumirem energia tamb\u00e9m equivalente a isso. Devido a isso, era necess\u00e1rio otimizar os algoritmos para que o m\u00ednimo de energia e de tempo fossem consumidos. Outro fator que influenciava era que, devido \u00e0 complexidade, n\u00e3o haviam muitos computadores, ent\u00e3o o uso de computadores como o ENIAC, o BINAC, o UNIVAC e os computadores da s\u00e9rie IBM System/360 era compatilhado entre diferentes institui\u00e7\u00f5es e pessoas. Hoje, a efici\u00eancia \u00e9 importante devido \u00e0s restri\u00e7\u00f5es de custo (para fabricar um produto suficientemente barato) e para o baixo consumo de pot\u00eancia. Com isso, \u00e9 poss\u00edvel miniaturizar computadores e sistemas digitais e eletr\u00f4nicos ao ponto de termos notebooks, celulares, wearables (smartwach, fone de ouvido, etc) e microcontroladores. Complexidade de tempo A complexidade de tempo descreve o tempo necess\u00e1rio para que um computador execute um algoritmo dado uma entrada de determinado tamanho. A unidade de medida aqui \u00e9 o n\u00famero de opera\u00e7\u00f5es realizadas . Exemplo: Ordena\u00e7\u00e3o de uma sequ\u00eancia com n n\u00fameros Por sele\u00e7\u00e3o (selection sort) void selection_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 0; i < n - 1; i++) { uint32_t min = i; for(uint32_t j = i + 1; j < n; j++) if(V[j] < V[min]) min = j; if(i != min) trocar(&V[i], &V[min]); } } O n\u00famero de passos aqui \u00e9 $$N_{passos}= (n-1) +(n-2)+ ...+ 2+1 = \\frac{(n-1) [1+(n-1)]}{2} \\approx n\u00b2$$ Assim, por possuir 2 loops e comparar todos os n\u00fameros da lista entre si, a complexidade de tempo \u00e9 dada por $n\u00b2$ sempre, sendo n o tamanho da entrada. Por inser\u00e7\u00e3o (insertion sort) void insertion_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 1; i < n; i++) for(uint32_t j = i; j > 0 && V[j - 1] > V[j];j--) trocar(&V[j], &V[j - 1]); } Aqui, a ordena\u00e7\u00e3o \u00e9 feita pegando um valor do array, e definindo como o in\u00edcio da lista ordenada. Depois, ele seleciona o valor seguinte, e compara com o maior valor da lista ordenada. Se esse valor da lista ordenada for maior que o selecionado, compara-se com o seguinte, at\u00e9 que se encontre um valor menor que ele. Quando esse valor for encontrado, o selecionado \u00e9 inserido na lista, e o pr\u00f3ximo valor n\u00e3o ordenado \u00e9 selecionado, de forma que o mesmo algoritmo \u00e9 executado. O n\u00famero de passos aqui varia, pois temos o melhor e o pior caso. O melhor caso seria o array ordenado , sem nenhuma opera\u00e7\u00e3o de troca a ser feita. Tirando isso, sempre ter\u00edamos algo pra fazer. Dessa forma: $$n< N_{passos} <n\u00b2$$ Assim, o melhor caso \u00e9 $n$, e o pior \u00e9 $n\u00b2$. Como calcular a quantidade de passos? A an\u00e1lise para determinar a quantidade de passos depende somente do tamanho da entrada n, afinal os outros trechos do c\u00f3digo s\u00e3o constantes (n\u00e3o se alteram). Por exemplo: void exemplo(uint32_t n) { c1(); for(uint32_t i = 0; i < n; i++) c2(); for(uint32_t j = 0; j < n; j++) c3(); for(uint32_t k = 0; k < n; k++) c4(); } Aqui, as subrotinas c1 , c2 , c3 e c4 n\u00e3o dependem de n para funcionar, mas o valor que \u00e9 iterado nos loops \u00e9 justamente o valor de n. Assim $$exemplo(n) = c1+n\\times{c2+n\\times[c3+(c4\\times n)] } = c1+c2 \\times n + c3 \\times n\u00b2 + c4 \\times n\u00b3$$ Dessa forma, a complexidade desse algoritmo \u00e9 de $n\u00b3$ Como calcular o tempo consumido? Supondo o exemplo anterior com uma entrada $n = 1000$. Suponha tamb\u00e9m que $c1 = 200ns,c2=150ns,c3 =250ns, c4=100ns$. Assim, o tempo levado \u00e9 de $$(200 + 150\\times 1000 + 250 \\times 1000\u00b2 \\times + 100 \\times 1000\u00b3)ns \\approx 100s $$ Quanto maior o tamanho da entrada, maior \u00e9 o fator de maior grau da fun\u00e7\u00e3o, nesse caso, o $n\u00b3$. Assim, esse fator \u00e9 o que determina a maior parte do tempo consumido. Nesse caso, \u00e9 poss\u00edvel afirmar que $$exemplo(n) \\le g(n), g(n) = c\\times n^{3}$$ An\u00e1lise assint\u00f3tica Os valores das constantes dependem da m\u00e1quina, e se analisa a ordem de complexidade por meio de $n \\rightarrow \\infty$ $$\\lim_{n \\rightarrow \\infty}{\\frac{exemplo(n)}{g(n)}} = \\begin{cases} O & exemplo(n) g(n)\\end{cases}$$ Sendo g(n) um valor equivalente \u00e0 complexidade no pior caso (no caso de $exemplo(n)$, $c \\times n\u00b3$) Complexidade de espa\u00e7o A complexidade de espa\u00e7o descreve o espa\u00e7o utilizado fisicamente na mem\u00f3ria do computador, dada uma entrada de determinado tamanho. A unidade utilizada aqui \u00e9 justamente o tamanho da aloca\u00e7\u00e3o de mem\u00f3ria necess\u00e1ria. Exemplo: Ordena\u00e7\u00e3o de uma sequ\u00eancia com n n\u00fameros Por inser\u00e7\u00e3o (insertion sort) void insertion_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 1; i < n; i++) for(uint32_t j = i; j > 0;j--) if( V[j - 1] > V[j]) trocar(&V[j], &V[j - 1]); } Tome como exemplo o mesmo algoritmo de inser\u00e7\u00e3o utilizado anteriormente. Assim, para essa implementa\u00e7\u00e3o do insertion sort: $$insertion_sort(n) = c_{uint32_t} \\times n +c_{uint32_t} \\times 3 $$ [!NOTE] O $c_{uint32_t} \\times 3$ representa os 3 valores inteiros alocados pelo programa ( i , j e o valor n ) Como calcular a mem\u00f3ria alocada? A express\u00e3o para o c\u00e1lculo aqui tamb\u00e9m ser\u00e1 em fun\u00e7\u00e3o de $n$, e as constantes dependem do tamanho dos dados. Quanto maior o tamanho de $n$, maior \u00e9 o fator de maior grau da fun\u00e7\u00e3o. An\u00e1lise assint\u00f3tica Assim como na an\u00e1lise de tempo, os valores das constantes dependem da m\u00e1quina, e se analisa a ordem de complexidade por meio de $n \\rightarrow \\infty$ $$\\lim_{n \\rightarrow \\infty}{\\frac{exemplo(n)}{g(n)}} = \\begin{cases} O & exemplo(n) g(n)\\end{cases}$$ Sendo g(n) um valor equivalente \u00e0 complexidade no pior caso Ordem de Crescimento Classes de complexidade para entrada n: Exemplo para c\u00e1lculo de complexidade Para calcular a complexidade de tempo e espa\u00e7o para uma fun\u00e7\u00e3o de fatorial, por exemplo, podemos descrever a implementa\u00e7\u00e3o iterativa do fatorial, de forma que tudo fique justificado. Sabemos que $1! = 1$ e $0! = 1$. Assim, para esses, $n = 0$. Ou seja, o tempo para realiza\u00e7\u00e3o deles \u00e9 0 (constante). Agora se pegarmos qualquer n\u00famero maior que 1, sabemos que a fun\u00e7\u00e3o de fatorial se torna $n! = n \\times (n-1)!$, assim, tornando a complexidade disso maior que 0 (n), pois seu crescimento \u00e9 linear. Em outras palavras: $$Fatorial(n) = \\begin{cases} 1 & n=0 \\ n \\times Fatorial(n-1) & n>0 \\end{cases} $$ Nota\u00e7\u00f5es matem\u00e1ticas Nota\u00e7\u00e3o O A nota\u00e7\u00e3o O (ou Big O) \u00e9 a formaliza\u00e7\u00e3o da complexidade de algoritmos, medindo, justamente, a complexidade dos algoritmos quando a entrada (o valor de $n$) tende a $\\infty$. Outras nota\u00e7\u00f5es s\u00e3o a nota\u00e7\u00e3o $\\Omega$, para melhor caso, e a nota\u00e7\u00e3o $\\Theta$ para um caso m\u00e9dio. Para analisar esses casos, vamos utilizar o exemplo de busca sequencial, denotado abaixo: int32_t busca(int32_t elem, int32_t V[], uint32_t n) { int32_t r = -1; for(uint32_t i = 0; r == -1 && i < n; i++) if(V[i] == elem) r = i; return r; } Esse exemplo pode ser descrito pela equa\u00e7\u00e3o $$busca(n) = c_A + c_B \\times n$$ An\u00e1lise do melhor caso ($\\Omega$) A situa\u00e7\u00e3o de melhor caso \u00e9 a que possui o menor n\u00famero de passos realizados. No caso da busca sequencial, o melhor caso \u00e9 quando o primeiro elemento \u00e9 o elemento desejado em um vetor sem repeti\u00e7\u00f5es (O(1)). Suponha que existem $c$ e $n_0$ tal que $(0\\le cg(n) \\le busca(n)), \\forall n\\ge n_0$ . Logo, $$\\Omega(busca(n)) = \\Omega (g(n)) = \\Omega(c_A + c_B) = c_{MC}$$ An\u00e1lise do pior caso ($O$) \u00c9 justamente a an\u00e1lise que descreve a situa\u00e7\u00e3o que requer o maior n\u00famero de passos para ser executada. \u00c9 tamb\u00e9m a mais utilizada para a an\u00e1lise de algoritmos. Estabelece um limitante superior. No exemplo da busca sequencial, o melhor caso \u00e9 quando o elemento desejado est\u00e1 na \u00faltima posi\u00e7\u00e3o do array. Suponha que existem $c$ e $n_0$ tal que $(0\\le busca(n))\\le cg(n) , \\forall n\\ge n_0$ . Logo, $$O(busca(n)) = O(cg(n)) = O(c_A + c_B) = c_{PC} \\times n$$ Propriedades da nota\u00e7\u00e3o $O$ Termos constantes: $O(c) = O(1)$ Multiplica\u00e7\u00e3o por constantes: $O(c\\times f(n))= O(f(n))$ Adi\u00e7\u00e3o: $O(f_1(n)) + (f_2(n)) = O(|f_1(n)| + |f_2(n)|)$ Produto: $O(f_1(n)) \\times (f_2(n)) = O(f_1(n) \\times f_2(n))$ Caso m\u00e9dio ($\\Theta$) Aqui, s\u00e3o feitas an\u00e1lises de quaisquer poss\u00edveis valores de tempo entre o melhor e o pior caso. Os casos m\u00e9dios para o exemplo da busca sequencial s\u00e3o a busca para qualquer valor entre 1 e 999, dado um vetor de 1000 elementos, por exemplo. Suponha que existem $c$ e $n_0$ tal que $(0\\le c_1g(n) \\le busca(n)\\le c_2g(n)), \\forall n\\ge n_0$ . Logo, $$\\Omega(c_{MC}) \\le busca(n) \\le O(n) $$","title":"An\u00e1lise de complexidade"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#analise-de-complexidade","text":"","title":"An\u00e1lise de complexidade"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#o-que-e-eficiencia","text":"\u00c9 a otimiza\u00e7\u00e3o dos recursos e do tempo para realizar algo. Assim, as coisas com maior efici\u00eancia demandam menos tempo e recursos para se obter um resultado significativo. Historicamente, computadores eram ineficientes, chegando a tomar o espa\u00e7o de um pr\u00e9dio (ENIAC) e consumirem energia tamb\u00e9m equivalente a isso. Devido a isso, era necess\u00e1rio otimizar os algoritmos para que o m\u00ednimo de energia e de tempo fossem consumidos. Outro fator que influenciava era que, devido \u00e0 complexidade, n\u00e3o haviam muitos computadores, ent\u00e3o o uso de computadores como o ENIAC, o BINAC, o UNIVAC e os computadores da s\u00e9rie IBM System/360 era compatilhado entre diferentes institui\u00e7\u00f5es e pessoas. Hoje, a efici\u00eancia \u00e9 importante devido \u00e0s restri\u00e7\u00f5es de custo (para fabricar um produto suficientemente barato) e para o baixo consumo de pot\u00eancia. Com isso, \u00e9 poss\u00edvel miniaturizar computadores e sistemas digitais e eletr\u00f4nicos ao ponto de termos notebooks, celulares, wearables (smartwach, fone de ouvido, etc) e microcontroladores.","title":"O que \u00e9 efici\u00eancia"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#complexidade-de-tempo","text":"A complexidade de tempo descreve o tempo necess\u00e1rio para que um computador execute um algoritmo dado uma entrada de determinado tamanho. A unidade de medida aqui \u00e9 o n\u00famero de opera\u00e7\u00f5es realizadas . Exemplo: Ordena\u00e7\u00e3o de uma sequ\u00eancia com n n\u00fameros","title":"Complexidade de tempo"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#por-selecao-selection-sort","text":"void selection_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 0; i < n - 1; i++) { uint32_t min = i; for(uint32_t j = i + 1; j < n; j++) if(V[j] < V[min]) min = j; if(i != min) trocar(&V[i], &V[min]); } } O n\u00famero de passos aqui \u00e9 $$N_{passos}= (n-1) +(n-2)+ ...+ 2+1 = \\frac{(n-1) [1+(n-1)]}{2} \\approx n\u00b2$$ Assim, por possuir 2 loops e comparar todos os n\u00fameros da lista entre si, a complexidade de tempo \u00e9 dada por $n\u00b2$ sempre, sendo n o tamanho da entrada.","title":"Por sele\u00e7\u00e3o (selection sort)"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#por-insercao-insertion-sort","text":"void insertion_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 1; i < n; i++) for(uint32_t j = i; j > 0 && V[j - 1] > V[j];j--) trocar(&V[j], &V[j - 1]); } Aqui, a ordena\u00e7\u00e3o \u00e9 feita pegando um valor do array, e definindo como o in\u00edcio da lista ordenada. Depois, ele seleciona o valor seguinte, e compara com o maior valor da lista ordenada. Se esse valor da lista ordenada for maior que o selecionado, compara-se com o seguinte, at\u00e9 que se encontre um valor menor que ele. Quando esse valor for encontrado, o selecionado \u00e9 inserido na lista, e o pr\u00f3ximo valor n\u00e3o ordenado \u00e9 selecionado, de forma que o mesmo algoritmo \u00e9 executado. O n\u00famero de passos aqui varia, pois temos o melhor e o pior caso. O melhor caso seria o array ordenado , sem nenhuma opera\u00e7\u00e3o de troca a ser feita. Tirando isso, sempre ter\u00edamos algo pra fazer. Dessa forma: $$n< N_{passos} <n\u00b2$$ Assim, o melhor caso \u00e9 $n$, e o pior \u00e9 $n\u00b2$.","title":"Por inser\u00e7\u00e3o (insertion sort)"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#como-calcular-a-quantidade-de-passos","text":"A an\u00e1lise para determinar a quantidade de passos depende somente do tamanho da entrada n, afinal os outros trechos do c\u00f3digo s\u00e3o constantes (n\u00e3o se alteram). Por exemplo: void exemplo(uint32_t n) { c1(); for(uint32_t i = 0; i < n; i++) c2(); for(uint32_t j = 0; j < n; j++) c3(); for(uint32_t k = 0; k < n; k++) c4(); } Aqui, as subrotinas c1 , c2 , c3 e c4 n\u00e3o dependem de n para funcionar, mas o valor que \u00e9 iterado nos loops \u00e9 justamente o valor de n. Assim $$exemplo(n) = c1+n\\times{c2+n\\times[c3+(c4\\times n)] } = c1+c2 \\times n + c3 \\times n\u00b2 + c4 \\times n\u00b3$$ Dessa forma, a complexidade desse algoritmo \u00e9 de $n\u00b3$","title":"Como calcular a quantidade de passos?"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#como-calcular-o-tempo-consumido","text":"Supondo o exemplo anterior com uma entrada $n = 1000$. Suponha tamb\u00e9m que $c1 = 200ns,c2=150ns,c3 =250ns, c4=100ns$. Assim, o tempo levado \u00e9 de $$(200 + 150\\times 1000 + 250 \\times 1000\u00b2 \\times + 100 \\times 1000\u00b3)ns \\approx 100s $$ Quanto maior o tamanho da entrada, maior \u00e9 o fator de maior grau da fun\u00e7\u00e3o, nesse caso, o $n\u00b3$. Assim, esse fator \u00e9 o que determina a maior parte do tempo consumido. Nesse caso, \u00e9 poss\u00edvel afirmar que $$exemplo(n) \\le g(n), g(n) = c\\times n^{3}$$","title":"Como calcular o tempo consumido?"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#analise-assintotica","text":"Os valores das constantes dependem da m\u00e1quina, e se analisa a ordem de complexidade por meio de $n \\rightarrow \\infty$ $$\\lim_{n \\rightarrow \\infty}{\\frac{exemplo(n)}{g(n)}} = \\begin{cases} O & exemplo(n) g(n)\\end{cases}$$ Sendo g(n) um valor equivalente \u00e0 complexidade no pior caso (no caso de $exemplo(n)$, $c \\times n\u00b3$)","title":"An\u00e1lise assint\u00f3tica"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#complexidade-de-espaco","text":"A complexidade de espa\u00e7o descreve o espa\u00e7o utilizado fisicamente na mem\u00f3ria do computador, dada uma entrada de determinado tamanho. A unidade utilizada aqui \u00e9 justamente o tamanho da aloca\u00e7\u00e3o de mem\u00f3ria necess\u00e1ria. Exemplo: Ordena\u00e7\u00e3o de uma sequ\u00eancia com n n\u00fameros","title":"Complexidade de espa\u00e7o"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#por-insercao-insertion-sort_1","text":"void insertion_sort(uint32_t* V, uint32_t n) { for(uint32_t i = 1; i < n; i++) for(uint32_t j = i; j > 0;j--) if( V[j - 1] > V[j]) trocar(&V[j], &V[j - 1]); } Tome como exemplo o mesmo algoritmo de inser\u00e7\u00e3o utilizado anteriormente. Assim, para essa implementa\u00e7\u00e3o do insertion sort: $$insertion_sort(n) = c_{uint32_t} \\times n +c_{uint32_t} \\times 3 $$ [!NOTE] O $c_{uint32_t} \\times 3$ representa os 3 valores inteiros alocados pelo programa ( i , j e o valor n )","title":"Por inser\u00e7\u00e3o (insertion sort)"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#como-calcular-a-memoria-alocada","text":"A express\u00e3o para o c\u00e1lculo aqui tamb\u00e9m ser\u00e1 em fun\u00e7\u00e3o de $n$, e as constantes dependem do tamanho dos dados. Quanto maior o tamanho de $n$, maior \u00e9 o fator de maior grau da fun\u00e7\u00e3o.","title":"Como calcular a mem\u00f3ria alocada?"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#analise-assintotica_1","text":"Assim como na an\u00e1lise de tempo, os valores das constantes dependem da m\u00e1quina, e se analisa a ordem de complexidade por meio de $n \\rightarrow \\infty$ $$\\lim_{n \\rightarrow \\infty}{\\frac{exemplo(n)}{g(n)}} = \\begin{cases} O & exemplo(n) g(n)\\end{cases}$$ Sendo g(n) um valor equivalente \u00e0 complexidade no pior caso","title":"An\u00e1lise assint\u00f3tica"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#ordem-de-crescimento","text":"Classes de complexidade para entrada n:","title":"Ordem de Crescimento"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#exemplo-para-calculo-de-complexidade","text":"Para calcular a complexidade de tempo e espa\u00e7o para uma fun\u00e7\u00e3o de fatorial, por exemplo, podemos descrever a implementa\u00e7\u00e3o iterativa do fatorial, de forma que tudo fique justificado. Sabemos que $1! = 1$ e $0! = 1$. Assim, para esses, $n = 0$. Ou seja, o tempo para realiza\u00e7\u00e3o deles \u00e9 0 (constante). Agora se pegarmos qualquer n\u00famero maior que 1, sabemos que a fun\u00e7\u00e3o de fatorial se torna $n! = n \\times (n-1)!$, assim, tornando a complexidade disso maior que 0 (n), pois seu crescimento \u00e9 linear. Em outras palavras: $$Fatorial(n) = \\begin{cases} 1 & n=0 \\ n \\times Fatorial(n-1) & n>0 \\end{cases} $$","title":"Exemplo para c\u00e1lculo de complexidade"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#notacoes-matematicas","text":"","title":"Nota\u00e7\u00f5es matem\u00e1ticas"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#notacao-o","text":"A nota\u00e7\u00e3o O (ou Big O) \u00e9 a formaliza\u00e7\u00e3o da complexidade de algoritmos, medindo, justamente, a complexidade dos algoritmos quando a entrada (o valor de $n$) tende a $\\infty$. Outras nota\u00e7\u00f5es s\u00e3o a nota\u00e7\u00e3o $\\Omega$, para melhor caso, e a nota\u00e7\u00e3o $\\Theta$ para um caso m\u00e9dio. Para analisar esses casos, vamos utilizar o exemplo de busca sequencial, denotado abaixo: int32_t busca(int32_t elem, int32_t V[], uint32_t n) { int32_t r = -1; for(uint32_t i = 0; r == -1 && i < n; i++) if(V[i] == elem) r = i; return r; } Esse exemplo pode ser descrito pela equa\u00e7\u00e3o $$busca(n) = c_A + c_B \\times n$$","title":"Nota\u00e7\u00e3o O"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#analise-do-melhor-caso-omega","text":"A situa\u00e7\u00e3o de melhor caso \u00e9 a que possui o menor n\u00famero de passos realizados. No caso da busca sequencial, o melhor caso \u00e9 quando o primeiro elemento \u00e9 o elemento desejado em um vetor sem repeti\u00e7\u00f5es (O(1)). Suponha que existem $c$ e $n_0$ tal que $(0\\le cg(n) \\le busca(n)), \\forall n\\ge n_0$ . Logo, $$\\Omega(busca(n)) = \\Omega (g(n)) = \\Omega(c_A + c_B) = c_{MC}$$","title":"An\u00e1lise do melhor caso ($\\Omega$)"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#analise-do-pior-caso-o","text":"\u00c9 justamente a an\u00e1lise que descreve a situa\u00e7\u00e3o que requer o maior n\u00famero de passos para ser executada. \u00c9 tamb\u00e9m a mais utilizada para a an\u00e1lise de algoritmos. Estabelece um limitante superior. No exemplo da busca sequencial, o melhor caso \u00e9 quando o elemento desejado est\u00e1 na \u00faltima posi\u00e7\u00e3o do array. Suponha que existem $c$ e $n_0$ tal que $(0\\le busca(n))\\le cg(n) , \\forall n\\ge n_0$ . Logo, $$O(busca(n)) = O(cg(n)) = O(c_A + c_B) = c_{PC} \\times n$$","title":"An\u00e1lise do pior caso ($O$)"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#propriedades-da-notacao-o","text":"Termos constantes: $O(c) = O(1)$ Multiplica\u00e7\u00e3o por constantes: $O(c\\times f(n))= O(f(n))$ Adi\u00e7\u00e3o: $O(f_1(n)) + (f_2(n)) = O(|f_1(n)| + |f_2(n)|)$ Produto: $O(f_1(n)) \\times (f_2(n)) = O(f_1(n) \\times f_2(n))$","title":"Propriedades da nota\u00e7\u00e3o $O$"},{"location":"Estruturas%20de%20Dados/02%20-%20Complexidade/#caso-medio-theta","text":"Aqui, s\u00e3o feitas an\u00e1lises de quaisquer poss\u00edveis valores de tempo entre o melhor e o pior caso. Os casos m\u00e9dios para o exemplo da busca sequencial s\u00e3o a busca para qualquer valor entre 1 e 999, dado um vetor de 1000 elementos, por exemplo. Suponha que existem $c$ e $n_0$ tal que $(0\\le c_1g(n) \\le busca(n)\\le c_2g(n)), \\forall n\\ge n_0$ . Logo, $$\\Omega(c_{MC}) \\le busca(n) \\le O(n) $$","title":"Caso m\u00e9dio ($\\Theta$)"},{"location":"Estruturas%20de%20Dados/03-%20Recorr%C3%AAncia/","text":"Recorr\u00eancia Anteriormente, foram definidas as no\u00e7\u00f5es de complexidade de tempo e de espa\u00e7o, tal qual suas nota\u00e7\u00f5es e como calcul\u00e1-las. Todas elas foram feitas de forma iterativa , ou seja, por meio de loops (while ou for). Por exemplo, a fun\u00e7\u00e3o de fatorial: uint64_t fatorial(uint32_t n) { uint64_t r = 1; for(uint32_t i = 2; i <= n; i++) r = r * i; return r; } Possui complexidade $\\Theta(n)$ (complexidade de ordem exata). Agora, observemos essa fun\u00e7\u00e3o implementada recursivamente: uint64_t fatorial(uint32_t n) { if(n == 0) return 1; else return n * fatorial(n - 1); } Como determinar a complexidade desse algoritmo? Aprenderemos a determinar a complexidade de fun\u00e7\u00f5es recursivas nesse documento. Rela\u00e7\u00f5es de recorr\u00eancia Uma rela\u00e7\u00e3o de recorr\u00eancia \u00e9 uma rela\u00e7\u00e3o ou fun\u00e7\u00e3o recursiva que define uma sequ\u00eancia. Uma fun\u00e7\u00e3o recursiva \u00e9 uma fun\u00e7\u00e3o descrita por si mesma e que possui duas partes: o caso base e o passo recursivo . Na fun\u00e7\u00e3o de fatorial descrita anteriormente, o caso base \u00e9 n == 0 , que retorna 1 . J\u00e1 o passo recursivo \u00e9 n* fatorial(n-1) para n > 0 . Dessa forma: $$Fatorial(n) = \\begin{cases} 1 & n=0 \\ n \\times Fatorial(n-1) & n>0 \\end{cases} $$ Para resolver essas rela\u00e7\u00f5es de recorr\u00eancia, utilizamos - O m\u00e9todo da substitui\u00e7\u00e3o - O m\u00e9todo da \u00e1rvore de recurs\u00e3o - O m\u00e9todo mestre M\u00e9todo da substitui\u00e7\u00e3o","title":"Recorr\u00eancia"},{"location":"Estruturas%20de%20Dados/03-%20Recorr%C3%AAncia/#recorrencia","text":"Anteriormente, foram definidas as no\u00e7\u00f5es de complexidade de tempo e de espa\u00e7o, tal qual suas nota\u00e7\u00f5es e como calcul\u00e1-las. Todas elas foram feitas de forma iterativa , ou seja, por meio de loops (while ou for). Por exemplo, a fun\u00e7\u00e3o de fatorial: uint64_t fatorial(uint32_t n) { uint64_t r = 1; for(uint32_t i = 2; i <= n; i++) r = r * i; return r; } Possui complexidade $\\Theta(n)$ (complexidade de ordem exata). Agora, observemos essa fun\u00e7\u00e3o implementada recursivamente: uint64_t fatorial(uint32_t n) { if(n == 0) return 1; else return n * fatorial(n - 1); } Como determinar a complexidade desse algoritmo? Aprenderemos a determinar a complexidade de fun\u00e7\u00f5es recursivas nesse documento.","title":"Recorr\u00eancia"},{"location":"Estruturas%20de%20Dados/03-%20Recorr%C3%AAncia/#relacoes-de-recorrencia","text":"Uma rela\u00e7\u00e3o de recorr\u00eancia \u00e9 uma rela\u00e7\u00e3o ou fun\u00e7\u00e3o recursiva que define uma sequ\u00eancia. Uma fun\u00e7\u00e3o recursiva \u00e9 uma fun\u00e7\u00e3o descrita por si mesma e que possui duas partes: o caso base e o passo recursivo . Na fun\u00e7\u00e3o de fatorial descrita anteriormente, o caso base \u00e9 n == 0 , que retorna 1 . J\u00e1 o passo recursivo \u00e9 n* fatorial(n-1) para n > 0 . Dessa forma: $$Fatorial(n) = \\begin{cases} 1 & n=0 \\ n \\times Fatorial(n-1) & n>0 \\end{cases} $$ Para resolver essas rela\u00e7\u00f5es de recorr\u00eancia, utilizamos - O m\u00e9todo da substitui\u00e7\u00e3o - O m\u00e9todo da \u00e1rvore de recurs\u00e3o - O m\u00e9todo mestre","title":"Rela\u00e7\u00f5es de recorr\u00eancia"},{"location":"Estruturas%20de%20Dados/03-%20Recorr%C3%AAncia/#metodo-da-substituicao","text":"","title":"M\u00e9todo da substitui\u00e7\u00e3o"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/","text":"Estrutura de lista As estruturas de listas s\u00e3o sequ\u00eancias de elementos $E_i$, que utilizam ponteiros $P_i$ para referenciar o pr\u00f3ximo elemento da sequ\u00eancia. (de forma linear) Lista encadeada Possui armazenamento descont\u00ednuo em mem\u00f3ria , ou seja, n\u00e3o precisam ser armazenados de forma sequencial na mem\u00f3ria. Isso permite que o acesso seja mais r\u00e1pido e que menos tempo seja utilizado ao aumentar ou diminuir a lista, pois n\u00e3o h\u00e1 necessidade de realoca\u00e7\u00e3o de um bloco de mem\u00f3ria. O tempo de acesso da lista \u00e9 sequencial, ou seja, para acessar o elemento $E_n$, eu preciso acessar todos os elementos anteriores a ele. Isso difere de um vetor, que, sabendo o \u00edndice de um elemento, o tempo de acesso \u00e9 constante. Opera\u00e7\u00f5es principais As principais opera\u00e7\u00f5es da lista encadeada s\u00e3o: * Busca * Inser\u00e7\u00e3o: O elemento \u00e9 alocado dinamicamente, e o ponteiro \u00e9 atualizado para referenciar o novo elemento inserido na lista * Remo\u00e7\u00e3o: * Modifica\u00e7\u00e3o Cole\u00e7\u00e3o de elementos Cabe\u00e7a: \u00e9 o primeiro elemento da lista, que aponta para o elemento seguinte. Cauda: \u00c9 o \u00faltimo elemento da lista, em uma lista duplamente encadeada, podendo servir para que se volte ao longo da lista. Na lista encadeada, cada elemento possui um ponteiro unidirecional para o pr\u00f3ximo elemento da lista. Cada elemento \u00e9 recomendavelmente acessado de forma iterativa. An\u00e1lise de complexidade A an\u00e1lise de tempo para a busca \u00e9 $\\Omega (1)$ e $O(n)$ J\u00e1 para a inser\u00e7\u00e3o Lista encadeada c\u00edclica As opera\u00e7\u00f5es s\u00e3o as mesmas da lista encadeada simples, mas o ponteiro do \u00faltimo elemento aponta para o primeiro., assim, os mecanismos de busca, inser\u00e7\u00e3o e remo\u00e7\u00e3o s\u00e3o parecidos, com a diferen\u00e7a para a cauda , que se modificada, t\u00eam que apontar para o primeiro elemento novamente. Lista duplamente encadeada \u00c9 a lista encadeada com dois ponteiros, que referenciam o o elemento anterior e o pr\u00f3ximo da sequ\u00eancia. \u00c9 poss\u00edvel realizar a busca de elementos da lista em ambas as dire\u00e7\u00f5es Inser\u00e7\u00e3o A cabe\u00e7a da lista \u00e9 acessada, e se um elemento nulo for encontrado, um novo elemento \u00e9 inserido, apontando para si mesmo como pr\u00f3ximo e anterior. Quando adicionado mais um elemento, os ponteiros \"pr\u00f3ximo\" e o \"anterior\" apontam para o ponteiro novo, e os ponteiros do pr\u00f3ximo elemento apontam para o elemento anterior. E assim por diante","title":"Estrutura de lista"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#estrutura-de-lista","text":"As estruturas de listas s\u00e3o sequ\u00eancias de elementos $E_i$, que utilizam ponteiros $P_i$ para referenciar o pr\u00f3ximo elemento da sequ\u00eancia. (de forma linear)","title":"Estrutura de lista"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#lista-encadeada","text":"Possui armazenamento descont\u00ednuo em mem\u00f3ria , ou seja, n\u00e3o precisam ser armazenados de forma sequencial na mem\u00f3ria. Isso permite que o acesso seja mais r\u00e1pido e que menos tempo seja utilizado ao aumentar ou diminuir a lista, pois n\u00e3o h\u00e1 necessidade de realoca\u00e7\u00e3o de um bloco de mem\u00f3ria. O tempo de acesso da lista \u00e9 sequencial, ou seja, para acessar o elemento $E_n$, eu preciso acessar todos os elementos anteriores a ele. Isso difere de um vetor, que, sabendo o \u00edndice de um elemento, o tempo de acesso \u00e9 constante.","title":"Lista encadeada"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#operacoes-principais","text":"As principais opera\u00e7\u00f5es da lista encadeada s\u00e3o: * Busca * Inser\u00e7\u00e3o: O elemento \u00e9 alocado dinamicamente, e o ponteiro \u00e9 atualizado para referenciar o novo elemento inserido na lista * Remo\u00e7\u00e3o: * Modifica\u00e7\u00e3o","title":"Opera\u00e7\u00f5es principais"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#colecao-de-elementos","text":"Cabe\u00e7a: \u00e9 o primeiro elemento da lista, que aponta para o elemento seguinte. Cauda: \u00c9 o \u00faltimo elemento da lista, em uma lista duplamente encadeada, podendo servir para que se volte ao longo da lista. Na lista encadeada, cada elemento possui um ponteiro unidirecional para o pr\u00f3ximo elemento da lista. Cada elemento \u00e9 recomendavelmente acessado de forma iterativa.","title":"Cole\u00e7\u00e3o de elementos"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#analise-de-complexidade","text":"A an\u00e1lise de tempo para a busca \u00e9 $\\Omega (1)$ e $O(n)$ J\u00e1 para a inser\u00e7\u00e3o","title":"An\u00e1lise de complexidade"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#lista-encadeada-ciclica","text":"As opera\u00e7\u00f5es s\u00e3o as mesmas da lista encadeada simples, mas o ponteiro do \u00faltimo elemento aponta para o primeiro., assim, os mecanismos de busca, inser\u00e7\u00e3o e remo\u00e7\u00e3o s\u00e3o parecidos, com a diferen\u00e7a para a cauda , que se modificada, t\u00eam que apontar para o primeiro elemento novamente.","title":"Lista encadeada c\u00edclica"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#lista-duplamente-encadeada","text":"\u00c9 a lista encadeada com dois ponteiros, que referenciam o o elemento anterior e o pr\u00f3ximo da sequ\u00eancia. \u00c9 poss\u00edvel realizar a busca de elementos da lista em ambas as dire\u00e7\u00f5es","title":"Lista duplamente encadeada"},{"location":"Estruturas%20de%20Dados/04%20-%20Estrutura%20de%20lista/#insercao","text":"A cabe\u00e7a da lista \u00e9 acessada, e se um elemento nulo for encontrado, um novo elemento \u00e9 inserido, apontando para si mesmo como pr\u00f3ximo e anterior. Quando adicionado mais um elemento, os ponteiros \"pr\u00f3ximo\" e o \"anterior\" apontam para o ponteiro novo, e os ponteiros do pr\u00f3ximo elemento apontam para o elemento anterior. E assim por diante","title":"Inser\u00e7\u00e3o"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/","text":"Conceitos de sistemas digitais Os sistemas digitais se originam de uma tecnologia de comunica\u00e7\u00e3o antiga: o tel\u00e9grafo. O tel\u00e9grafo funcionava por meio do fechamento e da abertura de um circuito com uma chave de contato, um fio longo e uma matraca (sa\u00edda de som ou emissor da mensagem), que emitia ru\u00eddo a depender do estado do circuito. O tel\u00e9grafo utilizava pulsos el\u00e9tricos longos ou curtos, junto a espa\u00e7os, para a formula\u00e7\u00e3o de palavras e n\u00fameros. Esses pulsos eram, geralmente, o c\u00f3digo morse . Um sistema digital possui apenas dois estados: Ligado e desligado, a todo momento. N\u00e3o h\u00e1 meio termo. Os sistemas digitais modernos utilizam sinais el\u00e9tricos para representar esses estados (1 ou 0). A informa\u00e7\u00e3o \u00e9 codificada na amplitude e na dura\u00e7\u00e3o dos pulsos, bem como por meio da sequ\u00eancia desses pulsos. Um diagrama de tempo mostra os estados do sistema, bem como a mudan\u00e7a desses estados: Diagramas de tempo como esse descrevem a opera\u00e7\u00e3o detalhada de um sistema digital, podendo mostrar, inclusive, como eles mudam, e como dois ou mais sistemas digitais se relacionam. Depura\u00e7\u00e3o de sistemas digitais Para depurar e analisar sistemas digitais, faz-se uso de instrumentos como o gerador de fun\u00e7\u00e3o e o oscilosc\u00f3pio. Este \u00faltimo permite a visualiza\u00e7\u00e3o do diagrama de tempo de um sinal digital, bem como comparar diferentes sinais. Mas o que \u00e9 digital? Digital se refere aos d\u00edgitos (n\u00fameros), e se contrap\u00f5e ao anal\u00f3gico: * Anal\u00f3gico: a quantidade representada \u00e9 continuamente vari\u00e1vel, abrangendo todos os n\u00fameros reais. * Exemplo: O som, ao ser capturado por um microfone; Um veloc\u00edmetro anal\u00f3gico * Digital: A quantidade representada utiliza valores discretos, separados uniformemente, representados pelos d\u00edgitos. * Exemplo: Term\u00f4metro digital, Veloc\u00edmetro digital, contagem de coisas, etc. Sistemas digitais Sistemas digitais s\u00e3o sistemas que... Sistemas mistos S\u00e3o sistemas que utilizam tanto informa\u00e7\u00f5es digitais quanto anal\u00f3gicas. Para isso, utilizam-se conversores anal\u00f3gico-digital ou digital-anal\u00f3gico. Por exemplo, temos um sistema de regulagem de temperatura:","title":"Conceitos de sistemas digitais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/#conceitos-de-sistemas-digitais","text":"Os sistemas digitais se originam de uma tecnologia de comunica\u00e7\u00e3o antiga: o tel\u00e9grafo. O tel\u00e9grafo funcionava por meio do fechamento e da abertura de um circuito com uma chave de contato, um fio longo e uma matraca (sa\u00edda de som ou emissor da mensagem), que emitia ru\u00eddo a depender do estado do circuito. O tel\u00e9grafo utilizava pulsos el\u00e9tricos longos ou curtos, junto a espa\u00e7os, para a formula\u00e7\u00e3o de palavras e n\u00fameros. Esses pulsos eram, geralmente, o c\u00f3digo morse . Um sistema digital possui apenas dois estados: Ligado e desligado, a todo momento. N\u00e3o h\u00e1 meio termo. Os sistemas digitais modernos utilizam sinais el\u00e9tricos para representar esses estados (1 ou 0). A informa\u00e7\u00e3o \u00e9 codificada na amplitude e na dura\u00e7\u00e3o dos pulsos, bem como por meio da sequ\u00eancia desses pulsos. Um diagrama de tempo mostra os estados do sistema, bem como a mudan\u00e7a desses estados: Diagramas de tempo como esse descrevem a opera\u00e7\u00e3o detalhada de um sistema digital, podendo mostrar, inclusive, como eles mudam, e como dois ou mais sistemas digitais se relacionam.","title":"Conceitos de sistemas digitais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/#depuracao-de-sistemas-digitais","text":"Para depurar e analisar sistemas digitais, faz-se uso de instrumentos como o gerador de fun\u00e7\u00e3o e o oscilosc\u00f3pio. Este \u00faltimo permite a visualiza\u00e7\u00e3o do diagrama de tempo de um sinal digital, bem como comparar diferentes sinais.","title":"Depura\u00e7\u00e3o de sistemas digitais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/#mas-o-que-e-digital","text":"Digital se refere aos d\u00edgitos (n\u00fameros), e se contrap\u00f5e ao anal\u00f3gico: * Anal\u00f3gico: a quantidade representada \u00e9 continuamente vari\u00e1vel, abrangendo todos os n\u00fameros reais. * Exemplo: O som, ao ser capturado por um microfone; Um veloc\u00edmetro anal\u00f3gico * Digital: A quantidade representada utiliza valores discretos, separados uniformemente, representados pelos d\u00edgitos. * Exemplo: Term\u00f4metro digital, Veloc\u00edmetro digital, contagem de coisas, etc.","title":"Mas o que \u00e9 digital?"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/#sistemas-digitais","text":"Sistemas digitais s\u00e3o sistemas que...","title":"Sistemas digitais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/#sistemas-mistos","text":"S\u00e3o sistemas que utilizam tanto informa\u00e7\u00f5es digitais quanto anal\u00f3gicas. Para isso, utilizam-se conversores anal\u00f3gico-digital ou digital-anal\u00f3gico. Por exemplo, temos um sistema de regulagem de temperatura:","title":"Sistemas mistos"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/","text":"Sistemas de numera\u00e7\u00e3o Sistema Decimal Possui dez s\u00edmbolos (0-9), de forma que cada n\u00famero \u00e9 um d\u00edgito. Ex: 34,678 possui * 3 dezenas * 4 unidades * 6 d\u00e9cimos * 7 cent\u00e9simos * 8 mil\u00e9simos Os valores podem ser representados como pot\u00eancias de 10: $10^1$ $10\u2070$ $10^{-1}$ $10^{-2}$ $10^{-3}$ 3 4, 6 7 8 Sendo o valor \u00e0 esquerda o d\u00edgito mais significativo e o valor mais \u00e0 direita o d\u00edgito menos significativo , de forma que esse sistema diz se posicional , afinal, a posi\u00e7\u00e3o claramente importa. Apesar de ser conveniente para a contagem manual, o sistema decimal n\u00e3o \u00e9 conveniente para a implementa\u00e7\u00e3o em sistemas digitais, por isso utiliza-se o sistema bin\u00e1rio para tal. Sistema bin\u00e1rio Possui apenas dois s\u00edmbolos (0 e 1), chamados de bits (binary digits). Os valores s\u00e3o representados como pot\u00eancias de 2: 8 4 2 1 1/2 $2^3$ $2\u00b2$ $2^{1}$ $2^{0}$ $2^{-1}$ 1 0 1 1, 1 Esse sistema tamb\u00e9m \u00e9 posicional, de forma que o valor \u00e0 esquerda \u00e9 o bit mais significativo e o valor mais \u00e0 direita, o d\u00edgito menos significativo Para converter um valor do sistema bin\u00e1rio para o decimal, basta multiplicar os valores pelas pot\u00eancias equivalentes: $$1011,1_2^ = 1\\times2\u00b3 + 0\\times 2\u00b2 + 1 \\times 2\u00b9 + 1 \\times 2\u2070 + 1 \\times 2^{-1} = 11,5_{10}^ $$ (*L\u00ea-se 1011,1 na base 2 e 11,5 na base 10 ) O maior valor que pode ser representado por uma certa quantidade de bits \u00e9 dada por $2^n - 1$, sendo n o n\u00famero de bits usado. Dessa forma, 4 bits podem representar no m\u00e1ximo o n\u00famero 15. Representa\u00e7\u00e3o de valores bin\u00e1rios Para a convers\u00e3o e representa\u00e7\u00e3o de sinais anal\u00f3gicos para digitais pode ser feita tomando amostras do sinal anal\u00f3gico em intervalos regulares, de forma a chegar a uma aproxima\u00e7\u00e3o do valor real. O intervalo entre as amostras depende da necessidade do circuito, e intervalos pequenos requerem mais processamento","title":"Sistemas de numera\u00e7\u00e3o"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/#sistemas-de-numeracao","text":"","title":"Sistemas de numera\u00e7\u00e3o"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/#sistema-decimal","text":"Possui dez s\u00edmbolos (0-9), de forma que cada n\u00famero \u00e9 um d\u00edgito. Ex: 34,678 possui * 3 dezenas * 4 unidades * 6 d\u00e9cimos * 7 cent\u00e9simos * 8 mil\u00e9simos Os valores podem ser representados como pot\u00eancias de 10: $10^1$ $10\u2070$ $10^{-1}$ $10^{-2}$ $10^{-3}$ 3 4, 6 7 8 Sendo o valor \u00e0 esquerda o d\u00edgito mais significativo e o valor mais \u00e0 direita o d\u00edgito menos significativo , de forma que esse sistema diz se posicional , afinal, a posi\u00e7\u00e3o claramente importa. Apesar de ser conveniente para a contagem manual, o sistema decimal n\u00e3o \u00e9 conveniente para a implementa\u00e7\u00e3o em sistemas digitais, por isso utiliza-se o sistema bin\u00e1rio para tal.","title":"Sistema Decimal"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/#sistema-binario","text":"Possui apenas dois s\u00edmbolos (0 e 1), chamados de bits (binary digits). Os valores s\u00e3o representados como pot\u00eancias de 2: 8 4 2 1 1/2 $2^3$ $2\u00b2$ $2^{1}$ $2^{0}$ $2^{-1}$ 1 0 1 1, 1 Esse sistema tamb\u00e9m \u00e9 posicional, de forma que o valor \u00e0 esquerda \u00e9 o bit mais significativo e o valor mais \u00e0 direita, o d\u00edgito menos significativo Para converter um valor do sistema bin\u00e1rio para o decimal, basta multiplicar os valores pelas pot\u00eancias equivalentes: $$1011,1_2^ = 1\\times2\u00b3 + 0\\times 2\u00b2 + 1 \\times 2\u00b9 + 1 \\times 2\u2070 + 1 \\times 2^{-1} = 11,5_{10}^ $$ (*L\u00ea-se 1011,1 na base 2 e 11,5 na base 10 ) O maior valor que pode ser representado por uma certa quantidade de bits \u00e9 dada por $2^n - 1$, sendo n o n\u00famero de bits usado. Dessa forma, 4 bits podem representar no m\u00e1ximo o n\u00famero 15.","title":"Sistema bin\u00e1rio"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/#representacao-de-valores-binarios","text":"Para a convers\u00e3o e representa\u00e7\u00e3o de sinais anal\u00f3gicos para digitais pode ser feita tomando amostras do sinal anal\u00f3gico em intervalos regulares, de forma a chegar a uma aproxima\u00e7\u00e3o do valor real. O intervalo entre as amostras depende da necessidade do circuito, e intervalos pequenos requerem mais processamento","title":"Representa\u00e7\u00e3o de valores bin\u00e1rios"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/03%20-%20Circuitos%20Digitais-l%C3%B3gicos/","text":"Circuitos Digitais-L\u00f3gicos","title":"Circuitos Digitais-L\u00f3gicos"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/03%20-%20Circuitos%20Digitais-l%C3%B3gicos/#circuitos-digitais-logicos","text":"","title":"Circuitos Digitais-L\u00f3gicos"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/","text":"Aula 27/05 Transmiss\u00e3o Paralela e serial \u00c9 necess\u00e1rio realizar a transmiss\u00e3o de dados entre diferentes partes de um circuito. Para isso, existem dois tipos de transmiss\u00e3o, o paralelo e o serial . Transmiss\u00e3o paralela \u00c9 o tipo de transmiss\u00e3o em que v\u00e1rios bits s\u00e3o enviados de uma vez, de forma paralela. Ent\u00e3o por exemplo, para enviar caracteres de 8 bits, cada caractere \u00e9 enviado de uma vez, ou seja, os 8 bits s\u00e3o enviados de uma vez. Transmiss\u00e3o Serial \u00c9 o tipo de transmiss\u00e3o em que 1 bit \u00e9 transmitido por vez, sequencialmente. Dessa forma, cada informa\u00e7\u00e3o \u00e9 separada de alguma forma. Ent\u00e3o, por exemplo, para caracteres de 8 bits, cada bit do caractere \u00e9 enviado de uma vez (a cada pulso poss\u00edvel). Circuitos combinacionais e sequenciais Circuitos combinacionais A sa\u00edda deles depende das entradas, e quando a entrada \u00e9 removida, a sa\u00edda volta ao estado original. Circuitos sequenciais Possuem mem\u00f3ria, permitindo que a sa\u00edda se mantenha no estado em que foi deixada, mesmo que a entrada seja removida. Temos como exemplo, latches e flip-flops . Computador digital Um computador digital possui alguns componentes como * Os m\u00e9todos de entrada * A unidade de controle * Uma unidade l\u00f3gica/aritm\u00e9tica * As unidades de mem\u00f3ria * Os m\u00e9todos de sa\u00edda O conjunto de instru\u00e7\u00f5es em um computador \u00e9 chamado de software . O software Microcontroladores S\u00e3o computadores mais simples, e que n\u00e3o podem ser configurados pelo usu\u00e1rio. Eles possuem todos os componentes de um computador, e s\u00e3o usados em aplica\u00e7\u00f5es de sistemas embarcados (eletrodom\u00e9sticos, equipamentos de \u00e1udio e v\u00eddeo, m\u00e1quinas de autoatendimento, etc). Convers\u00f5es de sistemas de numera\u00e7\u00e3o Convers\u00e3o bin\u00e1rio-decimal colocar aqui Convers\u00e3o decimal-bin\u00e1rio Existem dois m\u00e9todos para realizar a convers\u00e3o de n\u00fameros decimais para bin\u00e1rios: * Pela soma das pot\u00eancias de dois: N(base 10) $2^{5}$ $2^{4}$ $2^{3}$ $2^{2}$ $2^{1}$ $2^{0}$ $58_{10}$ 1 1 1 0 1 0 Pelo resto das sucessivas divis\u00f5es do n\u00famero por 2, depois ordenando esse valor na ordem inversa: Sistema hexadecimal e convers\u00e3o para bin\u00e1rio (escrever tabela)","title":"Aula 27/05"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#aula-2705","text":"","title":"Aula 27/05"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#transmissao-paralela-e-serial","text":"\u00c9 necess\u00e1rio realizar a transmiss\u00e3o de dados entre diferentes partes de um circuito. Para isso, existem dois tipos de transmiss\u00e3o, o paralelo e o serial .","title":"Transmiss\u00e3o Paralela e serial"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#transmissao-paralela","text":"\u00c9 o tipo de transmiss\u00e3o em que v\u00e1rios bits s\u00e3o enviados de uma vez, de forma paralela. Ent\u00e3o por exemplo, para enviar caracteres de 8 bits, cada caractere \u00e9 enviado de uma vez, ou seja, os 8 bits s\u00e3o enviados de uma vez.","title":"Transmiss\u00e3o paralela"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#transmissao-serial","text":"\u00c9 o tipo de transmiss\u00e3o em que 1 bit \u00e9 transmitido por vez, sequencialmente. Dessa forma, cada informa\u00e7\u00e3o \u00e9 separada de alguma forma. Ent\u00e3o, por exemplo, para caracteres de 8 bits, cada bit do caractere \u00e9 enviado de uma vez (a cada pulso poss\u00edvel).","title":"Transmiss\u00e3o Serial"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#circuitos-combinacionais-e-sequenciais","text":"","title":"Circuitos combinacionais e sequenciais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#circuitos-combinacionais","text":"A sa\u00edda deles depende das entradas, e quando a entrada \u00e9 removida, a sa\u00edda volta ao estado original.","title":"Circuitos combinacionais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#circuitos-sequenciais","text":"Possuem mem\u00f3ria, permitindo que a sa\u00edda se mantenha no estado em que foi deixada, mesmo que a entrada seja removida. Temos como exemplo, latches e flip-flops .","title":"Circuitos sequenciais"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#computador-digital","text":"Um computador digital possui alguns componentes como * Os m\u00e9todos de entrada * A unidade de controle * Uma unidade l\u00f3gica/aritm\u00e9tica * As unidades de mem\u00f3ria * Os m\u00e9todos de sa\u00edda O conjunto de instru\u00e7\u00f5es em um computador \u00e9 chamado de software . O software","title":"Computador digital"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#microcontroladores","text":"S\u00e3o computadores mais simples, e que n\u00e3o podem ser configurados pelo usu\u00e1rio. Eles possuem todos os componentes de um computador, e s\u00e3o usados em aplica\u00e7\u00f5es de sistemas embarcados (eletrodom\u00e9sticos, equipamentos de \u00e1udio e v\u00eddeo, m\u00e1quinas de autoatendimento, etc).","title":"Microcontroladores"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#conversoes-de-sistemas-de-numeracao","text":"","title":"Convers\u00f5es de sistemas de numera\u00e7\u00e3o"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#conversao-binario-decimal","text":"colocar aqui","title":"Convers\u00e3o bin\u00e1rio-decimal"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#conversao-decimal-binario","text":"Existem dois m\u00e9todos para realizar a convers\u00e3o de n\u00fameros decimais para bin\u00e1rios: * Pela soma das pot\u00eancias de dois: N(base 10) $2^{5}$ $2^{4}$ $2^{3}$ $2^{2}$ $2^{1}$ $2^{0}$ $58_{10}$ 1 1 1 0 1 0 Pelo resto das sucessivas divis\u00f5es do n\u00famero por 2, depois ordenando esse valor na ordem inversa:","title":"Convers\u00e3o decimal-bin\u00e1rio"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/#sistema-hexadecimal-e-conversao-para-binario","text":"(escrever tabela)","title":"Sistema hexadecimal e convers\u00e3o para bin\u00e1rio"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/","text":"Aula 29/05 C\u00f3digo BCD BCD significa... C\u00f3digos alfanum\u00e9tricos Al\u00e9m de dados num\u00e9ricos, um computador precisa ser capaz de manipular informa\u00e7\u00f5es n\u00e3o num\u00e9ricas, como letras do alfabeto, sinais de pontua\u00e7\u00e3o, entre outros s\u00edmbolos. Um c\u00f3digo alfanum\u00e9rico inclui pelo menos: - 26 letras mai\u00fasculas - 26 letras min\u00fasculas - 10 d\u00edgitos num\u00e9ricos - 7 sinais de pontua\u00e7\u00e3o - Outros 20 a 40 caracteres como sinais de opera\u00e7\u00e3o (+,-,*,/) ou outros s\u00edmbolos (#, %, &,@,etc.) A depender do idioma e da aplica\u00e7\u00e3o, \u00e9 necess\u00e1rio incluir mais s\u00edmbolos. Por exemplo, japon\u00eas possui 3 alfabetos, e suas palavras s\u00e3o escritas por composi\u00e7\u00e3o. A tabela ASCII determina 127 s\u00edmbolos, representados por 7 bits, no m\u00e1ximo. Os s\u00edmbolos inclusos s\u00e3o os citados acima, mas alguns caracteres especiais (\\0 para termina\u00e7\u00e3o, backspace, \\n para nova linha,, \"return\" (enter) etc. ). Bytes, nibbles e palavras Byte \u00e9 um conjunto de 8 bits, que pode representar quaisquer tipos de dados. Como a pron\u00fancia \u00e9 similar a mordida em ingl\u00eas, temos tamb\u00e9m o nibble . Nibble \u00e9 uma \"mordida pequena\", representando um conjunto de 4 bits. Palavra \u00e9 um conjunto de bits variados. Ent\u00e3o a palavra com a que os processadores atuais se comunicam \u00e9 de 64 bits. Detec\u00e7\u00e3o de erros Aqui veremos m\u00e9todos de paridade para detec\u00e7\u00e3o de erros Quando uma informa\u00e7\u00e3o \u00e9 transmitida entre dispositivos, h\u00e1 possibilidade de ocorr\u00eancia de ocorr\u00eancia de erros, ou seja, a informa\u00e7\u00e3o enviada \u00e9 modificada e recebida de forma errada. A principal causa de erro de transmiss\u00e3o \u00e9 o ru\u00eddo el\u00e9trico, em que, no caminho do transmissor dos dados ao receptor, o ru\u00eddo pode ser introduzido \u00e0 transmiss\u00e3o, e se sobrepor ao sinal. A maioria dos equipamentos digitais \u00e9 projetada para ser livre de ru\u00eddo, de forma que a probabilidade de erros ocorrer \u00e9 baixa. Apesar disso, s\u00e3o transmitidos milh\u00f5es ou bilh\u00f5es de bits, o que pode gerar distor\u00e7\u00f5es ou desastres. Para detectar esses erros, existem diversos m\u00e9todos de detec\u00e7\u00e3o, como o m\u00e9todo de paridade M\u00e9todo de paridade Um bit de paridade \u00e9 um bit extra anexado ao conjunto de bits do c\u00f3digo transmitido. Esse bit pode ser 0 ou 1. Isso, de forma eficiente, pode ser utilizado para determinar a paridade do dado (par ou \u00edmpar). Esse m\u00e9todo funciona de forma que, o n\u00famero de bits altos (1) presentes em um dado sendo par, o bit de paridade \u00e9 par(0). Similarmente, se o n\u00famero de bits altos for \u00edmpar, o bit \u00e9 \u00edmpar (1). Esse bit de paridade pode ser o mais ou menos significativo. paridade 2\u2076 2\u2075 2\u2074 2\u00b3 2\u00b2 2\u00b9 2\u2070 0 (par) 1 0 0 1 1 1 0 paridade 2\u2076 2\u2075 2\u2074 2\u00b3 2\u00b2 2\u00b9 2\u2070 1 (\u00edmpar) 1 1 0 0 1 1 1 Caso as informa\u00e7\u00f5es agrupadas com o bit de paridade sejam alteradas em 1 ou 3 bits, o sistema entender\u00e1 que o dado est\u00e1 corrompido e poder\u00e1 solicitar a transmiss\u00e3o dele novamente. Ainda assim, caso 2 ou 4 bits sejam alterados, os erros n\u00e3o ser\u00e3o detectados, pois a paridade ser\u00e1 correspondente \u00e0 esperada. Existem outras t\u00e9cnicas que podem ser utilizadas para detectar e corrigir erros, mas que consomem mais bits e requerem mais processamento para detectar e corrigir os erros.","title":"Aula 29/05"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#aula-2905","text":"","title":"Aula 29/05"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#codigo-bcd","text":"BCD significa...","title":"C\u00f3digo BCD"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#codigos-alfanumetricos","text":"Al\u00e9m de dados num\u00e9ricos, um computador precisa ser capaz de manipular informa\u00e7\u00f5es n\u00e3o num\u00e9ricas, como letras do alfabeto, sinais de pontua\u00e7\u00e3o, entre outros s\u00edmbolos. Um c\u00f3digo alfanum\u00e9rico inclui pelo menos: - 26 letras mai\u00fasculas - 26 letras min\u00fasculas - 10 d\u00edgitos num\u00e9ricos - 7 sinais de pontua\u00e7\u00e3o - Outros 20 a 40 caracteres como sinais de opera\u00e7\u00e3o (+,-,*,/) ou outros s\u00edmbolos (#, %, &,@,etc.) A depender do idioma e da aplica\u00e7\u00e3o, \u00e9 necess\u00e1rio incluir mais s\u00edmbolos. Por exemplo, japon\u00eas possui 3 alfabetos, e suas palavras s\u00e3o escritas por composi\u00e7\u00e3o. A tabela ASCII determina 127 s\u00edmbolos, representados por 7 bits, no m\u00e1ximo. Os s\u00edmbolos inclusos s\u00e3o os citados acima, mas alguns caracteres especiais (\\0 para termina\u00e7\u00e3o, backspace, \\n para nova linha,, \"return\" (enter) etc. ).","title":"C\u00f3digos alfanum\u00e9tricos"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#bytes-nibbles-e-palavras","text":"Byte \u00e9 um conjunto de 8 bits, que pode representar quaisquer tipos de dados. Como a pron\u00fancia \u00e9 similar a mordida em ingl\u00eas, temos tamb\u00e9m o nibble . Nibble \u00e9 uma \"mordida pequena\", representando um conjunto de 4 bits. Palavra \u00e9 um conjunto de bits variados. Ent\u00e3o a palavra com a que os processadores atuais se comunicam \u00e9 de 64 bits.","title":"Bytes, nibbles e palavras"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#deteccao-de-erros","text":"Aqui veremos m\u00e9todos de paridade para detec\u00e7\u00e3o de erros Quando uma informa\u00e7\u00e3o \u00e9 transmitida entre dispositivos, h\u00e1 possibilidade de ocorr\u00eancia de ocorr\u00eancia de erros, ou seja, a informa\u00e7\u00e3o enviada \u00e9 modificada e recebida de forma errada. A principal causa de erro de transmiss\u00e3o \u00e9 o ru\u00eddo el\u00e9trico, em que, no caminho do transmissor dos dados ao receptor, o ru\u00eddo pode ser introduzido \u00e0 transmiss\u00e3o, e se sobrepor ao sinal. A maioria dos equipamentos digitais \u00e9 projetada para ser livre de ru\u00eddo, de forma que a probabilidade de erros ocorrer \u00e9 baixa. Apesar disso, s\u00e3o transmitidos milh\u00f5es ou bilh\u00f5es de bits, o que pode gerar distor\u00e7\u00f5es ou desastres. Para detectar esses erros, existem diversos m\u00e9todos de detec\u00e7\u00e3o, como o m\u00e9todo de paridade","title":"Detec\u00e7\u00e3o de erros"},{"location":"Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/#metodo-de-paridade","text":"Um bit de paridade \u00e9 um bit extra anexado ao conjunto de bits do c\u00f3digo transmitido. Esse bit pode ser 0 ou 1. Isso, de forma eficiente, pode ser utilizado para determinar a paridade do dado (par ou \u00edmpar). Esse m\u00e9todo funciona de forma que, o n\u00famero de bits altos (1) presentes em um dado sendo par, o bit de paridade \u00e9 par(0). Similarmente, se o n\u00famero de bits altos for \u00edmpar, o bit \u00e9 \u00edmpar (1). Esse bit de paridade pode ser o mais ou menos significativo. paridade 2\u2076 2\u2075 2\u2074 2\u00b3 2\u00b2 2\u00b9 2\u2070 0 (par) 1 0 0 1 1 1 0 paridade 2\u2076 2\u2075 2\u2074 2\u00b3 2\u00b2 2\u00b9 2\u2070 1 (\u00edmpar) 1 1 0 0 1 1 1 Caso as informa\u00e7\u00f5es agrupadas com o bit de paridade sejam alteradas em 1 ou 3 bits, o sistema entender\u00e1 que o dado est\u00e1 corrompido e poder\u00e1 solicitar a transmiss\u00e3o dele novamente. Ainda assim, caso 2 ou 4 bits sejam alterados, os erros n\u00e3o ser\u00e3o detectados, pois a paridade ser\u00e1 correspondente \u00e0 esperada. Existem outras t\u00e9cnicas que podem ser utilizadas para detectar e corrigir erros, mas que consomem mais bits e requerem mais processamento para detectar e corrigir os erros.","title":"M\u00e9todo de paridade"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/","text":"Introdu\u00e7\u00e3o Bibliografia a ser utilizada Ci\u00eancia e Tecnologia Ci\u00eancia A ci\u00eancia pode ser descrita como \"o sistema de ac\u00famulo de conhecimento confi\u00e1vel\" (Zobel), oucomo \"O conhecimento positivo sistematizado\" (emp\u00edrico e verific\u00e1vel)(Multhaif). Ela constr\u00f3i teorias para explicar fen\u00f4menos observados, possuindo car\u00e1ter te\u00f3rico e anal\u00edtico. Seus resultados s\u00e3o duradouros. Tecnologia J\u00e1 a tecnologia \u00e9 definida, dentre outras formas, como a \"aplica\u00e7\u00e3o do conhecimento nas atividades pr\u00e1ticas, como atividades industriais e econ\u00f4micas\" (Wazlawick). Ela aplica o conhecimento de forma a transformar o mundo, possuindo car\u00e1ter pr\u00e1tico e sint\u00e9tico, portanto ef\u00eamero. M\u00e9todo cient\u00edfico (segundo Marder) O m\u00e9todo cient\u00edfico pode ser descrito nos seguintes passos: 1. Estabelecer uma hip\u00f3tese 2. Elaborar um procedimento experimental para testar a hip\u00f3tese 3. Construir instrumentos, se necess\u00e1rio 4. Executar os experimentos 5. Analisar os dados obtidos e testar se a hip\u00f3tese se comprova ou n\u00e3o Trabalho O trabalho ser\u00e1 um TCC 1, que possui * Contextualiza\u00e7\u00e3o * Motiva\u00e7\u00e3o ou justficativa * Objetivos * A Revis\u00e3o Bibliogr\u00e1fica * Plano de Continuidade * Considera\u00e7\u00f5es parciais","title":"Introdu\u00e7\u00e3o"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#introducao","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#bibliografia-a-ser-utilizada","text":"","title":"Bibliografia a ser utilizada"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#ciencia-e-tecnologia","text":"","title":"Ci\u00eancia e Tecnologia"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#ciencia","text":"A ci\u00eancia pode ser descrita como \"o sistema de ac\u00famulo de conhecimento confi\u00e1vel\" (Zobel), oucomo \"O conhecimento positivo sistematizado\" (emp\u00edrico e verific\u00e1vel)(Multhaif). Ela constr\u00f3i teorias para explicar fen\u00f4menos observados, possuindo car\u00e1ter te\u00f3rico e anal\u00edtico. Seus resultados s\u00e3o duradouros.","title":"Ci\u00eancia"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#tecnologia","text":"J\u00e1 a tecnologia \u00e9 definida, dentre outras formas, como a \"aplica\u00e7\u00e3o do conhecimento nas atividades pr\u00e1ticas, como atividades industriais e econ\u00f4micas\" (Wazlawick). Ela aplica o conhecimento de forma a transformar o mundo, possuindo car\u00e1ter pr\u00e1tico e sint\u00e9tico, portanto ef\u00eamero.","title":"Tecnologia"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#metodo-cientifico-segundo-marder","text":"O m\u00e9todo cient\u00edfico pode ser descrito nos seguintes passos: 1. Estabelecer uma hip\u00f3tese 2. Elaborar um procedimento experimental para testar a hip\u00f3tese 3. Construir instrumentos, se necess\u00e1rio 4. Executar os experimentos 5. Analisar os dados obtidos e testar se a hip\u00f3tese se comprova ou n\u00e3o","title":"M\u00e9todo cient\u00edfico (segundo Marder)"},{"location":"MTPC/01-%20Introdu%C3%A7%C3%A3o/#trabalho","text":"O trabalho ser\u00e1 um TCC 1, que possui * Contextualiza\u00e7\u00e3o * Motiva\u00e7\u00e3o ou justficativa * Objetivos * A Revis\u00e3o Bibliogr\u00e1fica * Plano de Continuidade * Considera\u00e7\u00f5es parciais","title":"Trabalho"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/","text":"Especifica\u00e7\u00e3o do TCC Pesquisa (Waslawick) Atividade que busca aumentar o conhecimento sobre como o mundo funciona. Engloba de pesquisas eleitorais a pesquisas cient\u00edficas. Natureza Trabalho original: Busca apresentar conhecimento novo a partir de observa\u00e7\u00f5es e teorias constru\u00eddas para explic\u00e1-las. Resumos de assunto (reviews): sistematizam uma \u00e1rea do conhecimento indicando sua evolu\u00e7\u00e3o hist\u00f3rica e estado da arte. (Revis\u00f5es sistem\u00e1ticas ou bibliom\u00e9tricas) Objetivos (?????) Explorat\u00f3ria: O autor n\u00e3o tem necessariamente uma hip\u00f3tese ou objetivo definido em mente. O autor vai examinar um conjunto de fen\u00f4menos buscando lacunas que possam ser a base para uma pesquisa mais elaborada. Descritiva: Busca obter dados mais consistentes sobre determinado assunto sem tentar criara teorias que expliquem os fen\u00f4menos. Caracterizada pelo levantamento de dados ou aplica\u00e7\u00e3o de entrevistas e question\u00e1rios. Explicativa: analisa os dados e busca suas causas e explica\u00e7\u00f5es. \u00c9 a mais complexa e completa. Procedimentos t\u00e9cnicos Bibliogr\u00e1fica: Estudo","title":"Especifica\u00e7\u00e3o do TCC"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/#especificacao-do-tcc","text":"","title":"Especifica\u00e7\u00e3o do TCC"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/#pesquisa-waslawick","text":"Atividade que busca aumentar o conhecimento sobre como o mundo funciona. Engloba de pesquisas eleitorais a pesquisas cient\u00edficas.","title":"Pesquisa (Waslawick)"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/#natureza","text":"Trabalho original: Busca apresentar conhecimento novo a partir de observa\u00e7\u00f5es e teorias constru\u00eddas para explic\u00e1-las. Resumos de assunto (reviews): sistematizam uma \u00e1rea do conhecimento indicando sua evolu\u00e7\u00e3o hist\u00f3rica e estado da arte. (Revis\u00f5es sistem\u00e1ticas ou bibliom\u00e9tricas)","title":"Natureza"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/#objetivos","text":"Explorat\u00f3ria: O autor n\u00e3o tem necessariamente uma hip\u00f3tese ou objetivo definido em mente. O autor vai examinar um conjunto de fen\u00f4menos buscando lacunas que possam ser a base para uma pesquisa mais elaborada. Descritiva: Busca obter dados mais consistentes sobre determinado assunto sem tentar criara teorias que expliquem os fen\u00f4menos. Caracterizada pelo levantamento de dados ou aplica\u00e7\u00e3o de entrevistas e question\u00e1rios. Explicativa: analisa os dados e busca suas causas e explica\u00e7\u00f5es. \u00c9 a mais complexa e completa.","title":"Objetivos (?????)"},{"location":"MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/#procedimentos-tecnicos","text":"Bibliogr\u00e1fica: Estudo","title":"Procedimentos t\u00e9cnicos"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/","text":"Conceitos B\u00e1sicos PF Defini\u00e7\u00e3o e aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o Uma fun\u00e7\u00e3o \u00e9 definida utilizando a palavra function ou a nota\u00e7\u00e3o arrow (como demonstrado em fun\u00e7\u00f5es como express\u00f5es ). A aplica\u00e7\u00e3o \u00e9 o uso dessa fun\u00e7\u00e3o. Exemplo: function areaCirc(r){ /*###############*/ const pi = 3.14 /*## DEFINI\u00c7\u00c3O ##*/ return pi*r**2 /*##############*/ } console.log(areacirc(3)) // ## APLICA\u00c7\u00c3O ## */ Pureza const pi = 3.14 function areaCirc(r){ return pi*r**2 } Uma fun\u00e7\u00e3o \u00e9 pura quando recebe todas as constantes no escopo local. A fun\u00e7\u00e3o acima \u00e9 IMPURA , pois recebe um par\u00e2metro (pi) do escopo global. Essa fun\u00e7\u00e3o pode ser considerada pura como abaixo function areaCircPura(r){ const pi = 3.14 return pi*r**2 } acima, a constante pi \u00e9 definida no escopo LOCAL da fun\u00e7\u00e3o function areaCircImpEst(r){ return Math.PI*r**2 } Essa outra fun\u00e7\u00e3o pode ser considerada IMPURA EST\u00c1VEL , pois recebe uma constante n\u00e3o definida no escopo ( Math.PI ), mas que existe na pr\u00f3pria linguagem. Fun\u00e7\u00e3o como Express\u00e3o As fun\u00e7\u00f5es declaradas usando a palavra function (como todas acima) n\u00e3o s\u00e3o consideradas \"Cidad\u00e3s de primeira classe\", n\u00e3o estando no mesmo n\u00edvel de uma constante ou um valor qualquer. para elevar o n\u00edvel da fun\u00e7\u00e3o ao mesmo de outro, utiliza-se a chamada NOTA\u00c7\u00c3O ARROW ( => ), podendo ser utilizada da seguinte forma: const areaCircArrow = (r) => 3.14*r**2 //<-- representa\u00e7\u00e3o da fun\u00e7\u00e3o como express\u00e3o // ^constante ^nome ^express\u00e3o de mapeamento agora a fun\u00e7\u00e3o \u00e9 uma \"Cidad\u00e3 de primeira classe\" a aplica\u00e7\u00e3o da fun\u00e7\u00e3o ocorre da mesma forma [ areaCircArrow() ]. no caso de a fun\u00e7\u00e3o ter uma linha, n\u00e3o \u00e9 necess\u00e1rio usar \"return\". const areaCircArrowchaves = (r) =>{ return 3.14*r**2 } mas no caso acima(entre chaves e com mais de uma linha), \u00e9 obrigat\u00f3rio. A partir de agora, usaremos apenas fun\u00e7\u00f5es desse jeito. Fun\u00e7\u00f5es como Argumento fun\u00e7\u00f5es podem ser passadas como argumento em outras fun\u00e7\u00f5es. fun\u00e7\u00f5es que recebem e/ou retornam outras fun\u00e7\u00f5es s\u00e3o chamadas de FUN\u00c7\u00d5ES DE ALTA ORDEM . const exec = (f,x,y) => f(x,y) const pot = (b,e) => b**e console.log(exec(pot,2,3)) A fun\u00e7\u00e3o exec() acima recebe uma fun\u00e7\u00e3o e dois par\u00e2metros para aplicar na fun\u00e7\u00e3o escolhida, no caso pot() . Fun\u00e7\u00f5es como retorno, currying e aplica\u00e7\u00e3o parcial Fun\u00e7\u00f5es tamb\u00e9m podem ser retornadas por outras fun\u00e7\u00f5es, a exemplo do uso de currying junto \u00e0 aplica\u00e7\u00e3o parcial. CURRYING \u00e9 a organiza\u00e7\u00e3o de fun\u00e7\u00f5es para que seus par\u00e2metros (ou argumentos) sejam passados de forma gradual/desagregada (ou seja, com APLICA\u00c7\u00c3O PARCIAL da fun\u00e7\u00e3o). Fun\u00e7\u00e3o n\u00e3o \"currificada\" const pot = (b,e) => b**e console.log(pot(5,2)) A fun\u00e7\u00e3o que define a pot\u00eancia de forma geral, dessa forma, n\u00e3o pode ser utilizada para fazer uma nova fun\u00e7\u00e3o para calcular o quadrado ou o cubo, etc. Agora, vamos ver a vers\u00e3o \"currificada\" e apresentando aplica\u00e7\u00e3o parcial. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados const quad = potCurry(2) //exemplos de aplica\u00e7\u00e3o parcial const cubo = potCurry(3) const base = 5 console.log(quad(base), cubo(base)) Aqui, a fun\u00e7\u00e3o utiliza tanto currying quanto aplica\u00e7\u00e3o parcial, mas \u00e9 poss\u00edvel fazer a aplica\u00e7\u00e3o total da fun\u00e7\u00e3o. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados console.log(potCurry(5)(2)) //aplica\u00e7\u00e3o total de uma fun\u00e7\u00e3o desagregada Fun\u00e7\u00f5es An\u00f4nimas S\u00e3o fun\u00e7\u00f5es sem nome, podendo ser definidas na execu\u00e7\u00e3o. const exec = (f, ...nconst) => f(...nconst) console.log(exec((x,y) => x**y,5,2)) console.log(exec((a,b,c)=> a+b+c , 3,4,5)) console.log(exec((a,b,c,d)=> a+b+c+d , 3,4,5,6)) A fun\u00e7\u00e3o exec , que recebe n par\u00e2metros (uma fun\u00e7\u00e3o, qualquer n\u00famero de par\u00e2metros*), \u00e9 aplicada utilizando fun\u00e7\u00f5es an\u00f4nimas, a exemplo de (x,y) => x**y . *A aplica\u00e7\u00e3o para receber qualquer n\u00famero de par\u00e2metros (denominada par\u00e2metro REST) pode ser representada por ...nomeDaConst , sendo nomeDaConst qualquer nome para o conjunto de par\u00e2metros recebidos. ATEN\u00c7\u00c3O! Por meio disso, n\u00e3o \u00e9 poss\u00edvel utilizar aplica\u00e7\u00e3o parcial.","title":"Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#conceitos-basicos","text":"","title":"Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#pf","text":"","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#definicao-e-aplicacao-de-uma-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida utilizando a palavra function ou a nota\u00e7\u00e3o arrow (como demonstrado em fun\u00e7\u00f5es como express\u00f5es ). A aplica\u00e7\u00e3o \u00e9 o uso dessa fun\u00e7\u00e3o. Exemplo: function areaCirc(r){ /*###############*/ const pi = 3.14 /*## DEFINI\u00c7\u00c3O ##*/ return pi*r**2 /*##############*/ } console.log(areacirc(3)) // ## APLICA\u00c7\u00c3O ## */","title":"Defini\u00e7\u00e3o e aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#pureza","text":"const pi = 3.14 function areaCirc(r){ return pi*r**2 } Uma fun\u00e7\u00e3o \u00e9 pura quando recebe todas as constantes no escopo local. A fun\u00e7\u00e3o acima \u00e9 IMPURA , pois recebe um par\u00e2metro (pi) do escopo global. Essa fun\u00e7\u00e3o pode ser considerada pura como abaixo function areaCircPura(r){ const pi = 3.14 return pi*r**2 } acima, a constante pi \u00e9 definida no escopo LOCAL da fun\u00e7\u00e3o function areaCircImpEst(r){ return Math.PI*r**2 } Essa outra fun\u00e7\u00e3o pode ser considerada IMPURA EST\u00c1VEL , pois recebe uma constante n\u00e3o definida no escopo ( Math.PI ), mas que existe na pr\u00f3pria linguagem.","title":"Pureza"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcao-como-expressao","text":"As fun\u00e7\u00f5es declaradas usando a palavra function (como todas acima) n\u00e3o s\u00e3o consideradas \"Cidad\u00e3s de primeira classe\", n\u00e3o estando no mesmo n\u00edvel de uma constante ou um valor qualquer. para elevar o n\u00edvel da fun\u00e7\u00e3o ao mesmo de outro, utiliza-se a chamada NOTA\u00c7\u00c3O ARROW ( => ), podendo ser utilizada da seguinte forma: const areaCircArrow = (r) => 3.14*r**2 //<-- representa\u00e7\u00e3o da fun\u00e7\u00e3o como express\u00e3o // ^constante ^nome ^express\u00e3o de mapeamento agora a fun\u00e7\u00e3o \u00e9 uma \"Cidad\u00e3 de primeira classe\" a aplica\u00e7\u00e3o da fun\u00e7\u00e3o ocorre da mesma forma [ areaCircArrow() ]. no caso de a fun\u00e7\u00e3o ter uma linha, n\u00e3o \u00e9 necess\u00e1rio usar \"return\". const areaCircArrowchaves = (r) =>{ return 3.14*r**2 } mas no caso acima(entre chaves e com mais de uma linha), \u00e9 obrigat\u00f3rio. A partir de agora, usaremos apenas fun\u00e7\u00f5es desse jeito.","title":"Fun\u00e7\u00e3o como Express\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-como-argumento","text":"fun\u00e7\u00f5es podem ser passadas como argumento em outras fun\u00e7\u00f5es. fun\u00e7\u00f5es que recebem e/ou retornam outras fun\u00e7\u00f5es s\u00e3o chamadas de FUN\u00c7\u00d5ES DE ALTA ORDEM . const exec = (f,x,y) => f(x,y) const pot = (b,e) => b**e console.log(exec(pot,2,3)) A fun\u00e7\u00e3o exec() acima recebe uma fun\u00e7\u00e3o e dois par\u00e2metros para aplicar na fun\u00e7\u00e3o escolhida, no caso pot() .","title":"Fun\u00e7\u00f5es como Argumento"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-como-retorno-currying-e-aplicacao-parcial","text":"Fun\u00e7\u00f5es tamb\u00e9m podem ser retornadas por outras fun\u00e7\u00f5es, a exemplo do uso de currying junto \u00e0 aplica\u00e7\u00e3o parcial. CURRYING \u00e9 a organiza\u00e7\u00e3o de fun\u00e7\u00f5es para que seus par\u00e2metros (ou argumentos) sejam passados de forma gradual/desagregada (ou seja, com APLICA\u00c7\u00c3O PARCIAL da fun\u00e7\u00e3o). Fun\u00e7\u00e3o n\u00e3o \"currificada\" const pot = (b,e) => b**e console.log(pot(5,2)) A fun\u00e7\u00e3o que define a pot\u00eancia de forma geral, dessa forma, n\u00e3o pode ser utilizada para fazer uma nova fun\u00e7\u00e3o para calcular o quadrado ou o cubo, etc. Agora, vamos ver a vers\u00e3o \"currificada\" e apresentando aplica\u00e7\u00e3o parcial. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados const quad = potCurry(2) //exemplos de aplica\u00e7\u00e3o parcial const cubo = potCurry(3) const base = 5 console.log(quad(base), cubo(base)) Aqui, a fun\u00e7\u00e3o utiliza tanto currying quanto aplica\u00e7\u00e3o parcial, mas \u00e9 poss\u00edvel fazer a aplica\u00e7\u00e3o total da fun\u00e7\u00e3o. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados console.log(potCurry(5)(2)) //aplica\u00e7\u00e3o total de uma fun\u00e7\u00e3o desagregada","title":"Fun\u00e7\u00f5es como retorno, currying e aplica\u00e7\u00e3o parcial"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-anonimas","text":"S\u00e3o fun\u00e7\u00f5es sem nome, podendo ser definidas na execu\u00e7\u00e3o. const exec = (f, ...nconst) => f(...nconst) console.log(exec((x,y) => x**y,5,2)) console.log(exec((a,b,c)=> a+b+c , 3,4,5)) console.log(exec((a,b,c,d)=> a+b+c+d , 3,4,5,6)) A fun\u00e7\u00e3o exec , que recebe n par\u00e2metros (uma fun\u00e7\u00e3o, qualquer n\u00famero de par\u00e2metros*), \u00e9 aplicada utilizando fun\u00e7\u00f5es an\u00f4nimas, a exemplo de (x,y) => x**y . *A aplica\u00e7\u00e3o para receber qualquer n\u00famero de par\u00e2metros (denominada par\u00e2metro REST) pode ser representada por ...nomeDaConst , sendo nomeDaConst qualquer nome para o conjunto de par\u00e2metros recebidos. ATEN\u00c7\u00c3O! Por meio disso, n\u00e3o \u00e9 poss\u00edvel utilizar aplica\u00e7\u00e3o parcial.","title":"Fun\u00e7\u00f5es An\u00f4nimas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/","text":"Listas e Registros \u00c9 poss\u00edvel fazer cole\u00e7\u00f5es de dados em linguagens de programa\u00e7\u00e3o como o JavaScript. As cole\u00e7\u00f5es que utilizaremos aqui s\u00e3o as listas (arrays) e registros. Tamb\u00e9m ser\u00e3o vistas opera\u00e7\u00f5es as quais \u00e9 poss\u00edvel realizar com essas cole\u00e7\u00f5es de dados. Listas As listas s\u00e3o cole\u00e7\u00f5es ordenadas de dados. Esses dados podem ser de qualquer tipo, incluindo outras cole\u00e7\u00f5es de dados const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] A estrutura acima \u00e9 uma lista que cont\u00e9m diferentes strings . e cada item da lista pode ser acessado por meio de nomes[x] , sendo x o \u00edndice (sendo 0 o primeiro item) que representa cada item. const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] console.log(nomes[0]) O c\u00f3digo acima retorna: 'Jo\u00e3o' Pode existir listas dentro de listas, como no exemplo abaixo const multiplos = [[3,1],[6,3,1],[9,6,3,1],[12,9,6,3,1]] Opera\u00e7\u00f5es com Listas Podemos fazer 3 opera\u00e7\u00f5es com listas: Mapeamento Uma opera\u00e7\u00e3o de mapeamento cria uma nova lista com o mesmo n\u00famero de elementos. Esses elementos s\u00e3o modificados de acordo com uma fun\u00e7\u00e3o ou express\u00e3o definida const numeros = [2,3,5,8,10,12] const dobroLista = (lista) => lista.map((x) => x * 2) console.log(dobrolista(numeros)) O c\u00f3digo acima retorna [4,6,10,16,20,24] Para entender o c\u00f3digo anterior, \u00e9 necess\u00e1rio apontar algumas coisas: Na express\u00e3o lista.map((x) => x * 2) , x representa o elemento a ser operado na lista. Ou seja, para o caso do 2 (primeiro elemento da lista), a opera\u00e7\u00e3o realizada \u00e9 (2)= 2 * 2 , que retorna 4 A quantidade de elementos na lista N\u00c3O \u00e9 modificada S\u00e3o geradas novas listas contendo os novos valores do mapeamento. Filtragem As opera\u00e7\u00f5es de filtragem retomam uma nova lista com elementos cuja fun\u00e7\u00e3o ou express\u00e3o tenha condi\u00e7\u00e3o satisfeita. Logo, as express\u00f5es utilizadas na opera\u00e7\u00e3o s\u00e3o de valor Booleano (Verdadeiro ou Falso) const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael', 'J\u00falio'] const filtroLetra = (lista) => lista.filter((x) => x[0] == 'J') console.log(filtroLetra(nomes)) A opera\u00e7\u00e3o acima filtra os nomes cuja inicial \u00e9 a letra 'J', ent\u00e3o retorna a lista abaixo: ['Jo\u00e3o','Jos\u00e9','J\u00falio'] Perceba que: * Assim como nas express\u00f5es de mapeamento, o x na express\u00e3o de filtragem representa os elementos a serem operados na lista. Assim, caso o valor l\u00f3gico do item corresponda ao valor declarado na express\u00e3o, o item \u00e9 incluso na nova lista. Caso contr\u00e1rio, o item \u00e9 ignorado. * Caso haja apenas um item na lista, ainda assim ser\u00e1 retornada uma nova lista com o item que satisfaz a condi\u00e7\u00e3o. * Caso nenhum item da lista a ser filtrada satisfa\u00e7a a condi\u00e7\u00e3o, ser\u00e1 retomada uma lista vazia ( [] ) Redu\u00e7\u00e3o As opera\u00e7\u00f5es de redu\u00e7\u00e3o s\u00e3o opera\u00e7\u00f5es que reduzem todos os elementos da lista a um \u00fanico valor baseado na fun\u00e7\u00e3o ou express\u00e3o utilizada. Tamb\u00e9m se faz uso de um acumulador , que aqui, soma e retoma o valor desejado ao realizar a opera\u00e7\u00e3o de redu\u00e7\u00e3o (como a soma de todos os itens ou a concatena\u00e7\u00e3o de strings) const listaString = ['The', 'Quick', 'Brown', 'Fox', 'Jumps', 'Over', 'The', 'Lazy', 'Dog'] const concat = (acc, x) => `${acc} ${x}` const reducaoConcat = (lista) => lista.reduce(concat,'') console.log(reducaoConcat(listaFrase)) A opera\u00e7\u00e3o acima concatena os itens da lista (todos de tipo string ) em apenas uma string com um espa\u00e7o entre cada item. Ela retorna 'The Quick Brown Fox Jumps Over The Lazy Dog' Perceba que: * O acc \"junta\" os itens de cada lista at\u00e9 formar a frase final. * O acc tamb\u00e9m \u00e9 operado e alterado diretamente pela opera\u00e7\u00e3o de redu\u00e7\u00e3o * Dentro da declara\u00e7\u00e3o da redu\u00e7\u00e3o, o que vem ap\u00f3s a v\u00edrgula (no exemplo acima, '' ) \u00e9 o valor inicial do acumulador. As tr\u00eas opera\u00e7\u00f5es conceituadas podem ser usadas em conjunto para fazer diversas opera\u00e7\u00f5es com listas, possibilitando a ampla manipula\u00e7\u00e3o desses valores. Registros Os registros s\u00e3o estruturas de cole\u00e7\u00e3o de dados que permitem o agrupamento de informa\u00e7\u00f5es de diversos tipos ou aspectos de um mesmo objeto. const livro = { nome: 'Quinze Dias', autor: 'Vitor Martins', ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira', 'Jovem-Adulto'] } O exemplo acima \u00e9 um registro de um livro. Os atributos da lista podem ser acessados da seguinte forma: //Ex.: nome console.log(livro.nome) console.log(livro.ISBN) Isso retorna 'Quinze Dias' 8525063150 \u00c9 poss\u00edvel criar listas de registros const livros = [ { nome: \"Quinze Dias\", autor: \"Vitor Martins\", ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira']}, { nome: 'O Vampiro que Descobriu o Brasil', autor: 'Ivan Jaf', ano: 1999, ISBN: 9788508111176, temas: ['Fic\u00e7\u00e3o','Hist\u00f3ria do Brasil', 'Literatura Brasileira']} ] Para acessar os itens dos registros, pode-se utilizar-se da seguinte sintaxe console.log(livros[1].nome) O comando acima retoma: 'O Vampiro que Descobriu o Brasil' Tamb\u00e9m \u00e9 poss\u00edvel, quando relevante, utilizar registros dentro de outros registros const pessoa = { nome: 'Fernando', idade: 24, medioConcluido: true, endereco: { rua: 'Etelvino de Souza', numero: 44, bairro: 'Jabotiana', cidade: 'Aracaju', estado: 'Sergipe' } } Para acessar as informa\u00e7\u00f5es de registros dentro de registros, utiliza-se console.log(pessoa.endereco.rua) O c\u00f3digo retorna 'Etelvino de Souza' Imutabilidade de Listas e Registros O paradigma funcional considera que todos os objetos s\u00e3o imut\u00e1veis (por isso a declara\u00e7\u00e3o com uso de const ), e por isso n\u00e3o podem ser modificados ap\u00f3s declarados... Exceto listas e registros. Listas e registros, mesmo com a declara\u00e7\u00e3o usando const , podem ter seus valores modificados, como no exemplo abaixo const lista1 = [1,4,3,10,6] const lista2 = lista1.sort((a,b) => a-b) console.log(lista2) console.log(lista1) Ao contr\u00e1rio do que se espera, ambas as listas foram operadas. [1,3,4,6,10] //Lista2 [1,3,4,6,10] //Lista1 Isso ocorre porque lista2 n\u00e3o \u00e9 uma nova lista, e sim um novo \"nome\" para a lista1 . Ent\u00e3o a lista pode ser chamada pelos dois \"nomes\" atribuidos a ela. Isso prova que, mesmo que a estrutura da lista em si seja imut\u00e1vel, o conte\u00fado pode ser modificado. Para evitar que isso aconte\u00e7a, \u00e9 poss\u00edvel fazer o seguinte: Fazer uma c\u00f3pia da lista utilizando par\u00e2metros Spread [...x] const lista1 = [1,4,3,10,6] const lista2 = [...lista1].sort((a,b) => a-b) console.log(lista2) console.log(lista1) Com o uso do par\u00e2metro Spread , uma nova lista \u00e9 criada e operada sem interfer\u00eancias na original. [1,3,4,6,10] //Lista2 [1,4,3,10,6] //Lista1 Utilizar o m\u00e9todo Object.freeze() O recurso Object.freeze() congela os itens das listas (e dos registros), retornando a lista n\u00e3o modificada, mesmo que se tenha associado outro nome e modificado ela. Isso garante o princ\u00edpio de imutabilidade para listas requerido pelo paradigma funcional. Para acessar a lista e criar uma nova lista com ela, utiliza-se o m\u00e9todo anterior para copi\u00e1-la. const lista1 = Object.freeze([1,4,3,10,6]) const lista2 = lista1.sort() //retorna um erro Uso de opera\u00e7\u00f5es de mapeamento, filtragem e redu\u00e7\u00e3o, etc const lista1 = [1,4,3,10,6] const lista2 = lista1.map((x) => x**2) console.log(lista2) console.log(lista1) As opera\u00e7\u00f5es com listas retomam sempre uma nova lista com os novos valores [1,16,9,100,36] //Lista2 [1,4,3,10,6] //Lista1 Outra opera\u00e7\u00e3o que cria uma nova lista \u00e9 o slice() , que cria uma nova lista a partir de uma sele\u00e7\u00e3o de um ponto inicial e um ponto final em qualquer \u00edndice da lista. const lista1 = ['Eu', 'amo', 'pizza','de','queijo'] const lista2 = lista1.slice(2,5) console.log(lista2) console.log(lista1) O exemplo acima retorna: [ 'pizza', 'de', 'queijo' ] [ 'Eu', 'amo', 'pizza', 'de', 'queijo' ] Registros No caso de registros, as op\u00e7\u00f5es de imutabilidade se assemelham com as listas. Aqui temos o Object.freeze() e o {...x} (Spread). Note que aqui, o par\u00e2metro Spread utiliza chaves, indicando que um registro est\u00e1 sendo copiado. const cachorro = Object.freeze({ nome: 'Luma', ra\u00e7a: 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }) const cachorro2 = {...cachorro} //Spread cachorro2.nome = 'Doki' cachorro2.peso = 8.1 console.log(cachorro2) console.log(cachorro) O c\u00f3digo retorna { nome: 'Doki', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'Amarelo', peso: 8.1 } { nome: 'Luma', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'preto', peso: 7.2 } PF","title":"Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#listas-e-registros","text":"\u00c9 poss\u00edvel fazer cole\u00e7\u00f5es de dados em linguagens de programa\u00e7\u00e3o como o JavaScript. As cole\u00e7\u00f5es que utilizaremos aqui s\u00e3o as listas (arrays) e registros. Tamb\u00e9m ser\u00e3o vistas opera\u00e7\u00f5es as quais \u00e9 poss\u00edvel realizar com essas cole\u00e7\u00f5es de dados.","title":"Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#listas","text":"As listas s\u00e3o cole\u00e7\u00f5es ordenadas de dados. Esses dados podem ser de qualquer tipo, incluindo outras cole\u00e7\u00f5es de dados const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] A estrutura acima \u00e9 uma lista que cont\u00e9m diferentes strings . e cada item da lista pode ser acessado por meio de nomes[x] , sendo x o \u00edndice (sendo 0 o primeiro item) que representa cada item. const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] console.log(nomes[0]) O c\u00f3digo acima retorna: 'Jo\u00e3o' Pode existir listas dentro de listas, como no exemplo abaixo const multiplos = [[3,1],[6,3,1],[9,6,3,1],[12,9,6,3,1]]","title":"Listas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#operacoes-com-listas","text":"Podemos fazer 3 opera\u00e7\u00f5es com listas:","title":"Opera\u00e7\u00f5es com Listas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#mapeamento","text":"Uma opera\u00e7\u00e3o de mapeamento cria uma nova lista com o mesmo n\u00famero de elementos. Esses elementos s\u00e3o modificados de acordo com uma fun\u00e7\u00e3o ou express\u00e3o definida const numeros = [2,3,5,8,10,12] const dobroLista = (lista) => lista.map((x) => x * 2) console.log(dobrolista(numeros)) O c\u00f3digo acima retorna [4,6,10,16,20,24] Para entender o c\u00f3digo anterior, \u00e9 necess\u00e1rio apontar algumas coisas: Na express\u00e3o lista.map((x) => x * 2) , x representa o elemento a ser operado na lista. Ou seja, para o caso do 2 (primeiro elemento da lista), a opera\u00e7\u00e3o realizada \u00e9 (2)= 2 * 2 , que retorna 4 A quantidade de elementos na lista N\u00c3O \u00e9 modificada S\u00e3o geradas novas listas contendo os novos valores do mapeamento.","title":"Mapeamento"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#filtragem","text":"As opera\u00e7\u00f5es de filtragem retomam uma nova lista com elementos cuja fun\u00e7\u00e3o ou express\u00e3o tenha condi\u00e7\u00e3o satisfeita. Logo, as express\u00f5es utilizadas na opera\u00e7\u00e3o s\u00e3o de valor Booleano (Verdadeiro ou Falso) const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael', 'J\u00falio'] const filtroLetra = (lista) => lista.filter((x) => x[0] == 'J') console.log(filtroLetra(nomes)) A opera\u00e7\u00e3o acima filtra os nomes cuja inicial \u00e9 a letra 'J', ent\u00e3o retorna a lista abaixo: ['Jo\u00e3o','Jos\u00e9','J\u00falio'] Perceba que: * Assim como nas express\u00f5es de mapeamento, o x na express\u00e3o de filtragem representa os elementos a serem operados na lista. Assim, caso o valor l\u00f3gico do item corresponda ao valor declarado na express\u00e3o, o item \u00e9 incluso na nova lista. Caso contr\u00e1rio, o item \u00e9 ignorado. * Caso haja apenas um item na lista, ainda assim ser\u00e1 retornada uma nova lista com o item que satisfaz a condi\u00e7\u00e3o. * Caso nenhum item da lista a ser filtrada satisfa\u00e7a a condi\u00e7\u00e3o, ser\u00e1 retomada uma lista vazia ( [] )","title":"Filtragem"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#reducao","text":"As opera\u00e7\u00f5es de redu\u00e7\u00e3o s\u00e3o opera\u00e7\u00f5es que reduzem todos os elementos da lista a um \u00fanico valor baseado na fun\u00e7\u00e3o ou express\u00e3o utilizada. Tamb\u00e9m se faz uso de um acumulador , que aqui, soma e retoma o valor desejado ao realizar a opera\u00e7\u00e3o de redu\u00e7\u00e3o (como a soma de todos os itens ou a concatena\u00e7\u00e3o de strings) const listaString = ['The', 'Quick', 'Brown', 'Fox', 'Jumps', 'Over', 'The', 'Lazy', 'Dog'] const concat = (acc, x) => `${acc} ${x}` const reducaoConcat = (lista) => lista.reduce(concat,'') console.log(reducaoConcat(listaFrase)) A opera\u00e7\u00e3o acima concatena os itens da lista (todos de tipo string ) em apenas uma string com um espa\u00e7o entre cada item. Ela retorna 'The Quick Brown Fox Jumps Over The Lazy Dog' Perceba que: * O acc \"junta\" os itens de cada lista at\u00e9 formar a frase final. * O acc tamb\u00e9m \u00e9 operado e alterado diretamente pela opera\u00e7\u00e3o de redu\u00e7\u00e3o * Dentro da declara\u00e7\u00e3o da redu\u00e7\u00e3o, o que vem ap\u00f3s a v\u00edrgula (no exemplo acima, '' ) \u00e9 o valor inicial do acumulador. As tr\u00eas opera\u00e7\u00f5es conceituadas podem ser usadas em conjunto para fazer diversas opera\u00e7\u00f5es com listas, possibilitando a ampla manipula\u00e7\u00e3o desses valores.","title":"Redu\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#registros","text":"Os registros s\u00e3o estruturas de cole\u00e7\u00e3o de dados que permitem o agrupamento de informa\u00e7\u00f5es de diversos tipos ou aspectos de um mesmo objeto. const livro = { nome: 'Quinze Dias', autor: 'Vitor Martins', ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira', 'Jovem-Adulto'] } O exemplo acima \u00e9 um registro de um livro. Os atributos da lista podem ser acessados da seguinte forma: //Ex.: nome console.log(livro.nome) console.log(livro.ISBN) Isso retorna 'Quinze Dias' 8525063150 \u00c9 poss\u00edvel criar listas de registros const livros = [ { nome: \"Quinze Dias\", autor: \"Vitor Martins\", ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira']}, { nome: 'O Vampiro que Descobriu o Brasil', autor: 'Ivan Jaf', ano: 1999, ISBN: 9788508111176, temas: ['Fic\u00e7\u00e3o','Hist\u00f3ria do Brasil', 'Literatura Brasileira']} ] Para acessar os itens dos registros, pode-se utilizar-se da seguinte sintaxe console.log(livros[1].nome) O comando acima retoma: 'O Vampiro que Descobriu o Brasil' Tamb\u00e9m \u00e9 poss\u00edvel, quando relevante, utilizar registros dentro de outros registros const pessoa = { nome: 'Fernando', idade: 24, medioConcluido: true, endereco: { rua: 'Etelvino de Souza', numero: 44, bairro: 'Jabotiana', cidade: 'Aracaju', estado: 'Sergipe' } } Para acessar as informa\u00e7\u00f5es de registros dentro de registros, utiliza-se console.log(pessoa.endereco.rua) O c\u00f3digo retorna 'Etelvino de Souza'","title":"Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#imutabilidade-de-listas-e-registros","text":"O paradigma funcional considera que todos os objetos s\u00e3o imut\u00e1veis (por isso a declara\u00e7\u00e3o com uso de const ), e por isso n\u00e3o podem ser modificados ap\u00f3s declarados... Exceto listas e registros. Listas e registros, mesmo com a declara\u00e7\u00e3o usando const , podem ter seus valores modificados, como no exemplo abaixo const lista1 = [1,4,3,10,6] const lista2 = lista1.sort((a,b) => a-b) console.log(lista2) console.log(lista1) Ao contr\u00e1rio do que se espera, ambas as listas foram operadas. [1,3,4,6,10] //Lista2 [1,3,4,6,10] //Lista1 Isso ocorre porque lista2 n\u00e3o \u00e9 uma nova lista, e sim um novo \"nome\" para a lista1 . Ent\u00e3o a lista pode ser chamada pelos dois \"nomes\" atribuidos a ela. Isso prova que, mesmo que a estrutura da lista em si seja imut\u00e1vel, o conte\u00fado pode ser modificado. Para evitar que isso aconte\u00e7a, \u00e9 poss\u00edvel fazer o seguinte:","title":"Imutabilidade de Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#fazer-uma-copia-da-lista-utilizando-parametros-spread-x","text":"const lista1 = [1,4,3,10,6] const lista2 = [...lista1].sort((a,b) => a-b) console.log(lista2) console.log(lista1) Com o uso do par\u00e2metro Spread , uma nova lista \u00e9 criada e operada sem interfer\u00eancias na original. [1,3,4,6,10] //Lista2 [1,4,3,10,6] //Lista1","title":"Fazer uma c\u00f3pia da lista utilizando par\u00e2metros Spread [...x]"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#utilizar-o-metodo-objectfreeze","text":"O recurso Object.freeze() congela os itens das listas (e dos registros), retornando a lista n\u00e3o modificada, mesmo que se tenha associado outro nome e modificado ela. Isso garante o princ\u00edpio de imutabilidade para listas requerido pelo paradigma funcional. Para acessar a lista e criar uma nova lista com ela, utiliza-se o m\u00e9todo anterior para copi\u00e1-la. const lista1 = Object.freeze([1,4,3,10,6]) const lista2 = lista1.sort() //retorna um erro","title":"Utilizar o m\u00e9todo Object.freeze()"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#uso-de-operacoes-de-mapeamento-filtragem-e-reducao-etc","text":"const lista1 = [1,4,3,10,6] const lista2 = lista1.map((x) => x**2) console.log(lista2) console.log(lista1) As opera\u00e7\u00f5es com listas retomam sempre uma nova lista com os novos valores [1,16,9,100,36] //Lista2 [1,4,3,10,6] //Lista1 Outra opera\u00e7\u00e3o que cria uma nova lista \u00e9 o slice() , que cria uma nova lista a partir de uma sele\u00e7\u00e3o de um ponto inicial e um ponto final em qualquer \u00edndice da lista. const lista1 = ['Eu', 'amo', 'pizza','de','queijo'] const lista2 = lista1.slice(2,5) console.log(lista2) console.log(lista1) O exemplo acima retorna: [ 'pizza', 'de', 'queijo' ] [ 'Eu', 'amo', 'pizza', 'de', 'queijo' ]","title":"Uso de opera\u00e7\u00f5es de mapeamento, filtragem e redu\u00e7\u00e3o, etc"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#registros_1","text":"No caso de registros, as op\u00e7\u00f5es de imutabilidade se assemelham com as listas. Aqui temos o Object.freeze() e o {...x} (Spread). Note que aqui, o par\u00e2metro Spread utiliza chaves, indicando que um registro est\u00e1 sendo copiado. const cachorro = Object.freeze({ nome: 'Luma', ra\u00e7a: 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }) const cachorro2 = {...cachorro} //Spread cachorro2.nome = 'Doki' cachorro2.peso = 8.1 console.log(cachorro2) console.log(cachorro) O c\u00f3digo retorna { nome: 'Doki', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'Amarelo', peso: 8.1 } { nome: 'Luma', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }","title":"Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#pf","text":"","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/","text":"Recursividade Conceito Recursividade \u00e9 o ato de resolver um problema por meio da repeti\u00e7\u00e3o de uma mesma fun\u00e7\u00e3o, chamada de passo indutivo , invocada por ela mesma, at\u00e9 que se chegue ao chamado caso base O CASO BASE \u00e9 o valor inicial de uma sequ\u00eancia recursiva. Ele \u00e9 respons\u00e1vel por definir o fim da cadeia recursiva. J\u00e1 o PASSO INDUTIVO \u00e9 o passo necess\u00e1rio para transitar at\u00e9 o caso base, assim obtendo o resultado esperado. Ex.: Definindo uma sequ\u00eancia aritm\u00e9tica $ {3,5,7,9,11,13...}$, podemos obter qualquer valor dela por meio da fun\u00e7\u00e3o recursiva a seguir $f(0) = 3 $ $ f(n-1) + 2$ A primeira linha \u00e9 o Caso Base (que indica que $3$ \u00e9 o elemento inicial da sequ\u00eancia e que, se o \"contador\" chegar a 0, o valor ser\u00e1 $3$ ) e a segunda \u00e9 o passo indutivo (que indica que, enquanto $f(n)$ for diferente de zero, subtri-se o n em 1 e soma-se 2 ao resultado de $f(n-1)$ ). Assim, para chegar ao quarto elemento da sequ\u00eancia, seriam feitos a seguintes itera\u00e7\u00f5es: \"Ida\" at\u00e9 o caso base $f(3)$ = =$f(2) + 2$ =$f(1) + 2$ =$f(0)$ \u2192 3 \"Volta\" solucionando os passos indutivos recursivamente $f(1) + 2$ \u2192 $3 + 2 $ = 5 $f(2) + 2$ \u2192 $5 + 2$ = 7 $f(3) + 2$ \u2192 $7 + 2$ = 9 Logo, o quarto elemento da lista \u00e9 $9$ Outro exemplo de fun\u00e7\u00e3o recursiva \u00e9 a famosa Sequ\u00eancia de Fibbonacci , que pode ser representada da seguinte forma: $f(0) = 1$ (caso base 1) $f(1) = 1$ (caso base 2) $f(n-1) + f(n-2)$ (passo indutivo) Traduzindo em palavras, os casos base s\u00e3o os primeiros n\u00fameros da sequ\u00eancia $(1,1)$ e todos os outros derivam desses, nesse caso, o elemento $f(3)$ \u00e9 definido por $f(2) + f(1)$, ou melhor, $3 = 2+1$ Na programa\u00e7\u00e3o, utilizando JavaScript essa fun\u00e7\u00e3o pode ser representada por: const fib = (n) => { if (n == 0) return 1 else if (n == 1) return 1 else return fib(n - 1) + fib(n-2) } Note que a fun\u00e7\u00e3o \u00e9 chamada dentro dela mesma, e isso \u00e9 um dos aspectos que caracteriza uma fun\u00e7\u00e3o recursiva. Note tamb\u00e9m que, caso n\u00e3o existissem casos base, a fun\u00e7\u00e3o nunca terminaria de ser executada, resultando em uma \"stack overflow\" ou sobrecarga de pilha. Outro exemplo \u00e9 uma fun\u00e7\u00e3o de pot\u00eancia const potencia = (b,e) => { if (e == 0) {return 1} else return b*potencia(b,e-1) } Aqui, o caso base \u00e9 o caso de o expoente ser $0$ (o resultado \u00e9 $1$), e o passo indutivo \u00e9 que, caso o expoente seja diferente de 0, faz-se o produto da base com a fun\u00e7\u00e3o, at\u00e9 que se chegue no caso base. //fazer o de mdc e o de string Recursividade em lista At\u00e9 agora, vimos a recursividade com casos que n\u00e3o envolvem listas, mas essa funcionalidade \u00e9 extremamente \u00fatil para a manipula\u00e7\u00e3o de listas com o paradigma funcional. Para a recursividade em lista, \u00e9 necess\u00e1rio desestruturar * a lista em dois elementos: * Head (ou cabe\u00e7a): \u00e9 o elemento a ser operado na opera\u00e7\u00e3o recursiva atual. Geralmente, mas n\u00e3o para todos os casos, \u00e9 o primeiro elemento da lista * Tail (ou cauda): \u00e9 o resto da lista, em que as pr\u00f3ximas opera\u00e7\u00f5es recursivas ocorrer\u00e3o, com um dos elementos (novamente, geralmente o primeiro) da tail sendo a head da pr\u00f3xima itera\u00e7\u00e3o recursiva. *A desestrutura\u00e7\u00e3o de par\u00e2metros \u00e9 a separa\u00e7\u00e3o de certos par\u00e2metros de um objeto, uma lista ou algum outro tipo de dado: const lista = [1,2,3,5] const [x,...xs] = lista //desestrutura\u00e7\u00e3o da lista, consistindo nesse caso de pegar o primeiro elemento e associ\u00e1-lo \u00e0 constante x, e o resto da lista associado \u00e0 constante xs. Assim, x = 1 e xs = [2,3,5]. console.log(x) console.log(xs) Voltando \u00e0 recursividade, abaixo temos uma fun\u00e7\u00e3o que retorna a soma de todos os elementos da lista: const somaLista = ([x,...xs]) => { if (typeof x == 'undefined') return 0 else return x + somaLista(xs) } console.log(somaLista([3,4,12,15])) //retorna 34 A depender da fun\u00e7\u00e3o, \u00e9 poss\u00edvel ter duas cabe\u00e7as em uma mesma opera\u00e7\u00e3o recursiva, como no exemplo abaixo, que retorna o maior const maior = ([x,y,...xs]) => { if (typeof y == 'undefined') return x else if (x>y) return maior([x,...xs]) else return maior([y,...xs]) } console.log(`O maior n\u00famero da lista \u00e9 ${maior([3,4,12,15])}`) //retorna \"O maior n\u00famero da lista \u00e9 15\" *OBS: Como \u00e9 poss\u00edvel ver, utilizamos em praticamente todas as fun\u00e7\u00f5es de recursividade em lista a condi\u00e7\u00e3o typeof x == 'undefined' , pois, caso a lista esteja vazia, o tipo dela \u00e9 indefinido, ou 'undefined' . N\u00e3o \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es \u00fateis com isso. Para facilitar o trabalho, \u00e9 poss\u00edvel identificar se certo elemento da lista (a \"cabe\u00e7a\") est\u00e1 vazio, pois se estiver, a lista est\u00e1 vazia (ou no caso acima, resta apenas um elemento, que \u00e9 o que queremos). Assim, \u00e9 poss\u00edvel definir uma fun\u00e7\u00e3o de uso geral: const undef = (x) => typeof x == 'undefined' Essa fun\u00e7\u00e3o verifica se o tipo da constante selecionada \u00e9 undefined e retorna um valor do tipo bool true ou false caso seja ou n\u00e3o seja. A partir da recursividade, \u00e9 poss\u00edvel criar fun\u00e7\u00f5es j\u00e1 existentes, a fim de entender como elas funcionariam no paradigma funcional. Abaixo, temos a fun\u00e7\u00e3o map , implementada em JS: const lista1 = [2,3,8,10] const lista2 = lista1.map((x) => x**2) console.log(lista2) // retorna [4,9,64,100] Como explicado no documento de Listas e registros a fun\u00e7\u00e3o map retorna uma nova lista com os elementos modificados de acordo com a fun\u00e7\u00e3o definida na sua declara\u00e7\u00e3o. Podemos criar uma fun\u00e7\u00e3o map com recursividade, da seguinte forma: const meuMap = ([x,...xs], f) => { if (typeof x == 'undefined') return [] else return [f(x), ...meuMap(xs,f)] } PF","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#recursividade","text":"","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#conceito","text":"Recursividade \u00e9 o ato de resolver um problema por meio da repeti\u00e7\u00e3o de uma mesma fun\u00e7\u00e3o, chamada de passo indutivo , invocada por ela mesma, at\u00e9 que se chegue ao chamado caso base O CASO BASE \u00e9 o valor inicial de uma sequ\u00eancia recursiva. Ele \u00e9 respons\u00e1vel por definir o fim da cadeia recursiva. J\u00e1 o PASSO INDUTIVO \u00e9 o passo necess\u00e1rio para transitar at\u00e9 o caso base, assim obtendo o resultado esperado. Ex.: Definindo uma sequ\u00eancia aritm\u00e9tica $ {3,5,7,9,11,13...}$, podemos obter qualquer valor dela por meio da fun\u00e7\u00e3o recursiva a seguir $f(0) = 3 $ $ f(n-1) + 2$ A primeira linha \u00e9 o Caso Base (que indica que $3$ \u00e9 o elemento inicial da sequ\u00eancia e que, se o \"contador\" chegar a 0, o valor ser\u00e1 $3$ ) e a segunda \u00e9 o passo indutivo (que indica que, enquanto $f(n)$ for diferente de zero, subtri-se o n em 1 e soma-se 2 ao resultado de $f(n-1)$ ). Assim, para chegar ao quarto elemento da sequ\u00eancia, seriam feitos a seguintes itera\u00e7\u00f5es: \"Ida\" at\u00e9 o caso base $f(3)$ = =$f(2) + 2$ =$f(1) + 2$ =$f(0)$ \u2192 3 \"Volta\" solucionando os passos indutivos recursivamente $f(1) + 2$ \u2192 $3 + 2 $ = 5 $f(2) + 2$ \u2192 $5 + 2$ = 7 $f(3) + 2$ \u2192 $7 + 2$ = 9 Logo, o quarto elemento da lista \u00e9 $9$ Outro exemplo de fun\u00e7\u00e3o recursiva \u00e9 a famosa Sequ\u00eancia de Fibbonacci , que pode ser representada da seguinte forma: $f(0) = 1$ (caso base 1) $f(1) = 1$ (caso base 2) $f(n-1) + f(n-2)$ (passo indutivo) Traduzindo em palavras, os casos base s\u00e3o os primeiros n\u00fameros da sequ\u00eancia $(1,1)$ e todos os outros derivam desses, nesse caso, o elemento $f(3)$ \u00e9 definido por $f(2) + f(1)$, ou melhor, $3 = 2+1$ Na programa\u00e7\u00e3o, utilizando JavaScript essa fun\u00e7\u00e3o pode ser representada por: const fib = (n) => { if (n == 0) return 1 else if (n == 1) return 1 else return fib(n - 1) + fib(n-2) } Note que a fun\u00e7\u00e3o \u00e9 chamada dentro dela mesma, e isso \u00e9 um dos aspectos que caracteriza uma fun\u00e7\u00e3o recursiva. Note tamb\u00e9m que, caso n\u00e3o existissem casos base, a fun\u00e7\u00e3o nunca terminaria de ser executada, resultando em uma \"stack overflow\" ou sobrecarga de pilha. Outro exemplo \u00e9 uma fun\u00e7\u00e3o de pot\u00eancia const potencia = (b,e) => { if (e == 0) {return 1} else return b*potencia(b,e-1) } Aqui, o caso base \u00e9 o caso de o expoente ser $0$ (o resultado \u00e9 $1$), e o passo indutivo \u00e9 que, caso o expoente seja diferente de 0, faz-se o produto da base com a fun\u00e7\u00e3o, at\u00e9 que se chegue no caso base. //fazer o de mdc e o de string","title":"Conceito"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#recursividade-em-lista","text":"At\u00e9 agora, vimos a recursividade com casos que n\u00e3o envolvem listas, mas essa funcionalidade \u00e9 extremamente \u00fatil para a manipula\u00e7\u00e3o de listas com o paradigma funcional. Para a recursividade em lista, \u00e9 necess\u00e1rio desestruturar * a lista em dois elementos: * Head (ou cabe\u00e7a): \u00e9 o elemento a ser operado na opera\u00e7\u00e3o recursiva atual. Geralmente, mas n\u00e3o para todos os casos, \u00e9 o primeiro elemento da lista * Tail (ou cauda): \u00e9 o resto da lista, em que as pr\u00f3ximas opera\u00e7\u00f5es recursivas ocorrer\u00e3o, com um dos elementos (novamente, geralmente o primeiro) da tail sendo a head da pr\u00f3xima itera\u00e7\u00e3o recursiva. *A desestrutura\u00e7\u00e3o de par\u00e2metros \u00e9 a separa\u00e7\u00e3o de certos par\u00e2metros de um objeto, uma lista ou algum outro tipo de dado: const lista = [1,2,3,5] const [x,...xs] = lista //desestrutura\u00e7\u00e3o da lista, consistindo nesse caso de pegar o primeiro elemento e associ\u00e1-lo \u00e0 constante x, e o resto da lista associado \u00e0 constante xs. Assim, x = 1 e xs = [2,3,5]. console.log(x) console.log(xs) Voltando \u00e0 recursividade, abaixo temos uma fun\u00e7\u00e3o que retorna a soma de todos os elementos da lista: const somaLista = ([x,...xs]) => { if (typeof x == 'undefined') return 0 else return x + somaLista(xs) } console.log(somaLista([3,4,12,15])) //retorna 34 A depender da fun\u00e7\u00e3o, \u00e9 poss\u00edvel ter duas cabe\u00e7as em uma mesma opera\u00e7\u00e3o recursiva, como no exemplo abaixo, que retorna o maior const maior = ([x,y,...xs]) => { if (typeof y == 'undefined') return x else if (x>y) return maior([x,...xs]) else return maior([y,...xs]) } console.log(`O maior n\u00famero da lista \u00e9 ${maior([3,4,12,15])}`) //retorna \"O maior n\u00famero da lista \u00e9 15\" *OBS: Como \u00e9 poss\u00edvel ver, utilizamos em praticamente todas as fun\u00e7\u00f5es de recursividade em lista a condi\u00e7\u00e3o typeof x == 'undefined' , pois, caso a lista esteja vazia, o tipo dela \u00e9 indefinido, ou 'undefined' . N\u00e3o \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es \u00fateis com isso. Para facilitar o trabalho, \u00e9 poss\u00edvel identificar se certo elemento da lista (a \"cabe\u00e7a\") est\u00e1 vazio, pois se estiver, a lista est\u00e1 vazia (ou no caso acima, resta apenas um elemento, que \u00e9 o que queremos). Assim, \u00e9 poss\u00edvel definir uma fun\u00e7\u00e3o de uso geral: const undef = (x) => typeof x == 'undefined' Essa fun\u00e7\u00e3o verifica se o tipo da constante selecionada \u00e9 undefined e retorna um valor do tipo bool true ou false caso seja ou n\u00e3o seja. A partir da recursividade, \u00e9 poss\u00edvel criar fun\u00e7\u00f5es j\u00e1 existentes, a fim de entender como elas funcionariam no paradigma funcional. Abaixo, temos a fun\u00e7\u00e3o map , implementada em JS: const lista1 = [2,3,8,10] const lista2 = lista1.map((x) => x**2) console.log(lista2) // retorna [4,9,64,100] Como explicado no documento de Listas e registros a fun\u00e7\u00e3o map retorna uma nova lista com os elementos modificados de acordo com a fun\u00e7\u00e3o definida na sua declara\u00e7\u00e3o. Podemos criar uma fun\u00e7\u00e3o map com recursividade, da seguinte forma: const meuMap = ([x,...xs], f) => { if (typeof x == 'undefined') return [] else return [f(x), ...meuMap(xs,f)] }","title":"Recursividade em lista"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#pf","text":"","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/Menu/","text":"PF T\u00edtulo Conceitos B\u00e1sicos Listas e Registros Recursividade","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/Menu/#pf","text":"T\u00edtulo Conceitos B\u00e1sicos Listas e Registros Recursividade","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/","text":"Conceitos iniciais Programa e algoritmo Algoritmos s\u00e3o sequ\u00eancias de passos a serem executados. Esses passos s\u00e3o bem descritos, sem ambiguidades, e que podem ser executados de alguma forma. Por exemplo, para calcular a soma de dois n\u00fameros, voc\u00ea toma esses dois n\u00famero, processa-os de forma a som\u00e1-los, e retoma o resultado dessa soma. Um programa \u00e9 uma sequ\u00eancia de passos escrita em uma linguagem de computador para executar a\u00e7\u00f5es ou resolver problemas. Eles s\u00e3o essenciais para o funcionamento de um computador, afinal sem programas, a m\u00e1quina \u00e9 in\u00fatil. Seu Sistema Operacional(Windows,Linux, Mac OS ou BSD) s\u00e3o programas; seu aplicativo de calculadora \u00e9 um programa; o navegador pelo qual voc\u00ea provavelmente l\u00ea isso \u00e9 um programa. Para a cria\u00e7\u00e3o de programas, \u00e9 necess\u00e1ria alguma interface entre o programador e o computador. Monitores, terminais de computador, ou impressoras para ver os comandos digitados e os resultados; dispositivos para a entrada de dados (um teclado, por exemplo); e algo que seja poss\u00edvel escrever esses programas de forma que o computador entenda. \u00c9 a\u00ed que entram as linguagens de programa\u00e7\u00e3o. O computador s\u00f3 entende instru\u00e7\u00f5es em bin\u00e1rio, isto \u00e9, 0 e 1, sim ou n\u00e3o. \u00c9 com sequ\u00eancias de zeros e uns que os programas rodam no computador. Mas escrever em bin\u00e1rio (tamb\u00e9m chamado de linguagem de m\u00e1quina) \u00e9 trabalhoso e dif\u00edcil. Por isso, foram inventadas diferentes linguagens de programa\u00e7\u00e3o, como assembly, que, mesmo sendo mais f\u00e1cil que linguagem de m\u00e1quina, ainda \u00e9 complicado para padr\u00f5es atuais. Ent\u00e3o, ao longo do tempo, diferentes linguagens foram constru\u00eddas de forma a facilitar ainda mais a constru\u00e7\u00e3o e a cria\u00e7\u00e3o de programas, como COBOL, Fortran, Lisp, C, Java, entre outras. Aqui, daremos enfoque na linguagem C. Trin\u00f4mio Para o funcionamento do programa, \u00e9 necess\u00e1rio entender o objetivo desse programa, e assim entender: A entrada: Os dados inseridos para cumprir o objetivo O processamento: A manipula\u00e7\u00e3o dos dados para obter o resultado desejado A sa\u00edda: O resultado do algoritmo A linguagem C C foi criada nos Laborat\u00f3rios Bell (AT&T) por Denis Ritchie e Ken Thompson em 1970. \u00c9 uma linguagem de alto n\u00edvel, mesmo que considerada por alguns como de n\u00edvel m\u00e9dio devido ao acesso de mem\u00f3ria. \u00c9 compilada, estruturada e fortemente tipada. Ser uma linguagem compilada significa que o c\u00f3digo do programa \u00e9 convertido para linguagem de m\u00e1quina por inteiro. Isso \u00e9 diferente de linguagens interpretadas,como python, que l\u00ea o c\u00f3digo e o converte linha a linha. Termos C\u00f3digo fonte: \u00e9 o c\u00f3digo do programa. Um exemplo \u00e9 um c\u00f3digo em C C\u00f3digo objeto: O c\u00f3digo objeto \u00e9 o produto da compila\u00e7\u00e3o de um c\u00f3digo fonte, que agora \u00e9 transformado em linguagem de m\u00e1quina. Comp\u00f5e uma parte do execut\u00e1vel gerado pelo compilador do C Linkeditor: \u00c9 o respons\u00e1vel por requisitar e agregar todas as partes necess\u00e1rias para a execu\u00e7\u00e3o de um programa. \u00c9 o respons\u00e1vel por incluir as bibliotecas necess\u00e1rias para compilar o problema C\u00f3digo execut\u00e1vel: \u00c9 o produto final da compila\u00e7\u00e3o. \u00c9 esse o arquivo que o usu\u00e1rio tem acesso e pode executar a l\u00f3gica do programa. Biblioteca: \u00c9 um conjunto de instru\u00e7\u00f5es e fun\u00e7\u00f5es que podem ser utilizados em diferentes programas, para diferentes prop\u00f3sitos Tempo de compila\u00e7\u00e3o: \u00c9 o momento em que o c\u00f3digo fonte \u00e9 lido pelo compilador. Aqui, o compilador pode indicar erros que o impedem de ser transformado em c\u00f3digo objeto (a aus\u00eancia de um ;, por exemplo). Tempo de execu\u00e7\u00e3o (runtime): Aqui \u00e9 onde podem ser indicados erros ocorridos durante a execu\u00e7\u00e3o do programa, como uma exce\u00e7\u00e3o de ponto flutuante. Exemplo de programa em C #include <stdio.h> /*Biblioteca*/ int main(){ //fun\u00e7\u00e3o main printf(\"Hello world!\"); } O include <stdio.h> significa que a biblioteca stdio.h (standard Input/Output) \u00e9 requisitada para a execu\u00e7\u00e3o do programa. Essa biblioteca \u00e9 a principal biblioteca da linguagem, pois cont\u00e9m todas as fun\u00e7\u00f5es b\u00e1sicas. A fun\u00e7\u00e3o main() \u00e9 a principal fun\u00e7\u00e3o do C. Ela executa as fun\u00e7\u00f5es subsequentes necess\u00e1rias para executar o programa. Vari\u00e1veis Vari\u00e1veis s\u00e3o dados guardados de forma provis\u00f3ria na mem\u00f3ria RAM da m\u00e1quina. Cada um desses dados \u00e9 endere\u00e7ado. As vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria. Ex.: Um caractere ocupa 1 byte, enquanto um n\u00famero inteiro (int) ocupa 4 bytes. No caso da linguagem C, as regras de nomenclatura s\u00e3o: O primeiro caractere pode ser uma letra ou _(underline) Caracteres mai\u00fasculos e min\u00fasculos s\u00e3o diferentenciados (Case sensitive) As vari\u00e1veis n\u00e3o podem ser iguais a palavras reservadas da linguagem Os nomes das vari\u00e1veis n\u00e3o podem possuir espa\u00e7os em branco As vari\u00e1veis podem ser: * Locais (declaradas dentro de fun\u00e7\u00f5es) * Na defini\u00e7\u00e3o de par\u00e3metros de fun\u00e7\u00e3o * Fora de todas as fun\u00e7\u00f5es (vari\u00e1veis globais) * Tipos de dados Como indicado antes, as vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria a depender do tipo de dado armazenado nela. Os tipos de dados podem ser usados para determinar a quantidade de mem\u00f3ria ocupada e para determinar se \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es com outras vari\u00e1veis. (Ex.: uma vari\u00e1vel de tipo int n\u00e3o pode realizar opera\u00e7\u00f5es com uma vari\u00e1vel do tipo char) Tipo Representa Tamanho em bits Tamanho em bytes Int n\u00famero inteiro 16 ou 32 2 ou 4 float n\u00famero racional 32 4 double n\u00famero racional 64 8 long int n\u00famero inteiro 64 8 char valores alfanum\u00e9ricos 8 1 Coment\u00e1rios em C Os coment\u00e1rios em C s\u00e3o feitos com /* coment\u00e1rio */ Operadores aritm\u00e9ticos C, assim como diversas linguagens, possui diversos operadores aritm\u00e9ticos, l\u00f3gicos e relacionais. aritm\u00e9ticos L\u00f3gicos Relacionais + (adi\u00e7\u00e3o) && (AND) == (igual a) - (subtra\u00e7\u00e3o) || (OR) < (menor que) * (multiplica\u00e7\u00e3o) ! (NOT) > (menor que) / (divis\u00e3o) \u02c6(XOR) != (diferente de) <= (menor ou igual) >= (maior ou igual) M\u00e1scaras de formata\u00e7\u00e3o de E/S %d: Int %f: Float %c: Char %s: String Essas m\u00e1scaras s\u00e3o usadas para capturar ou exibir dados de vari\u00e1veis. Ex.: int numero = 3; printf(\"%d\", numero); Entrada e Sa\u00edda A entrada de dados se d\u00e1 da seguinte forma: int numero; scanf(\"%d\", &numero); O & \u00e9 o operador de endere\u00e7amento de valores na mem\u00f3ria. J\u00e1 a sa\u00edda se d\u00e1 da seguinte forma int numero = 3; printf(\"%d\", n\u00famero) (Programa) C\u00e1lculo de m\u00e9dia aritm\u00e9tica da nota de dois alunos #include <stdio.h> float nota1,nota2,media; void main(){ printf(\"Insira a primeira nota: \"); scanf(\"%f\", &nota1); printf(\"\\n Insira a segunda nota: \"); scanf(\"%f\",&nota2); media = (nota1 + nota2)/2; printf(\"\\n A m\u00e9dia das notas \u00e9 %f\",media); } PI (tag)","title":"Conceitos iniciais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#conceitos-iniciais","text":"","title":"Conceitos iniciais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#programa-e-algoritmo","text":"Algoritmos s\u00e3o sequ\u00eancias de passos a serem executados. Esses passos s\u00e3o bem descritos, sem ambiguidades, e que podem ser executados de alguma forma. Por exemplo, para calcular a soma de dois n\u00fameros, voc\u00ea toma esses dois n\u00famero, processa-os de forma a som\u00e1-los, e retoma o resultado dessa soma. Um programa \u00e9 uma sequ\u00eancia de passos escrita em uma linguagem de computador para executar a\u00e7\u00f5es ou resolver problemas. Eles s\u00e3o essenciais para o funcionamento de um computador, afinal sem programas, a m\u00e1quina \u00e9 in\u00fatil. Seu Sistema Operacional(Windows,Linux, Mac OS ou BSD) s\u00e3o programas; seu aplicativo de calculadora \u00e9 um programa; o navegador pelo qual voc\u00ea provavelmente l\u00ea isso \u00e9 um programa. Para a cria\u00e7\u00e3o de programas, \u00e9 necess\u00e1ria alguma interface entre o programador e o computador. Monitores, terminais de computador, ou impressoras para ver os comandos digitados e os resultados; dispositivos para a entrada de dados (um teclado, por exemplo); e algo que seja poss\u00edvel escrever esses programas de forma que o computador entenda. \u00c9 a\u00ed que entram as linguagens de programa\u00e7\u00e3o. O computador s\u00f3 entende instru\u00e7\u00f5es em bin\u00e1rio, isto \u00e9, 0 e 1, sim ou n\u00e3o. \u00c9 com sequ\u00eancias de zeros e uns que os programas rodam no computador. Mas escrever em bin\u00e1rio (tamb\u00e9m chamado de linguagem de m\u00e1quina) \u00e9 trabalhoso e dif\u00edcil. Por isso, foram inventadas diferentes linguagens de programa\u00e7\u00e3o, como assembly, que, mesmo sendo mais f\u00e1cil que linguagem de m\u00e1quina, ainda \u00e9 complicado para padr\u00f5es atuais. Ent\u00e3o, ao longo do tempo, diferentes linguagens foram constru\u00eddas de forma a facilitar ainda mais a constru\u00e7\u00e3o e a cria\u00e7\u00e3o de programas, como COBOL, Fortran, Lisp, C, Java, entre outras. Aqui, daremos enfoque na linguagem C.","title":"Programa e algoritmo"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#trinomio","text":"Para o funcionamento do programa, \u00e9 necess\u00e1rio entender o objetivo desse programa, e assim entender: A entrada: Os dados inseridos para cumprir o objetivo O processamento: A manipula\u00e7\u00e3o dos dados para obter o resultado desejado A sa\u00edda: O resultado do algoritmo","title":"Trin\u00f4mio"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#a-linguagem-c","text":"C foi criada nos Laborat\u00f3rios Bell (AT&T) por Denis Ritchie e Ken Thompson em 1970. \u00c9 uma linguagem de alto n\u00edvel, mesmo que considerada por alguns como de n\u00edvel m\u00e9dio devido ao acesso de mem\u00f3ria. \u00c9 compilada, estruturada e fortemente tipada. Ser uma linguagem compilada significa que o c\u00f3digo do programa \u00e9 convertido para linguagem de m\u00e1quina por inteiro. Isso \u00e9 diferente de linguagens interpretadas,como python, que l\u00ea o c\u00f3digo e o converte linha a linha.","title":"A linguagem C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#termos","text":"C\u00f3digo fonte: \u00e9 o c\u00f3digo do programa. Um exemplo \u00e9 um c\u00f3digo em C C\u00f3digo objeto: O c\u00f3digo objeto \u00e9 o produto da compila\u00e7\u00e3o de um c\u00f3digo fonte, que agora \u00e9 transformado em linguagem de m\u00e1quina. Comp\u00f5e uma parte do execut\u00e1vel gerado pelo compilador do C Linkeditor: \u00c9 o respons\u00e1vel por requisitar e agregar todas as partes necess\u00e1rias para a execu\u00e7\u00e3o de um programa. \u00c9 o respons\u00e1vel por incluir as bibliotecas necess\u00e1rias para compilar o problema C\u00f3digo execut\u00e1vel: \u00c9 o produto final da compila\u00e7\u00e3o. \u00c9 esse o arquivo que o usu\u00e1rio tem acesso e pode executar a l\u00f3gica do programa. Biblioteca: \u00c9 um conjunto de instru\u00e7\u00f5es e fun\u00e7\u00f5es que podem ser utilizados em diferentes programas, para diferentes prop\u00f3sitos Tempo de compila\u00e7\u00e3o: \u00c9 o momento em que o c\u00f3digo fonte \u00e9 lido pelo compilador. Aqui, o compilador pode indicar erros que o impedem de ser transformado em c\u00f3digo objeto (a aus\u00eancia de um ;, por exemplo). Tempo de execu\u00e7\u00e3o (runtime): Aqui \u00e9 onde podem ser indicados erros ocorridos durante a execu\u00e7\u00e3o do programa, como uma exce\u00e7\u00e3o de ponto flutuante.","title":"Termos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#exemplo-de-programa-em-c","text":"#include <stdio.h> /*Biblioteca*/ int main(){ //fun\u00e7\u00e3o main printf(\"Hello world!\"); } O include <stdio.h> significa que a biblioteca stdio.h (standard Input/Output) \u00e9 requisitada para a execu\u00e7\u00e3o do programa. Essa biblioteca \u00e9 a principal biblioteca da linguagem, pois cont\u00e9m todas as fun\u00e7\u00f5es b\u00e1sicas. A fun\u00e7\u00e3o main() \u00e9 a principal fun\u00e7\u00e3o do C. Ela executa as fun\u00e7\u00f5es subsequentes necess\u00e1rias para executar o programa.","title":"Exemplo de programa em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#variaveis","text":"Vari\u00e1veis s\u00e3o dados guardados de forma provis\u00f3ria na mem\u00f3ria RAM da m\u00e1quina. Cada um desses dados \u00e9 endere\u00e7ado. As vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria. Ex.: Um caractere ocupa 1 byte, enquanto um n\u00famero inteiro (int) ocupa 4 bytes. No caso da linguagem C, as regras de nomenclatura s\u00e3o: O primeiro caractere pode ser uma letra ou _(underline) Caracteres mai\u00fasculos e min\u00fasculos s\u00e3o diferentenciados (Case sensitive) As vari\u00e1veis n\u00e3o podem ser iguais a palavras reservadas da linguagem Os nomes das vari\u00e1veis n\u00e3o podem possuir espa\u00e7os em branco As vari\u00e1veis podem ser: * Locais (declaradas dentro de fun\u00e7\u00f5es) * Na defini\u00e7\u00e3o de par\u00e3metros de fun\u00e7\u00e3o * Fora de todas as fun\u00e7\u00f5es (vari\u00e1veis globais) *","title":"Vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#tipos-de-dados","text":"Como indicado antes, as vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria a depender do tipo de dado armazenado nela. Os tipos de dados podem ser usados para determinar a quantidade de mem\u00f3ria ocupada e para determinar se \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es com outras vari\u00e1veis. (Ex.: uma vari\u00e1vel de tipo int n\u00e3o pode realizar opera\u00e7\u00f5es com uma vari\u00e1vel do tipo char) Tipo Representa Tamanho em bits Tamanho em bytes Int n\u00famero inteiro 16 ou 32 2 ou 4 float n\u00famero racional 32 4 double n\u00famero racional 64 8 long int n\u00famero inteiro 64 8 char valores alfanum\u00e9ricos 8 1","title":"Tipos de dados"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#comentarios-em-c","text":"Os coment\u00e1rios em C s\u00e3o feitos com /* coment\u00e1rio */","title":"Coment\u00e1rios em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#operadores-aritmeticos","text":"C, assim como diversas linguagens, possui diversos operadores aritm\u00e9ticos, l\u00f3gicos e relacionais. aritm\u00e9ticos L\u00f3gicos Relacionais + (adi\u00e7\u00e3o) && (AND) == (igual a) - (subtra\u00e7\u00e3o) || (OR) < (menor que) * (multiplica\u00e7\u00e3o) ! (NOT) > (menor que) / (divis\u00e3o) \u02c6(XOR) != (diferente de) <= (menor ou igual) >= (maior ou igual)","title":"Operadores aritm\u00e9ticos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#mascaras-de-formatacao-de-es","text":"%d: Int %f: Float %c: Char %s: String Essas m\u00e1scaras s\u00e3o usadas para capturar ou exibir dados de vari\u00e1veis. Ex.: int numero = 3; printf(\"%d\", numero);","title":"M\u00e1scaras de formata\u00e7\u00e3o de E/S"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#entrada-e-saida","text":"A entrada de dados se d\u00e1 da seguinte forma: int numero; scanf(\"%d\", &numero); O & \u00e9 o operador de endere\u00e7amento de valores na mem\u00f3ria. J\u00e1 a sa\u00edda se d\u00e1 da seguinte forma int numero = 3; printf(\"%d\", n\u00famero)","title":"Entrada e Sa\u00edda"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#programa-calculo-de-media-aritmetica-da-nota-de-dois-alunos","text":"#include <stdio.h> float nota1,nota2,media; void main(){ printf(\"Insira a primeira nota: \"); scanf(\"%f\", &nota1); printf(\"\\n Insira a segunda nota: \"); scanf(\"%f\",&nota2); media = (nota1 + nota2)/2; printf(\"\\n A m\u00e9dia das notas \u00e9 %f\",media); }","title":"(Programa) C\u00e1lculo de m\u00e9dia aritm\u00e9tica da nota de dois alunos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#pi-tag","text":"","title":"PI (tag)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/","text":"Operadores relacionais e condicionais Operadores relacionais A linguagem C possui operadores chamados, operadores relacionais, que servem para comparar dados (vari\u00e1veis, inteiros, strings, etc.). Alguns operadores relacionais s\u00e3o: < (Menor que) > (Maior que) <= (Menor ou igual) >= (Maior ou igual) == (igual) != (diferente de) Baseado nisso, podemos realizar opera\u00e7\u00f5es de compara\u00e7\u00e3o em chamadas estruturas de decis\u00e3o . Estruturas de decis\u00e3o simples As estruturas de decis\u00e3o simples interrompem o fluxo de tempo de execu\u00e7\u00e3o do programa a depender dos valores passados. Elas s\u00e3o representadas pelas palavras if ... if (\"condi\u00e7\u00e3o\"){ print(\"condi\u00e7\u00e3o satisfeita\"); } ... No c\u00f3digo acima, a palavra \"condi\u00e7\u00e3o\" pode ser substituida por alguma compara\u00e7\u00e3o, e caso satisfeita, ela executar\u00e1 o c\u00f3digo determinado, nesse caso print(\"Condi\u00e7\u00e3o satisfeita\"); . Veja o exemplo abaixo int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois n\u00fameros \u00e9 %i\",z); } O c\u00f3digo acima recebe dois n\u00fameros digitados pelo usu\u00e1rio, e os soma. Caso a soma desses n\u00fameros seja superior a 10, ele exibe o resultado. Estruturas de decis\u00e3o compostas Em compara\u00e7\u00e3o com as estruturas de decis\u00e3o simples, aqui, possu\u00edmos a condicional else int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois numeros e %i\",z); } else{ printf(\"numero menor que 10 :(\\n\"); } Diferente da primeira vez que vimos este bloco de c\u00f3digo, com o uso do else , podemos definir uma a\u00e7\u00e3o para o caso de a condi\u00e7\u00e3o n\u00e3o ser satisfeita. Nesse caso, caso a entrada n\u00e3o corresponda \u00e0 condi\u00e7\u00e3o definida (se a soma dos dois n\u00fameros n\u00e3o for maior que 10), o programa retorna que o n\u00famero \u00e9 menor que 10. \u00c9 poss\u00edvel aninhar condicionais e estabelecer diferentes condi\u00e7\u00f5es a serem verificadas int x; printf(\"\\nNumero maior, menor ou igual a 20\"); printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if(x == 20){ printf(\"\\nIgual a 20.\\n\"); } else if(x> 20){ printf(\"\\nMaior que 20\\n\"); } else if(x< 20){ printf(\"\\nMenor que 20\\n\"); } No caso acima, 3 condi\u00e7\u00f5es podem ser possivelmente satisfeitas (o n\u00famero ser igual a 20, maior que 20 ou menor que 20) int x; printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if (x<20){ if(x<30){ printf(\"numero maior que 30\"); } else{ printf(\"numero maior que 20, mas menor que 30\"); } } else{ printf(\"numero menor que ou igual a 20\"); } Agora, ele testa a primeira condi\u00e7\u00e3o (numero maior que 20), e se satisfeita, testa a segunda (numero maior que 30). Caso a segunda n\u00e3o seja satisfeita, ele retorna que o n\u00famero \u00e9 maior que 20, e caso nenhuma delas seja satisfeita, ele retorna que o n\u00famero \u00e9 menor que 20. O switch case Al\u00e9m das estruturas de decis\u00e3o if e else , existe a estrutura de decis\u00e3o m\u00faltipla switch : switch(vari\u00e1vel){ case constante1: comando; break; case constante2: comando; break; default: comando; } A palavra switch \u00e9 acompanhada de uma vari\u00e1vel discreta (char ou int e derivados), a qual a condi\u00e7\u00e3o ser\u00e1 testada. O uso da palavra case determina os casos a serem testados, isto \u00e9, os casos em que o valor da vari\u00e1vel corresponde ao valor desejado. A palavra default representa o conjunto de a\u00e7\u00f5es que ser\u00e1 executado caso nenhuma das condi\u00e7\u00f5es testadas seja satisfeita. Seu uso \u00e9 opcional. OBS\u00b9: Para executar apenas o primeiro case correspondente a um valor, \u00e9 necess\u00e1rio utilizar a palavra reservada break OBS\u00b2: O switch n\u00e3o aceita strings ou floats. Para testar condi\u00e7\u00f5es com vari\u00e1veis desses tipos, \u00e9 necess\u00e1rio utilizar \u00ecf e else . PI","title":"Operadores relacionais e condicionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#operadores-relacionais-e-condicionais","text":"","title":"Operadores relacionais e condicionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#operadores-relacionais","text":"A linguagem C possui operadores chamados, operadores relacionais, que servem para comparar dados (vari\u00e1veis, inteiros, strings, etc.). Alguns operadores relacionais s\u00e3o: < (Menor que) > (Maior que) <= (Menor ou igual) >= (Maior ou igual) == (igual) != (diferente de) Baseado nisso, podemos realizar opera\u00e7\u00f5es de compara\u00e7\u00e3o em chamadas estruturas de decis\u00e3o .","title":"Operadores relacionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#estruturas-de-decisao-simples","text":"As estruturas de decis\u00e3o simples interrompem o fluxo de tempo de execu\u00e7\u00e3o do programa a depender dos valores passados. Elas s\u00e3o representadas pelas palavras if ... if (\"condi\u00e7\u00e3o\"){ print(\"condi\u00e7\u00e3o satisfeita\"); } ... No c\u00f3digo acima, a palavra \"condi\u00e7\u00e3o\" pode ser substituida por alguma compara\u00e7\u00e3o, e caso satisfeita, ela executar\u00e1 o c\u00f3digo determinado, nesse caso print(\"Condi\u00e7\u00e3o satisfeita\"); . Veja o exemplo abaixo int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois n\u00fameros \u00e9 %i\",z); } O c\u00f3digo acima recebe dois n\u00fameros digitados pelo usu\u00e1rio, e os soma. Caso a soma desses n\u00fameros seja superior a 10, ele exibe o resultado.","title":"Estruturas de decis\u00e3o simples"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#estruturas-de-decisao-compostas","text":"Em compara\u00e7\u00e3o com as estruturas de decis\u00e3o simples, aqui, possu\u00edmos a condicional else int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois numeros e %i\",z); } else{ printf(\"numero menor que 10 :(\\n\"); } Diferente da primeira vez que vimos este bloco de c\u00f3digo, com o uso do else , podemos definir uma a\u00e7\u00e3o para o caso de a condi\u00e7\u00e3o n\u00e3o ser satisfeita. Nesse caso, caso a entrada n\u00e3o corresponda \u00e0 condi\u00e7\u00e3o definida (se a soma dos dois n\u00fameros n\u00e3o for maior que 10), o programa retorna que o n\u00famero \u00e9 menor que 10. \u00c9 poss\u00edvel aninhar condicionais e estabelecer diferentes condi\u00e7\u00f5es a serem verificadas int x; printf(\"\\nNumero maior, menor ou igual a 20\"); printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if(x == 20){ printf(\"\\nIgual a 20.\\n\"); } else if(x> 20){ printf(\"\\nMaior que 20\\n\"); } else if(x< 20){ printf(\"\\nMenor que 20\\n\"); } No caso acima, 3 condi\u00e7\u00f5es podem ser possivelmente satisfeitas (o n\u00famero ser igual a 20, maior que 20 ou menor que 20) int x; printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if (x<20){ if(x<30){ printf(\"numero maior que 30\"); } else{ printf(\"numero maior que 20, mas menor que 30\"); } } else{ printf(\"numero menor que ou igual a 20\"); } Agora, ele testa a primeira condi\u00e7\u00e3o (numero maior que 20), e se satisfeita, testa a segunda (numero maior que 30). Caso a segunda n\u00e3o seja satisfeita, ele retorna que o n\u00famero \u00e9 maior que 20, e caso nenhuma delas seja satisfeita, ele retorna que o n\u00famero \u00e9 menor que 20.","title":"Estruturas de decis\u00e3o compostas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#o-switch-case","text":"Al\u00e9m das estruturas de decis\u00e3o if e else , existe a estrutura de decis\u00e3o m\u00faltipla switch : switch(vari\u00e1vel){ case constante1: comando; break; case constante2: comando; break; default: comando; } A palavra switch \u00e9 acompanhada de uma vari\u00e1vel discreta (char ou int e derivados), a qual a condi\u00e7\u00e3o ser\u00e1 testada. O uso da palavra case determina os casos a serem testados, isto \u00e9, os casos em que o valor da vari\u00e1vel corresponde ao valor desejado. A palavra default representa o conjunto de a\u00e7\u00f5es que ser\u00e1 executado caso nenhuma das condi\u00e7\u00f5es testadas seja satisfeita. Seu uso \u00e9 opcional. OBS\u00b9: Para executar apenas o primeiro case correspondente a um valor, \u00e9 necess\u00e1rio utilizar a palavra reservada break OBS\u00b2: O switch n\u00e3o aceita strings ou floats. Para testar condi\u00e7\u00f5es com vari\u00e1veis desses tipos, \u00e9 necess\u00e1rio utilizar \u00ecf e else .","title":"O switch case"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/","text":"Strings O que s\u00e3o strings? Strings s\u00e3o cadeias de caracteres utilizadas para a entrada e sa\u00edda de texto no programa. Um exemplo de string \u00e9 \"Eu amo macarr\u00e3o com queijo\" . Note que a frase est\u00e1 entre aspas, pois strings sempre s\u00e3o passadas com aspas duplas. Algumas linguagens, como Python, suportam a passagem de strings com aspas simples, mas no C, n\u00e3o. Strings em C Na linguagem C, o tipo string n\u00e3o \u00e9 definido. Para contornar isso, \u00e9 poss\u00edvel declarar uma \"string\" como uma cadeia de caracteres, isto \u00e9, uma matriz unidimensional de caracteres. Ao declarar uma cadeia de caracteres dessa forma, \u00e9 necess\u00e1rio ter em mente que o \u00faltimo caractere da cadeia \u00e9 o \\0 , que indica a termina\u00e7\u00e3o da string. char nome[30]; //note que a matriz unidimensional recebe o tamanho m\u00e1ximo da string, nesse caso, 30 caracteres. Como o \\0 ocupa a \u00faltima posi\u00e7\u00e3o, o tamanho m\u00e1ximo da string neste caso \u00e9 29 caracteres. scanf e biblioteca Observe o c\u00f3digo abaixo: char nome[30]; scanf(\"%s\", &nome); printf(\"Nome: %s\", nome); //Utiliza-se a m\u00e1scara %s para capturar strings Neste excerto de c\u00f3digo, o uso de scanf n\u00e3o gera erros. O problema \u00e9 que o scanf vai capturar o texto digitado apenas at\u00e9 o primeiro espa\u00e7o. Ent\u00e3o caso seja digitado Pedro Luiz da Costa , o scanf armazenar\u00e1 apenas \"Pedro\" . Para contornar essa limita\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar uma fun\u00e7\u00e3o da biblioteca , que adiciona fun\u00e7\u00f5es para o tratamento de strings, como a compara\u00e7\u00e3o do conte\u00fado de strings ( strcmp() ), o comprimento ( strlen() ), a c\u00f3pia do conte\u00fado de uma string para outra ( strcpy() ), etc. Para capturar o texto completo da string, \u00e9 poss\u00edvel utilizar gets e fgets . Aqui, utilizaremos gets , mas fgets \u00e9 mais seguro. #include <string,h> char nome[30]; gets(nome); //fgets(nome, 30, stdin); A sintaxe para utilizar o fgets. O 30 \u00e9 o tamanho m\u00e1ximo a ser capturado printf(\"\\nNome: %s\", nome); OBS: Para utilizar acentua\u00e7\u00e3o em C, \u00e9 necess\u00e1rio incluir a biblioteca <locale.h> e chamar a fun\u00e7\u00e3o setlocale(LC_ALL,\"Portuguese\") . PI","title":"Strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#strings","text":"","title":"Strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#o-que-sao-strings","text":"Strings s\u00e3o cadeias de caracteres utilizadas para a entrada e sa\u00edda de texto no programa. Um exemplo de string \u00e9 \"Eu amo macarr\u00e3o com queijo\" . Note que a frase est\u00e1 entre aspas, pois strings sempre s\u00e3o passadas com aspas duplas. Algumas linguagens, como Python, suportam a passagem de strings com aspas simples, mas no C, n\u00e3o.","title":"O que s\u00e3o strings?"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#strings-em-c","text":"Na linguagem C, o tipo string n\u00e3o \u00e9 definido. Para contornar isso, \u00e9 poss\u00edvel declarar uma \"string\" como uma cadeia de caracteres, isto \u00e9, uma matriz unidimensional de caracteres. Ao declarar uma cadeia de caracteres dessa forma, \u00e9 necess\u00e1rio ter em mente que o \u00faltimo caractere da cadeia \u00e9 o \\0 , que indica a termina\u00e7\u00e3o da string. char nome[30]; //note que a matriz unidimensional recebe o tamanho m\u00e1ximo da string, nesse caso, 30 caracteres. Como o \\0 ocupa a \u00faltima posi\u00e7\u00e3o, o tamanho m\u00e1ximo da string neste caso \u00e9 29 caracteres.","title":"Strings em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#scanf-e-biblioteca","text":"Observe o c\u00f3digo abaixo: char nome[30]; scanf(\"%s\", &nome); printf(\"Nome: %s\", nome); //Utiliza-se a m\u00e1scara %s para capturar strings Neste excerto de c\u00f3digo, o uso de scanf n\u00e3o gera erros. O problema \u00e9 que o scanf vai capturar o texto digitado apenas at\u00e9 o primeiro espa\u00e7o. Ent\u00e3o caso seja digitado Pedro Luiz da Costa , o scanf armazenar\u00e1 apenas \"Pedro\" . Para contornar essa limita\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar uma fun\u00e7\u00e3o da biblioteca , que adiciona fun\u00e7\u00f5es para o tratamento de strings, como a compara\u00e7\u00e3o do conte\u00fado de strings ( strcmp() ), o comprimento ( strlen() ), a c\u00f3pia do conte\u00fado de uma string para outra ( strcpy() ), etc. Para capturar o texto completo da string, \u00e9 poss\u00edvel utilizar gets e fgets . Aqui, utilizaremos gets , mas fgets \u00e9 mais seguro. #include <string,h> char nome[30]; gets(nome); //fgets(nome, 30, stdin); A sintaxe para utilizar o fgets. O 30 \u00e9 o tamanho m\u00e1ximo a ser capturado printf(\"\\nNome: %s\", nome); OBS: Para utilizar acentua\u00e7\u00e3o em C, \u00e9 necess\u00e1rio incluir a biblioteca <locale.h> e chamar a fun\u00e7\u00e3o setlocale(LC_ALL,\"Portuguese\") .","title":"scanf e biblioteca"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/","text":"Estrutura de Repeti\u00e7\u00e3o Loops Loops (ou repeti\u00e7\u00f5es) s\u00e3o estruturas que, dada uma uma condi\u00e7\u00e3o, ele testa uma condi\u00e7\u00e3o, e enquanto ela for verdadeira, um determinado bloco de c\u00f3digo ser\u00e1 repetido. while O while \u00e9 uma estrutura que testa uma condi\u00e7\u00e3o ao in\u00edcio da execu\u00e7\u00e3o de um bloco de c\u00f3digo, e se ela for verdadeira, ele ser\u00e1 executado. Ao fim de cada execu\u00e7\u00e3o, essa condi\u00e7\u00e3o ser\u00e1 testada. Se, em determinada execu\u00e7\u00e3o, esta condi\u00e7\u00e3o n\u00e3o for satisfeita, o bloco de c\u00f3digo deixa de ser executado. int x = 1; while (x < 10){ printf(\"%d\",x); x++; } O c\u00f3digo acima executa a impress\u00e3o do n\u00famero da vari\u00e1vel x, e acresce 1 a essa vari\u00e1vel, enquanto x \u00e9 menor que 10. Similar ao conceito de recursividade, aqui, temos um caso base (x menor que 10) e um passo indutivo (x++), al\u00e9m dos comandos envolvidos. do-while Diferente do while , o do while testa a condi\u00e7\u00e3o desejada ao fim do loop: int x = 1; do{ printf(\"%d\",x); x++; }while (x < 10) No exemplo acima, o c\u00f3digo ser\u00e1 executado uma vez independente da condi\u00e7\u00e3o ser satisfeita. Ap\u00f3s essa vez, ele testa a condi\u00e7\u00e3o, e, enquanto for verdadeura, ele a continua executando. Quando ela for falsa, o c\u00f3digo deixa de ser executado. for O for funciona como um contador. Para cada execu\u00e7\u00e3o do c\u00f3digo dentro do seu escopo, a vari\u00e1vel utilizada como contador ser\u00e1 incrementada ou decrementada. A sintaxe do for funciona da seguinte forma: for(contador;teste; modifica\u00e7\u00e3o no contador){ comando; } Aqui, o contador \u00e9 uma vari\u00e1vel, o teste \u00e9 a condif\u00e7\u00e3o que ser\u00e1 verificada para que o c\u00f3digo continue sendo executado, e a modifica\u00e7\u00e3o no contador \u00e9 a opera\u00e7\u00e3o realizada no contador a cada vez que o c\u00f3digo \u00e9 executado. Agora, um exemplo pr\u00e1tico: int contador = 0; for(contador;contador< 10; contador++){ printf(\"\\nO contador esta no numero %d\", contador); } printf(\"\\nO contador parou de crescer em %d\",contador); PI","title":"Estrutura de Repeti\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#estrutura-de-repeticao","text":"","title":"Estrutura de Repeti\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#loops","text":"Loops (ou repeti\u00e7\u00f5es) s\u00e3o estruturas que, dada uma uma condi\u00e7\u00e3o, ele testa uma condi\u00e7\u00e3o, e enquanto ela for verdadeira, um determinado bloco de c\u00f3digo ser\u00e1 repetido.","title":"Loops"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#while","text":"O while \u00e9 uma estrutura que testa uma condi\u00e7\u00e3o ao in\u00edcio da execu\u00e7\u00e3o de um bloco de c\u00f3digo, e se ela for verdadeira, ele ser\u00e1 executado. Ao fim de cada execu\u00e7\u00e3o, essa condi\u00e7\u00e3o ser\u00e1 testada. Se, em determinada execu\u00e7\u00e3o, esta condi\u00e7\u00e3o n\u00e3o for satisfeita, o bloco de c\u00f3digo deixa de ser executado. int x = 1; while (x < 10){ printf(\"%d\",x); x++; } O c\u00f3digo acima executa a impress\u00e3o do n\u00famero da vari\u00e1vel x, e acresce 1 a essa vari\u00e1vel, enquanto x \u00e9 menor que 10. Similar ao conceito de recursividade, aqui, temos um caso base (x menor que 10) e um passo indutivo (x++), al\u00e9m dos comandos envolvidos.","title":"while"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#do-while","text":"Diferente do while , o do while testa a condi\u00e7\u00e3o desejada ao fim do loop: int x = 1; do{ printf(\"%d\",x); x++; }while (x < 10) No exemplo acima, o c\u00f3digo ser\u00e1 executado uma vez independente da condi\u00e7\u00e3o ser satisfeita. Ap\u00f3s essa vez, ele testa a condi\u00e7\u00e3o, e, enquanto for verdadeura, ele a continua executando. Quando ela for falsa, o c\u00f3digo deixa de ser executado.","title":"do-while"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#for","text":"O for funciona como um contador. Para cada execu\u00e7\u00e3o do c\u00f3digo dentro do seu escopo, a vari\u00e1vel utilizada como contador ser\u00e1 incrementada ou decrementada. A sintaxe do for funciona da seguinte forma: for(contador;teste; modifica\u00e7\u00e3o no contador){ comando; } Aqui, o contador \u00e9 uma vari\u00e1vel, o teste \u00e9 a condif\u00e7\u00e3o que ser\u00e1 verificada para que o c\u00f3digo continue sendo executado, e a modifica\u00e7\u00e3o no contador \u00e9 a opera\u00e7\u00e3o realizada no contador a cada vez que o c\u00f3digo \u00e9 executado. Agora, um exemplo pr\u00e1tico: int contador = 0; for(contador;contador< 10; contador++){ printf(\"\\nO contador esta no numero %d\", contador); } printf(\"\\nO contador parou de crescer em %d\",contador);","title":"for"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/","text":"Vetores(Arrays) Vetores e Matrizes Vetores e Matrizes s\u00e3o conjuntos de dados homog\u00eaneos (de um mesmo tipo). Esses dados terminar Vetor de strings Como em C, o tipo string n\u00e3o \u00e9 definido, um vetor de strings \u00e9 um vetor bidimensional. Isso significa que ele funciona como uma matriz (sintaxe abaixo). Com isso, ele tamb\u00e9m possui algumas limita\u00e7\u00f5es, como a seguinte: * O n\u00famero de caracteres em cada string tem que ser igual para todos os itens da lista O exemplo abaixo demonstra o uso de strings //N\u00famero de strings armazenadas na lista // v v tamanho das strings char listaNomes[6][10]; // listaNomes[0] = 'Luiz'; //<--- Sintaxe para atribuir uma string a um lugar na lista (neste caso, no \u00edndice 0) printf(\"%s\",listanomes[0]); //<-- Imprime o nome naquele \u00edndice PI","title":"Vetores(Arrays)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#vetoresarrays","text":"","title":"Vetores(Arrays)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#vetores-e-matrizes","text":"Vetores e Matrizes s\u00e3o conjuntos de dados homog\u00eaneos (de um mesmo tipo). Esses dados terminar","title":"Vetores e Matrizes"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#vetor-de-strings","text":"Como em C, o tipo string n\u00e3o \u00e9 definido, um vetor de strings \u00e9 um vetor bidimensional. Isso significa que ele funciona como uma matriz (sintaxe abaixo). Com isso, ele tamb\u00e9m possui algumas limita\u00e7\u00f5es, como a seguinte: * O n\u00famero de caracteres em cada string tem que ser igual para todos os itens da lista O exemplo abaixo demonstra o uso de strings //N\u00famero de strings armazenadas na lista // v v tamanho das strings char listaNomes[6][10]; // listaNomes[0] = 'Luiz'; //<--- Sintaxe para atribuir uma string a um lugar na lista (neste caso, no \u00edndice 0) printf(\"%s\",listanomes[0]); //<-- Imprime o nome naquele \u00edndice","title":"Vetor de strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/","text":"Matrizes com mais de uma dimens\u00e3o Matrizes em C podem ser declaradas com qualquer quantidade de dimens\u00f5es int matriz1[3][3]; //Matriz bidimensional int matriz2[4][2][5]; //Matriz tridimensional int matriz3[5][12][20][24][15]; //Matriz de dimens\u00e3o 5 O uso de matrizes com mais de uma dimens\u00e3o j\u00e1 podia ser visto com a declara\u00e7\u00e3o de listas de strings: char nomes[15][30]; No exemplo de vari\u00e1vel declarada acima, o primeiro valor entre colchetes representa o n\u00famero de linhas. O segundo, o n\u00famero de colunas. Nesse caso, o n\u00famero de colunas \u00e9 o n\u00famero de caracteres de cada linha da lista, ou melhor ainda, de cada nome. PI","title":"Matrizes com mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/#matrizes-com-mais-de-uma-dimensao","text":"Matrizes em C podem ser declaradas com qualquer quantidade de dimens\u00f5es int matriz1[3][3]; //Matriz bidimensional int matriz2[4][2][5]; //Matriz tridimensional int matriz3[5][12][20][24][15]; //Matriz de dimens\u00e3o 5 O uso de matrizes com mais de uma dimens\u00e3o j\u00e1 podia ser visto com a declara\u00e7\u00e3o de listas de strings: char nomes[15][30]; No exemplo de vari\u00e1vel declarada acima, o primeiro valor entre colchetes representa o n\u00famero de linhas. O segundo, o n\u00famero de colunas. Nesse caso, o n\u00famero de colunas \u00e9 o n\u00famero de caracteres de cada linha da lista, ou melhor ainda, de cada nome.","title":"Matrizes com mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/","text":"Estruturas Heterog\u00eaneas de Dados (Structs) PI","title":"Estruturas Heterog\u00eaneas de Dados (Structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/#estruturas-heterogeneas-de-dados-structs","text":"","title":"Estruturas Heterog\u00eaneas de Dados (Structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/","text":"Ponteiros Ponteiros s\u00e3o tipos de dados que armazenam endere\u00e7os de mem\u00f3ria. Declara\u00e7\u00e3o de vari\u00e1veis Em C, o operador & retorna um endere\u00e7o de mem\u00f3ria: scanf(\"%d\",&num); // ^ // Operador un\u00e1rio Esse operador \u00e9 necess\u00e1rio para informar que a informa\u00e7\u00e3o armazenada naquela vari\u00e1vel est\u00e1 em determinado local da mem\u00f3ria. Declara\u00e7\u00e3o de ponteiros O operador un\u00e1rio * \u00e9 utilizado para a declara\u00e7\u00e3o e o acesso de vari\u00e1veis ponteiro: int num, cont; num = 6; int *pont; // <--- Ponteiro pont = &num; // <--- Ponteiro recebendo o endere\u00e7o de mem\u00f3ria da vari\u00e1vel num cont = *pont;// <--- Vari\u00e1vel recebendo o valor \"desreferenciado\", ou seja, o valor armazenado no endere\u00e7o de mem\u00f3ria armazenado pelo ponteiro Matrizes e ponteiros Na linguagem C, matrizes e ponteiros est\u00e3o intimamente relacionados. Aqui, matrizes e vetores s\u00e3o considerados ponteiros. Isso significa que os nomes das matrizes s\u00e3o ponteiros que apontam para a posi\u00e7\u00e3o de mem\u00f3ria do primeiro elemento desta matriz. PI","title":"Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/#ponteiros","text":"Ponteiros s\u00e3o tipos de dados que armazenam endere\u00e7os de mem\u00f3ria.","title":"Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/#declaracao-de-variaveis","text":"Em C, o operador & retorna um endere\u00e7o de mem\u00f3ria: scanf(\"%d\",&num); // ^ // Operador un\u00e1rio Esse operador \u00e9 necess\u00e1rio para informar que a informa\u00e7\u00e3o armazenada naquela vari\u00e1vel est\u00e1 em determinado local da mem\u00f3ria.","title":"Declara\u00e7\u00e3o de vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/#declaracao-de-ponteiros","text":"O operador un\u00e1rio * \u00e9 utilizado para a declara\u00e7\u00e3o e o acesso de vari\u00e1veis ponteiro: int num, cont; num = 6; int *pont; // <--- Ponteiro pont = &num; // <--- Ponteiro recebendo o endere\u00e7o de mem\u00f3ria da vari\u00e1vel num cont = *pont;// <--- Vari\u00e1vel recebendo o valor \"desreferenciado\", ou seja, o valor armazenado no endere\u00e7o de mem\u00f3ria armazenado pelo ponteiro","title":"Declara\u00e7\u00e3o de ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/#matrizes-e-ponteiros","text":"Na linguagem C, matrizes e ponteiros est\u00e3o intimamente relacionados. Aqui, matrizes e vetores s\u00e3o considerados ponteiros. Isso significa que os nomes das matrizes s\u00e3o ponteiros que apontam para a posi\u00e7\u00e3o de mem\u00f3ria do primeiro elemento desta matriz.","title":"Matrizes e ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/","text":"Fun\u00e7\u00f5es e Escopos Fun\u00e7\u00f5es Apesar de j\u00e1 usarmos fun\u00e7\u00f5es desde quando come\u00e7amos a programar, \u00e9 poss\u00edvel tamb\u00e9m criarmos nossas pr\u00f3ximas fun\u00e7\u00f5es. \u00c9 altamente recomendado criar fun\u00e7\u00f5es para c\u00f3digos que se repetem. Tamb\u00e9m \u00e9 considerada uma boa pr\u00e1tica que fun\u00e7\u00f5es realizem uma \u00fanica tarefa, e seu nome reflita essa tarefa. Defini\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o Fun\u00e7\u00f5es podem ser definidas com a seguinte sintaxe void soma(int x, int y){ //<- Declara\u00e7\u00e3o da fun\u00e7\u00e3o com os argumentos a serem manipulados int valorSoma; valorSoma = x+y; printf(\"%d\", valorSoma); } int main(){ soma(3,2); //<- Chamada da fun\u00e7\u00e3o com os par\u00e2metros passados } A sintaxe de defini\u00e7\u00e3o de fun\u00e7\u00f5es deve ter, obrigatoriamente, o tipo do retorno, o nome da fun\u00e7\u00e3o e a lista de par\u00e2metros necess\u00e1rios para execut\u00e1-la. Quando a fun\u00e7\u00e3o n\u00e3o necessita de par\u00e2metros, os par\u00eanteses ainda s\u00e3o utilizados (a exemplo da fun\u00e7\u00e3o main). OBS 1: Quando um valor \u00e9 passado a uma fun\u00e7\u00e3o, ele \u00e9 chamado de argumento . Quando a fun\u00e7\u00e3o \u00e9 declarada e requisita determinados valores, esses valores s\u00e3o denominados par\u00e2metros . OBS 2 : Cada argumento requisitado por uma fun\u00e7\u00e3o deve conter, em sua defini\u00e7\u00e3o, o tipo da vari\u00e1vel a ser recebida. Ex: int troca(int x, int y){...} . Note que, mesmo com os argumentos sendo do mesmo tipo (int), a palavra reservada para esse tipo \u00e9 utilizada para cada argumento. Caso a fun\u00e7\u00e3o fosse definida como int troca(int x, y){...} , o c\u00f3digo n\u00e3o funcionaria. Vari\u00e1veis declaradas dentro de fun\u00e7\u00f5es de forma est\u00e1tica possuem tempo de vida limitado at\u00e9 o fim da execu\u00e7\u00e3o da fun\u00e7\u00e3o e escopo limitado, n\u00e3o existindo fora da fun\u00e7\u00e3o. Para chamar uma fun\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar o nome desta, junto aos argumentos esperados por ela (definidos quando a fun\u00e7\u00e3o foi definida). Passagem de argumentos para fun\u00e7\u00f5es Argumentos podem ser passados por valor ou por refer\u00eancia. Por valor Ao passar um argumento por valor, seu valor \u00e9 copiado para o para o respectivo par\u00e2mero na fun\u00e7\u00e3o, e as altera\u00e7\u00f5es ocorridas nesse par\u00e2metro n\u00e3o s\u00e3o refletidos no valor do argumento original. Em outras palavras, as modifica\u00e7\u00f5es do valor n\u00e3o s\u00e3o mantidas ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o. void trocaValor(int x, int y){ int aux; aux = x; x = y; y = aux; } int main(){ int a = 3, b = 2; trocaValor(a, b); printf(\"a: %d b: %d\", a, b); //vai retornar a: 3 b: 2, pois ao sair da fun\u00e7\u00e3o trocaValor, os valores s\u00e3o inalterados. } Por refer\u00eancia Ao passar um argumento por refer\u00eancia, o argumento recebido \u00e9 o endere\u00e7o do argumento. Dessa forma, a fun\u00e7\u00e3o acessa o valor do argumento e o modifica, alterando o valor original. void trocaValor(int *x, int *y){ int aux; aux = *x; *x = *y; *y = aux; } int main(){ int a = 3, b = 2; trocaValor(a, b); printf(\"a: %d b: %d\", &a, &b); //vai retornar a: 2 e b: 3, pois, por refer\u00eancia, os endere\u00e7os em que os valores est\u00e3o s\u00e3o acessados } Para entender melhor, a passagem de argumentos por refer\u00eancia, revise os conceitos de ponteiros, da apostila anterior. OBS: Como matrizes s\u00e3o consideradas ponteiros, n\u00e3o \u00e9 necess\u00e1rio utilizar o operador * para pass\u00e1-las como argumento. Seus valores sempre ser\u00e3o modificados nas fun\u00e7\u00f5es, caso isso seja desejado. Escopos As fun\u00e7\u00f5es, bem como as diferentes estruturas aprendidas at\u00e9 aqui, podem ter vari\u00e1veis declaradas durante a sua execu\u00e7\u00e3o. Essas vari\u00e1veis n\u00e3o podem ser acessadas fora dessas estruturas. Os locais onde essas vari\u00e1veis podem ser acessadas s\u00e3o chamados de escopos . Vari\u00e1veis Locais Considere o c\u00f3digo abaixo: void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero <5; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ int num; //escopo: fun\u00e7\u00e3o main printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nO numero digitado foi: %d\", num); printf(\"\\nContando ate 4...\"); contador(); } No c\u00f3digo acima, a vari\u00e1vel numero , pertencente \u00e0 fun\u00e7\u00e3o contador , s\u00f3 pode ser usada dentro dessa fun\u00e7\u00e3o. Essencialmente, o escopo da vari\u00e1vel numero \u00e9 a fun\u00e7\u00e3o contador . Da mesma forma, o escopo da vari\u00e1vel num \u00e9 a fun\u00e7\u00e3o main. Isso n\u00e3o significa que a vari\u00e1vel pode ser acessada pela fun\u00e7\u00e3o contador , invocada ali. Isso aconteceria apenas se a vari\u00e1vel pudesse ser passada como argumento para a fun\u00e7\u00e3o. De qualquer forma, as vari\u00e1veis num e n\u00famero s\u00e3o chamadas de vari\u00e1veis locais , pois seu acesso s\u00f3 \u00e9 poss\u00edvel em determinadas partes do c\u00f3digo ap\u00f3s sua cria\u00e7\u00e3o. As vari\u00e1veis locais deixam de existir ap\u00f3s o escopo em que elas est\u00e3o situadas deixa de ser executado. Gra\u00e7as a essa caracter\u00edstica, \u00e9 poss\u00edvel criar infinitas vari\u00e1veis de mesmo nome em escopos diferentes, afinal, quase sempre, elas n\u00e3o gerar\u00e3o interfer\u00eancia entre si. Um exemplo b\u00e1sico de uso das vari\u00e1veis locais \u00e9 o for : for(int i = 0; i< 5; i++){ printf(\" %d\", i); } A vari\u00e1vel i \u00e9 declarada no momento em que o for \u00e9 executado, mas deixa de existir ap\u00f3s o loop ser conclu\u00eddo. Vari\u00e1veis Globais Agora, considere o seguinte caso: int num = 0; //escopo: global void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero < num; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nContando ate %d... \", num); contador(); } No caso acima, a vari\u00e1vel num foi declarada fora de qualquer fun\u00e7\u00e3o, ou seja, no escopo global. Isso significa que, a partir do momento em que ela foi declarada, ela pode ser acessada e modificada por quaisquer fun\u00e7\u00f5es que a acessem. No caso acima, a vari\u00e1vel num \u00e9 acessada e modificada pela fun\u00e7\u00e3o main() , e depois, acessada pela fun\u00e7\u00e3o contador() . Isso tudo ocorre conforme a execu\u00e7\u00e3o na main() . \u26a0\ufe0f ATEN\u00c7\u00c3O: Por manterem valores entre escopos de fun\u00e7\u00e3o, e poderem ser modificadas por qualquer fun\u00e7\u00e3o em que sejam lidas, as vari\u00e1veis globais s\u00e3o indesejadas em grandes c\u00f3digos. Elas dificultam a depura\u00e7\u00e3o e a resolu\u00e7\u00e3o de problemas na execu\u00e7\u00e3o do c\u00f3digo, e por isso, devem ser evitadas. Vari\u00e1veis est\u00e1ticas Tanto as vari\u00e1veis locais quanto as globais podem ter a atribui\u00e7\u00e3o de vari\u00e1vel est\u00e1tica, determinada com a palavra static antes do tipo e do nome. Elas possuem diferentes comportamentos a depender do escopo: - Vari\u00e1veis locais: Ao serem criadas, elas n\u00e3o ser\u00e3o apagadas da mem\u00f3ria no fim do escopo, carregando seu valor entre as chamadas da fun\u00e7\u00e3o - Vari\u00e1veis globais: Caso o programa possua outros m\u00f3dulos (arquivos .c), elas n\u00e3o podem ser acessadas nesses outros m\u00f3dulos. Isso reduz a possibilidade de conflitos no programa. PI","title":"Fun\u00e7\u00f5es e Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#funcoes-e-escopos","text":"","title":"Fun\u00e7\u00f5es e Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#funcoes","text":"Apesar de j\u00e1 usarmos fun\u00e7\u00f5es desde quando come\u00e7amos a programar, \u00e9 poss\u00edvel tamb\u00e9m criarmos nossas pr\u00f3ximas fun\u00e7\u00f5es. \u00c9 altamente recomendado criar fun\u00e7\u00f5es para c\u00f3digos que se repetem. Tamb\u00e9m \u00e9 considerada uma boa pr\u00e1tica que fun\u00e7\u00f5es realizem uma \u00fanica tarefa, e seu nome reflita essa tarefa.","title":"Fun\u00e7\u00f5es"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#definicao-e-chamada-de-uma-funcao","text":"Fun\u00e7\u00f5es podem ser definidas com a seguinte sintaxe void soma(int x, int y){ //<- Declara\u00e7\u00e3o da fun\u00e7\u00e3o com os argumentos a serem manipulados int valorSoma; valorSoma = x+y; printf(\"%d\", valorSoma); } int main(){ soma(3,2); //<- Chamada da fun\u00e7\u00e3o com os par\u00e2metros passados } A sintaxe de defini\u00e7\u00e3o de fun\u00e7\u00f5es deve ter, obrigatoriamente, o tipo do retorno, o nome da fun\u00e7\u00e3o e a lista de par\u00e2metros necess\u00e1rios para execut\u00e1-la. Quando a fun\u00e7\u00e3o n\u00e3o necessita de par\u00e2metros, os par\u00eanteses ainda s\u00e3o utilizados (a exemplo da fun\u00e7\u00e3o main). OBS 1: Quando um valor \u00e9 passado a uma fun\u00e7\u00e3o, ele \u00e9 chamado de argumento . Quando a fun\u00e7\u00e3o \u00e9 declarada e requisita determinados valores, esses valores s\u00e3o denominados par\u00e2metros . OBS 2 : Cada argumento requisitado por uma fun\u00e7\u00e3o deve conter, em sua defini\u00e7\u00e3o, o tipo da vari\u00e1vel a ser recebida. Ex: int troca(int x, int y){...} . Note que, mesmo com os argumentos sendo do mesmo tipo (int), a palavra reservada para esse tipo \u00e9 utilizada para cada argumento. Caso a fun\u00e7\u00e3o fosse definida como int troca(int x, y){...} , o c\u00f3digo n\u00e3o funcionaria. Vari\u00e1veis declaradas dentro de fun\u00e7\u00f5es de forma est\u00e1tica possuem tempo de vida limitado at\u00e9 o fim da execu\u00e7\u00e3o da fun\u00e7\u00e3o e escopo limitado, n\u00e3o existindo fora da fun\u00e7\u00e3o. Para chamar uma fun\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar o nome desta, junto aos argumentos esperados por ela (definidos quando a fun\u00e7\u00e3o foi definida).","title":"Defini\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#passagem-de-argumentos-para-funcoes","text":"Argumentos podem ser passados por valor ou por refer\u00eancia.","title":"Passagem de argumentos para fun\u00e7\u00f5es"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#por-valor","text":"Ao passar um argumento por valor, seu valor \u00e9 copiado para o para o respectivo par\u00e2mero na fun\u00e7\u00e3o, e as altera\u00e7\u00f5es ocorridas nesse par\u00e2metro n\u00e3o s\u00e3o refletidos no valor do argumento original. Em outras palavras, as modifica\u00e7\u00f5es do valor n\u00e3o s\u00e3o mantidas ap\u00f3s a execu\u00e7\u00e3o da fun\u00e7\u00e3o. void trocaValor(int x, int y){ int aux; aux = x; x = y; y = aux; } int main(){ int a = 3, b = 2; trocaValor(a, b); printf(\"a: %d b: %d\", a, b); //vai retornar a: 3 b: 2, pois ao sair da fun\u00e7\u00e3o trocaValor, os valores s\u00e3o inalterados. }","title":"Por valor"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#por-referencia","text":"Ao passar um argumento por refer\u00eancia, o argumento recebido \u00e9 o endere\u00e7o do argumento. Dessa forma, a fun\u00e7\u00e3o acessa o valor do argumento e o modifica, alterando o valor original. void trocaValor(int *x, int *y){ int aux; aux = *x; *x = *y; *y = aux; } int main(){ int a = 3, b = 2; trocaValor(a, b); printf(\"a: %d b: %d\", &a, &b); //vai retornar a: 2 e b: 3, pois, por refer\u00eancia, os endere\u00e7os em que os valores est\u00e3o s\u00e3o acessados } Para entender melhor, a passagem de argumentos por refer\u00eancia, revise os conceitos de ponteiros, da apostila anterior. OBS: Como matrizes s\u00e3o consideradas ponteiros, n\u00e3o \u00e9 necess\u00e1rio utilizar o operador * para pass\u00e1-las como argumento. Seus valores sempre ser\u00e3o modificados nas fun\u00e7\u00f5es, caso isso seja desejado.","title":"Por refer\u00eancia"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#escopos","text":"As fun\u00e7\u00f5es, bem como as diferentes estruturas aprendidas at\u00e9 aqui, podem ter vari\u00e1veis declaradas durante a sua execu\u00e7\u00e3o. Essas vari\u00e1veis n\u00e3o podem ser acessadas fora dessas estruturas. Os locais onde essas vari\u00e1veis podem ser acessadas s\u00e3o chamados de escopos .","title":"Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#variaveis-locais","text":"Considere o c\u00f3digo abaixo: void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero <5; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ int num; //escopo: fun\u00e7\u00e3o main printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nO numero digitado foi: %d\", num); printf(\"\\nContando ate 4...\"); contador(); } No c\u00f3digo acima, a vari\u00e1vel numero , pertencente \u00e0 fun\u00e7\u00e3o contador , s\u00f3 pode ser usada dentro dessa fun\u00e7\u00e3o. Essencialmente, o escopo da vari\u00e1vel numero \u00e9 a fun\u00e7\u00e3o contador . Da mesma forma, o escopo da vari\u00e1vel num \u00e9 a fun\u00e7\u00e3o main. Isso n\u00e3o significa que a vari\u00e1vel pode ser acessada pela fun\u00e7\u00e3o contador , invocada ali. Isso aconteceria apenas se a vari\u00e1vel pudesse ser passada como argumento para a fun\u00e7\u00e3o. De qualquer forma, as vari\u00e1veis num e n\u00famero s\u00e3o chamadas de vari\u00e1veis locais , pois seu acesso s\u00f3 \u00e9 poss\u00edvel em determinadas partes do c\u00f3digo ap\u00f3s sua cria\u00e7\u00e3o. As vari\u00e1veis locais deixam de existir ap\u00f3s o escopo em que elas est\u00e3o situadas deixa de ser executado. Gra\u00e7as a essa caracter\u00edstica, \u00e9 poss\u00edvel criar infinitas vari\u00e1veis de mesmo nome em escopos diferentes, afinal, quase sempre, elas n\u00e3o gerar\u00e3o interfer\u00eancia entre si. Um exemplo b\u00e1sico de uso das vari\u00e1veis locais \u00e9 o for : for(int i = 0; i< 5; i++){ printf(\" %d\", i); } A vari\u00e1vel i \u00e9 declarada no momento em que o for \u00e9 executado, mas deixa de existir ap\u00f3s o loop ser conclu\u00eddo.","title":"Vari\u00e1veis Locais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#variaveis-globais","text":"Agora, considere o seguinte caso: int num = 0; //escopo: global void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero < num; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nContando ate %d... \", num); contador(); } No caso acima, a vari\u00e1vel num foi declarada fora de qualquer fun\u00e7\u00e3o, ou seja, no escopo global. Isso significa que, a partir do momento em que ela foi declarada, ela pode ser acessada e modificada por quaisquer fun\u00e7\u00f5es que a acessem. No caso acima, a vari\u00e1vel num \u00e9 acessada e modificada pela fun\u00e7\u00e3o main() , e depois, acessada pela fun\u00e7\u00e3o contador() . Isso tudo ocorre conforme a execu\u00e7\u00e3o na main() . \u26a0\ufe0f ATEN\u00c7\u00c3O: Por manterem valores entre escopos de fun\u00e7\u00e3o, e poderem ser modificadas por qualquer fun\u00e7\u00e3o em que sejam lidas, as vari\u00e1veis globais s\u00e3o indesejadas em grandes c\u00f3digos. Elas dificultam a depura\u00e7\u00e3o e a resolu\u00e7\u00e3o de problemas na execu\u00e7\u00e3o do c\u00f3digo, e por isso, devem ser evitadas.","title":"Vari\u00e1veis Globais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#variaveis-estaticas","text":"Tanto as vari\u00e1veis locais quanto as globais podem ter a atribui\u00e7\u00e3o de vari\u00e1vel est\u00e1tica, determinada com a palavra static antes do tipo e do nome. Elas possuem diferentes comportamentos a depender do escopo: - Vari\u00e1veis locais: Ao serem criadas, elas n\u00e3o ser\u00e3o apagadas da mem\u00f3ria no fim do escopo, carregando seu valor entre as chamadas da fun\u00e7\u00e3o - Vari\u00e1veis globais: Caso o programa possua outros m\u00f3dulos (arquivos .c), elas n\u00e3o podem ser acessadas nesses outros m\u00f3dulos. Isso reduz a possibilidade de conflitos no programa.","title":"Vari\u00e1veis est\u00e1ticas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/","text":"Recursividade O que \u00e9 Recursividade? Recursividade na computa\u00e7\u00e3o \u00e9 a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o ou algoritmo que funciona por meio da invoca\u00e7\u00e3o de si mesmo. Defini\u00e7\u00f5es recursivas s\u00e3o poderosas para defini\u00e7\u00f5es matem\u00e1ticas e a resolu\u00e7\u00e3o de problemas como a busca sequencial de arquivos. Dois exemplos comuns de recursividade s\u00e3o a sequ\u00eancia de Fibonacci e a defini\u00e7\u00e3o de fatoriais . A sequ\u00eancia de Fibonacci \u00e9 definida por: $$ Fib(N) = Fib(N-1) + Fib (N-2) $$ A defini\u00e7\u00e3o acima \u00e9 chamada de Passo recursivo . Mas precisamos definir um ponto inicial para a chamada recursiva. Chamamos isso de caso base . O caso base da sequ\u00eancia \u00e9: $$Fib(1) = Fib(0) = 1$$ Assim, $$Fib(5) = 8 $$ Regras para a definir fun\u00e7\u00f5es recursivas Uma fun\u00e7\u00e3o recursiva precisa ter, em algum momento, uma chamada a si mesma. \u00c9 necess\u00e1rio pensar no caso base de uma fun\u00e7\u00e3o recursiva, pois isso evita que a fun\u00e7\u00e3o chame a si mesma infinitamente. As fun\u00e7\u00f5es recursivas precisam de Finitude din\u00e2mica , ou seja, precisam possuir determinada condi\u00e7\u00e3o que se torna verdadeira em algum momento (essencialmente, a defini\u00e7\u00e3o do caso base) Na programa\u00e7\u00e3o O excerto de c\u00f3digo abaixo \u00e9 uma representa\u00e7\u00e3o da sequ\u00eancia de Fibonacci escrita na linguagem C: int fib(int num){ if(num == 0 || num == 1){ return 1; //caso base. } else{ return fib(num-1) + fib(num-2); //passo indutivo } } Similarmente, \u00e9 poss\u00edvel definir fatorial dessa forma: int fat(int num){ if (num == 0){ num = 1; } else{ num *= fat(num-1); } return num; } Matematicamente, fatorial \u00e9 definido da seguinte forma: $$ n! = n \\cdot (n-1)! $$ Sendo o caso base $0! = 1$ PI","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/#recursividade","text":"","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/#o-que-e-recursividade","text":"Recursividade na computa\u00e7\u00e3o \u00e9 a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o ou algoritmo que funciona por meio da invoca\u00e7\u00e3o de si mesmo. Defini\u00e7\u00f5es recursivas s\u00e3o poderosas para defini\u00e7\u00f5es matem\u00e1ticas e a resolu\u00e7\u00e3o de problemas como a busca sequencial de arquivos. Dois exemplos comuns de recursividade s\u00e3o a sequ\u00eancia de Fibonacci e a defini\u00e7\u00e3o de fatoriais . A sequ\u00eancia de Fibonacci \u00e9 definida por: $$ Fib(N) = Fib(N-1) + Fib (N-2) $$ A defini\u00e7\u00e3o acima \u00e9 chamada de Passo recursivo . Mas precisamos definir um ponto inicial para a chamada recursiva. Chamamos isso de caso base . O caso base da sequ\u00eancia \u00e9: $$Fib(1) = Fib(0) = 1$$ Assim, $$Fib(5) = 8 $$","title":"O que \u00e9 Recursividade?"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/#regras-para-a-definir-funcoes-recursivas","text":"Uma fun\u00e7\u00e3o recursiva precisa ter, em algum momento, uma chamada a si mesma. \u00c9 necess\u00e1rio pensar no caso base de uma fun\u00e7\u00e3o recursiva, pois isso evita que a fun\u00e7\u00e3o chame a si mesma infinitamente. As fun\u00e7\u00f5es recursivas precisam de Finitude din\u00e2mica , ou seja, precisam possuir determinada condi\u00e7\u00e3o que se torna verdadeira em algum momento (essencialmente, a defini\u00e7\u00e3o do caso base)","title":"Regras para a definir fun\u00e7\u00f5es recursivas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/#na-programacao","text":"O excerto de c\u00f3digo abaixo \u00e9 uma representa\u00e7\u00e3o da sequ\u00eancia de Fibonacci escrita na linguagem C: int fib(int num){ if(num == 0 || num == 1){ return 1; //caso base. } else{ return fib(num-1) + fib(num-2); //passo indutivo } } Similarmente, \u00e9 poss\u00edvel definir fatorial dessa forma: int fat(int num){ if (num == 0){ num = 1; } else{ num *= fat(num-1); } return num; } Matematicamente, fatorial \u00e9 definido da seguinte forma: $$ n! = n \\cdot (n-1)! $$ Sendo o caso base $0! = 1$","title":"Na programa\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/","text":"Alocamento de mem\u00f3ria Programa e algoritmo Endere\u00e7os de mem\u00f3ria Toda vari\u00e1vel \u00e9 situada em um endere\u00e7o (uma posi\u00e7\u00e3o) da mem\u00f3ria. Quando queremos nos referir a um endere\u00e7o de mem\u00f3ria relativo a algo, utilizamos o & , como no scanf. Relembrando: Ponteiros (O conte\u00fado deste t\u00f3pico j\u00e1 foi abordado anteriormente) A vari\u00e1vel pont\u00e9iro \u00e9 uma vari\u00e1vel que armazena o endere\u00e7o de outra posi\u00e7\u00e3o na mem\u00f3ria, que pode conter outros dados. Se um ponteiro n\u00e3o armazena nenhum endere\u00e7o v\u00e1lido, o valor \u00e9 NULL Para declarar um ponteiro em C coloca-se * na frente do nome da vari\u00e1vel. Desreferenciamento de um ponteiro Para acessar o conte\u00fado de uma vari\u00e1vel que o ponteiro referencia, utiliza-se * na frente do ponteiro Vari\u00e1veis Est\u00e1ticas: Declaradas convencionalmente em tempo de projeto (ao programar) Din\u00e2micas Podem ser ciradas e destru\u00eddas durante a execu\u00e7\u00e3o do programa A declara\u00e7\u00e3o \u00e9 indireta e a vincula\u00e7\u00e3o, por meio de ponteiros Elas possuem diversas vantagens em rela\u00e7\u00e3o \u00e0s est\u00e1ticas, como a declara\u00e7\u00e3o de vari\u00e1veis sem desperd\u00edcio de mem\u00f3ria \u00c1reas da mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Para alocar a mem\u00f3ria de vari\u00e1veis est\u00e1ticas, \u00e9 necess\u00e1rio saber a quantidade de mem\u00f3ria a ser alocada previamente. O problema disso \u00e9 que, em muitos casos, s\u00f3 \u00e9 poss\u00edvel saber a quantidade de mem\u00f3ria necess\u00e1ria durante a execu\u00e7\u00e3o do programa. Um dos maiores usos do alocamento din\u00e2mico \u00e9 com os blocos de dados (vetores e matrizes), para evitar o desperd\u00edcio ou a falta de mem\u00f3ria. Em C malloc : recebe como par\u00e2metro a quantidade de mem\u00f3rias que desejamos alocar, reservando a mem\u00f3ria perdida e retomando um ponteiro void para o primeiro byte alocado. ponteiro = (int*) malloc(12); //alocamento de 12 bytes para um ponteiro com cast int (armazena n\u00fameros de t) Para descobrir a quantidade de bytes necess\u00e1rios, existe a fun\u00e7\u00e3o sizeof() , que retorna o n\u00famero de bytes utlizados para algum elemento (tipo ou struct) ponteiro = (int*) malloc(sizeof(int)); //alocamento da quantidade de bytes necess\u00e1rios para uma vari\u00e1vel int ponteiro = (int*) malloc(sizeof(int)*4 );//alocamento da quantidade de bytes necess\u00e1rios para 4 vari\u00e1veis do tipo int Tamb\u00e9m existe a fun\u00e7\u00e3o calloc, que al\u00e9m de permitir a indica\u00e7\u00e3o do n\u00famero de elementos para alocar mem\u00f3ria, define o valor de cada um dos valores para 0. ponteiro = calloc(3, sizeof(int)); //aloca 3 int e declara todos eles como 0 Ap\u00f3s utilizar o ponteiro, \u00e9 ideal utilizar free(ponteiro) Aloca\u00e7\u00e3o din\u00e2mica de matrizes de mais de uma dimens\u00e3o A forma como declaramos vari\u00e1veis din\u00e2micas demonstrada anteriormente cria uma matriz unidimensional para o armazenamento dessas informa\u00e7\u00f5es. Agora, poderemos criar \"matrizes bidimensionais\" (com uma pegadinha). Para declarar matrizes bidimensionais, podemos utilizar o seguinte: matriz = (int*) malloc(2*3*sizeof(int)); // ^ ^ // | Aloca\u00e7\u00e3o dos bytes necess\u00e1rios para o tamanho de uma \"matriz\" 2x3 // Casting do tipo //genericamente: //matriz = (int*) malloc(linhas*colunas*sizeof(int)); Apesar de ser considerada uma matriz 3x2, n\u00e3o \u00e9 poss\u00edvel utilizar printf(\"%d\", matriz[1][2]); //genericamente, //printf(\"%d\", matriz[x][y]); para chamar o elemento da 2\u00aa linha e 3\u00aa coluna. Em vez disso, \u00e9 necess\u00e1rio utilizar aritm\u00e9tica de ponteiros: printf(\"%d\", matriz[(1*3)+2]); //genericamente, //printf(\"%d\", matriz[(x*colunas)+2]); Existe outra maneira de declarar uma matriz, dessa vez no formato convencional. Para tal, utiliza-se um ponteiro de um ponteiro Aloca\u00e7\u00e3o din\u00e2mica de estruturas (structs) A aloca\u00e7\u00e3o de structs funciona de forma similar ao de vari\u00e1veis, utilizando malloc ou calloc: struct areaRet{ float altura; float comprimento; float area; } struct s_circulo *p; p = (struct s_circulo *)malloc(sizeof(struct s_circulo)); //adicionar como acessar depois PI","title":"Alocamento de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocamento-de-memoria","text":"","title":"Alocamento de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#programa-e-algoritmo","text":"","title":"Programa e algoritmo"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#enderecos-de-memoria","text":"Toda vari\u00e1vel \u00e9 situada em um endere\u00e7o (uma posi\u00e7\u00e3o) da mem\u00f3ria. Quando queremos nos referir a um endere\u00e7o de mem\u00f3ria relativo a algo, utilizamos o & , como no scanf.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#relembrando-ponteiros","text":"(O conte\u00fado deste t\u00f3pico j\u00e1 foi abordado anteriormente) A vari\u00e1vel pont\u00e9iro \u00e9 uma vari\u00e1vel que armazena o endere\u00e7o de outra posi\u00e7\u00e3o na mem\u00f3ria, que pode conter outros dados. Se um ponteiro n\u00e3o armazena nenhum endere\u00e7o v\u00e1lido, o valor \u00e9 NULL Para declarar um ponteiro em C coloca-se * na frente do nome da vari\u00e1vel.","title":"Relembrando: Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#desreferenciamento-de-um-ponteiro","text":"Para acessar o conte\u00fado de uma vari\u00e1vel que o ponteiro referencia, utiliza-se * na frente do ponteiro","title":"Desreferenciamento de um ponteiro"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#variaveis","text":"","title":"Vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#estaticas","text":"Declaradas convencionalmente em tempo de projeto (ao programar)","title":"Est\u00e1ticas:"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#dinamicas","text":"Podem ser ciradas e destru\u00eddas durante a execu\u00e7\u00e3o do programa A declara\u00e7\u00e3o \u00e9 indireta e a vincula\u00e7\u00e3o, por meio de ponteiros Elas possuem diversas vantagens em rela\u00e7\u00e3o \u00e0s est\u00e1ticas, como a declara\u00e7\u00e3o de vari\u00e1veis sem desperd\u00edcio de mem\u00f3ria","title":"Din\u00e2micas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#areas-da-memoria","text":"","title":"\u00c1reas da mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-memoria","text":"Para alocar a mem\u00f3ria de vari\u00e1veis est\u00e1ticas, \u00e9 necess\u00e1rio saber a quantidade de mem\u00f3ria a ser alocada previamente. O problema disso \u00e9 que, em muitos casos, s\u00f3 \u00e9 poss\u00edvel saber a quantidade de mem\u00f3ria necess\u00e1ria durante a execu\u00e7\u00e3o do programa. Um dos maiores usos do alocamento din\u00e2mico \u00e9 com os blocos de dados (vetores e matrizes), para evitar o desperd\u00edcio ou a falta de mem\u00f3ria.","title":"Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#em-c","text":"malloc : recebe como par\u00e2metro a quantidade de mem\u00f3rias que desejamos alocar, reservando a mem\u00f3ria perdida e retomando um ponteiro void para o primeiro byte alocado. ponteiro = (int*) malloc(12); //alocamento de 12 bytes para um ponteiro com cast int (armazena n\u00fameros de t) Para descobrir a quantidade de bytes necess\u00e1rios, existe a fun\u00e7\u00e3o sizeof() , que retorna o n\u00famero de bytes utlizados para algum elemento (tipo ou struct) ponteiro = (int*) malloc(sizeof(int)); //alocamento da quantidade de bytes necess\u00e1rios para uma vari\u00e1vel int ponteiro = (int*) malloc(sizeof(int)*4 );//alocamento da quantidade de bytes necess\u00e1rios para 4 vari\u00e1veis do tipo int Tamb\u00e9m existe a fun\u00e7\u00e3o calloc, que al\u00e9m de permitir a indica\u00e7\u00e3o do n\u00famero de elementos para alocar mem\u00f3ria, define o valor de cada um dos valores para 0. ponteiro = calloc(3, sizeof(int)); //aloca 3 int e declara todos eles como 0 Ap\u00f3s utilizar o ponteiro, \u00e9 ideal utilizar free(ponteiro)","title":"Em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-matrizes-de-mais-de-uma-dimensao","text":"A forma como declaramos vari\u00e1veis din\u00e2micas demonstrada anteriormente cria uma matriz unidimensional para o armazenamento dessas informa\u00e7\u00f5es. Agora, poderemos criar \"matrizes bidimensionais\" (com uma pegadinha). Para declarar matrizes bidimensionais, podemos utilizar o seguinte: matriz = (int*) malloc(2*3*sizeof(int)); // ^ ^ // | Aloca\u00e7\u00e3o dos bytes necess\u00e1rios para o tamanho de uma \"matriz\" 2x3 // Casting do tipo //genericamente: //matriz = (int*) malloc(linhas*colunas*sizeof(int)); Apesar de ser considerada uma matriz 3x2, n\u00e3o \u00e9 poss\u00edvel utilizar printf(\"%d\", matriz[1][2]); //genericamente, //printf(\"%d\", matriz[x][y]); para chamar o elemento da 2\u00aa linha e 3\u00aa coluna. Em vez disso, \u00e9 necess\u00e1rio utilizar aritm\u00e9tica de ponteiros: printf(\"%d\", matriz[(1*3)+2]); //genericamente, //printf(\"%d\", matriz[(x*colunas)+2]); Existe outra maneira de declarar uma matriz, dessa vez no formato convencional. Para tal, utiliza-se um ponteiro de um ponteiro","title":"Aloca\u00e7\u00e3o din\u00e2mica de matrizes de mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-estruturas-structs","text":"A aloca\u00e7\u00e3o de structs funciona de forma similar ao de vari\u00e1veis, utilizando malloc ou calloc: struct areaRet{ float altura; float comprimento; float area; } struct s_circulo *p; p = (struct s_circulo *)malloc(sizeof(struct s_circulo)); //adicionar como acessar depois","title":"Aloca\u00e7\u00e3o din\u00e2mica de estruturas (structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/","text":"Entrada e Sa\u00edda de Arquivos O que s\u00e3o arquivos Arquivos s\u00e3o dados ou cole\u00e7\u00f5es de dados guardados em disco (ou qualquer armazenamento n\u00e3o vol\u00e1til, cuja informa\u00e7\u00e3o armazenada \u00e9 permanente) , sendo conservados mesmo ap\u00f3s a execu\u00e7\u00e3o do programa. Exemplos de arquivos s\u00e3o os arquivos .c escritos at\u00e9 aqui, um pdf contendo um documento. O texto que voc\u00ea est\u00e1 lendo aqui est\u00e1 armazenado em um arquivo. Mem\u00f3ria RAM, um tipo de mem\u00f3ria vol\u00e1til HDs, um tipo de mem\u00f3ria n\u00e3o vol\u00e1til Apesar de possu\u00edrem como ponto positivo a conserva\u00e7\u00e3o dos dados a longo prazo, uma desvantagem do armazenamento de tudo em arquivos \u00e9 a velocidade de acesso, afinal acessar arquivos em disco \u00e9 mais lento que acessar da mem\u00f3ria RAM ou do cache do processador, por exemplo. Acesso de arquivos em C \u00c9 poss\u00edvel acessar arquivos em C utilizando um ponteiro do tipo FILE , definido na biblioteca <stdio.h> . PI","title":"Entrada e Sa\u00edda de Arquivos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#entrada-e-saida-de-arquivos","text":"","title":"Entrada e Sa\u00edda de Arquivos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#o-que-sao-arquivos","text":"Arquivos s\u00e3o dados ou cole\u00e7\u00f5es de dados guardados em disco (ou qualquer armazenamento n\u00e3o vol\u00e1til, cuja informa\u00e7\u00e3o armazenada \u00e9 permanente) , sendo conservados mesmo ap\u00f3s a execu\u00e7\u00e3o do programa. Exemplos de arquivos s\u00e3o os arquivos .c escritos at\u00e9 aqui, um pdf contendo um documento. O texto que voc\u00ea est\u00e1 lendo aqui est\u00e1 armazenado em um arquivo. Mem\u00f3ria RAM, um tipo de mem\u00f3ria vol\u00e1til HDs, um tipo de mem\u00f3ria n\u00e3o vol\u00e1til Apesar de possu\u00edrem como ponto positivo a conserva\u00e7\u00e3o dos dados a longo prazo, uma desvantagem do armazenamento de tudo em arquivos \u00e9 a velocidade de acesso, afinal acessar arquivos em disco \u00e9 mais lento que acessar da mem\u00f3ria RAM ou do cache do processador, por exemplo.","title":"O que s\u00e3o arquivos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#acesso-de-arquivos-em-c","text":"\u00c9 poss\u00edvel acessar arquivos em C utilizando um ponteiro do tipo FILE , definido na biblioteca <stdio.h> .","title":"Acesso de arquivos em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/","text":"Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o Um algoritmo de ordena\u00e7\u00e3o possibilita a organiza\u00e7\u00e3o de vetores ou matrizes de acordo com determinados crit\u00e9rios. Aqui, criaremos o algoritmo bubble sort . O bubble sort funciona ... \u00c9 poss\u00edvel implementar o bubble sort de forma a ordenar um vetor de valores inteiros em C da seguinte maneira: //defini\u00e7\u00e3o do algoritmo de ordena\u00e7\u00e3o void bubbleSort(int matriz[], int tamanho){ int aux; for(int i = 0; i< tamanho-1; i++){ for(int j = i+1; j<tamanho; j++){ if(matriz[i]> matriz[j]){ //ordem crescente aux = matriz[i]; matriz[i] = matriz[j]; matriz[j] = aux; } } } } //execu\u00e7\u00e3o int main(){ int matriz[8] = {0,2,20,4,3,1,5,8}; //lista declarada na declara\u00e7\u00e3o da propria variavel int tamanho = 8; bubbleSort(matriz,tamanho); printf(\"\\n A lista ordenada e:\"); for(int i = 0; i< tamanho; i++){ printf(\"%d \", matriz[i]); } } O c\u00f3digo contido na fun\u00e7\u00e3o bubbleSort() ordena n\u00fameros inteiros em ordem crescente. Para orden\u00e1-los em ordem decrescente, basta modificar o trecho if(matriz [i] > matriz[j]){... para if(matriz [i] < matriz[j]){... . Ordena\u00e7\u00e3o de Strings Tamb\u00e9m \u00e9 poss\u00edvel ordenar strings em ordem alfab\u00e9tica, utilizando este mesmo algoritmo junto a fun\u00e7\u00f5es contidas na biblioteca string.h ... (continuar depois) PI Extra","title":"Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#apendice-algoritmos-de-ordenacao","text":"Um algoritmo de ordena\u00e7\u00e3o possibilita a organiza\u00e7\u00e3o de vetores ou matrizes de acordo com determinados crit\u00e9rios. Aqui, criaremos o algoritmo bubble sort . O bubble sort funciona ... \u00c9 poss\u00edvel implementar o bubble sort de forma a ordenar um vetor de valores inteiros em C da seguinte maneira: //defini\u00e7\u00e3o do algoritmo de ordena\u00e7\u00e3o void bubbleSort(int matriz[], int tamanho){ int aux; for(int i = 0; i< tamanho-1; i++){ for(int j = i+1; j<tamanho; j++){ if(matriz[i]> matriz[j]){ //ordem crescente aux = matriz[i]; matriz[i] = matriz[j]; matriz[j] = aux; } } } } //execu\u00e7\u00e3o int main(){ int matriz[8] = {0,2,20,4,3,1,5,8}; //lista declarada na declara\u00e7\u00e3o da propria variavel int tamanho = 8; bubbleSort(matriz,tamanho); printf(\"\\n A lista ordenada e:\"); for(int i = 0; i< tamanho; i++){ printf(\"%d \", matriz[i]); } } O c\u00f3digo contido na fun\u00e7\u00e3o bubbleSort() ordena n\u00fameros inteiros em ordem crescente. Para orden\u00e1-los em ordem decrescente, basta modificar o trecho if(matriz [i] > matriz[j]){... para if(matriz [i] < matriz[j]){... .","title":"Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#ordenacao-de-strings","text":"Tamb\u00e9m \u00e9 poss\u00edvel ordenar strings em ordem alfab\u00e9tica, utilizando este mesmo algoritmo junto a fun\u00e7\u00f5es contidas na biblioteca string.h ... (continuar depois)","title":"Ordena\u00e7\u00e3o de Strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#extra","text":"","title":"Extra"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/","text":"Menu PI <- Menu inicial Menu de navega\u00e7\u00e3o Aula Nome 1. Conceitos iniciais 2. Operadores relacionais e condicionais 3. Strings 4. Estruturas de Repeti\u00e7\u00e3o 5. Vetores(Arrays) 6. Matrizes nDimensionais 7. Estruturas Heterog\u00eaneas de Dados (Structs) 8. Fun\u00e7\u00f5es e Escopos 9. Recursividade 10. Ponteiros 11. Alocamento de mem\u00f3ria 12. Entrada e Sa\u00edda de Arquivos 13. Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o","title":"Menu"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#menu","text":"","title":"Menu"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#pi","text":"<- Menu inicial","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#menu-de-navegacao","text":"Aula Nome 1. Conceitos iniciais 2. Operadores relacionais e condicionais 3. Strings 4. Estruturas de Repeti\u00e7\u00e3o 5. Vetores(Arrays) 6. Matrizes nDimensionais 7. Estruturas Heterog\u00eaneas de Dados (Structs) 8. Fun\u00e7\u00f5es e Escopos 9. Recursividade 10. Ponteiros 11. Alocamento de mem\u00f3ria 12. Entrada e Sa\u00edda de Arquivos 13. Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o","title":"Menu de navega\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/","text":"Aula 1 - Conceitos B\u00e1sicos Caracter\u00edsticas do paradigma imperativo O paradigma imperativo possui caracter\u00edsticas como - Estruturas de controle (escolha e repeti\u00e7\u00e3o) - Entrada e sa\u00edda de dados - Tratamento de erros e de exce\u00e7\u00f5es (retornos, etc) - Abstra\u00e7\u00e3o procedural - Express\u00f5es e comandos de atribui\u00e7\u00e3o (defini\u00e7\u00e3o de vari\u00e1veis, fun\u00e7\u00f5es, etc) - Bibliotecas de apoio (bibliotecas como stdio.h ) Programa\u00e7\u00e3o estruturada Com a programa\u00e7\u00e3o estruturada, o fluxo de execu\u00e7\u00e3o ocorre de forma organizada, sem comandos como goto , que permitiam que a execu\u00e7\u00e3o pulasse entre diferentes linhas do c\u00f3digo, deixando o c\u00f3digo desorganizado e ca\u00f3tico. . . . Apesar de o c\u00f3digo ser mais organizado, a programa\u00e7\u00e3o imperativa possui um problema: o foco em fun\u00e7\u00f5es e n\u00e3o nos dados , o que gerava um c\u00f3digo dif\u00edcil de manter, de entender e de reaproveitar. Al\u00e9m disso, n\u00e3o havia prote\u00e7\u00e3o de dados robusta entre escopos de execu\u00e7\u00e3o. Surgimento da Orienta\u00e7\u00e3o a Objetos Com a necessidade de um novo paradigma, novas linguagens foram desenvolvidas: A linguagem Simula 67 idealizada por Ole-Johan Dahl e Kristen Nygaard, na Noruega. Ela possu\u00eda caracter\u00edsticas que permitiam a abstra\u00e7\u00e3o de procedimentos e de dados, de forma que novos tipos de dados poderiam ser criados, al\u00e9m do encapsulamento e da visibilidade desses dados. Os conceitos aplicados foram refinados e nomeados por Alan Kay, um matem\u00e1tico, inform\u00e1tico e bi\u00f3logo estadunidense, com a linguagem Smalltalk . V\u00e1rias outras linguagens como Java, PHP, C++, utilizam hoje a Orienta\u00e7\u00e3o a Objetos, o que facilita o desenvolvimento de novos programas e aplicativos. Encapsulamento e visibilidade Um dos pilares da POO, encapsulamento \u00e9 o isolamento de componentes da implementa\u00e7\u00e3o, permitindo que esses componentes sejam utilizados, mas sem que o seu interior seja exposto. Em outras palavras, \u00e9 o ato de esconder o interior de algum objeto ou fun\u00e7\u00e3o, impedindo que programas que os acessem vejam o interior desses componentes. Os modificadores de visibilidade indicam o n\u00edvel de acesso de partes do programa a determinados elementos de uma classe. Esses n\u00edveis de acesso s\u00e3o: - P\u00fablico (+): Os atributos podem ser acessados e modificados fora da classe que ele pertence - Privado (-): Os atributos s\u00f3 podem ser acessados ou modificados dentro da pr\u00f3pria classe, por m\u00e9todos - Protegido(#): Os atributos podem ser acessados ou modificados pela classe que ele pertence e por suas subclasses Por meio dos modificadores de visibilidade, \u00e9 poss\u00edvel encapsular partes do c\u00f3digo, de forma que eles fiquem isolados de outras partes do c\u00f3digo. Algumas das vantagens do encapsulamento s\u00e3o: * As mudan\u00e7as realizadas no objeto encapsulado s\u00e3o invis\u00edveis ao exterior, de forma que mesmo com altera\u00e7\u00f5es a ele, sua funcionalidade permanece a mesma. * \u00c9 poss\u00edvel reaproveitar melhor o c\u00f3digo de componentes encapsulados entre diferentes projetos * A redu\u00e7\u00e3o de poss\u00edveis erros e altera\u00e7\u00f5es durante a escrita ou a execu\u00e7\u00e3o do c\u00f3digo, pois evita a modifica\u00e7\u00e3o indesejada de valores nessas ocasi\u00f5es. A linguagem Java -Escrever depois-","title":"Aula 1 - Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#aula-1-conceitos-basicos","text":"","title":"Aula 1 - Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#caracteristicas-do-paradigma-imperativo","text":"O paradigma imperativo possui caracter\u00edsticas como - Estruturas de controle (escolha e repeti\u00e7\u00e3o) - Entrada e sa\u00edda de dados - Tratamento de erros e de exce\u00e7\u00f5es (retornos, etc) - Abstra\u00e7\u00e3o procedural - Express\u00f5es e comandos de atribui\u00e7\u00e3o (defini\u00e7\u00e3o de vari\u00e1veis, fun\u00e7\u00f5es, etc) - Bibliotecas de apoio (bibliotecas como stdio.h )","title":"Caracter\u00edsticas do paradigma imperativo"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#programacao-estruturada","text":"Com a programa\u00e7\u00e3o estruturada, o fluxo de execu\u00e7\u00e3o ocorre de forma organizada, sem comandos como goto , que permitiam que a execu\u00e7\u00e3o pulasse entre diferentes linhas do c\u00f3digo, deixando o c\u00f3digo desorganizado e ca\u00f3tico. . . . Apesar de o c\u00f3digo ser mais organizado, a programa\u00e7\u00e3o imperativa possui um problema: o foco em fun\u00e7\u00f5es e n\u00e3o nos dados , o que gerava um c\u00f3digo dif\u00edcil de manter, de entender e de reaproveitar. Al\u00e9m disso, n\u00e3o havia prote\u00e7\u00e3o de dados robusta entre escopos de execu\u00e7\u00e3o.","title":"Programa\u00e7\u00e3o estruturada"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#surgimento-da-orientacao-a-objetos","text":"Com a necessidade de um novo paradigma, novas linguagens foram desenvolvidas: A linguagem Simula 67 idealizada por Ole-Johan Dahl e Kristen Nygaard, na Noruega. Ela possu\u00eda caracter\u00edsticas que permitiam a abstra\u00e7\u00e3o de procedimentos e de dados, de forma que novos tipos de dados poderiam ser criados, al\u00e9m do encapsulamento e da visibilidade desses dados. Os conceitos aplicados foram refinados e nomeados por Alan Kay, um matem\u00e1tico, inform\u00e1tico e bi\u00f3logo estadunidense, com a linguagem Smalltalk . V\u00e1rias outras linguagens como Java, PHP, C++, utilizam hoje a Orienta\u00e7\u00e3o a Objetos, o que facilita o desenvolvimento de novos programas e aplicativos.","title":"Surgimento da Orienta\u00e7\u00e3o a Objetos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#encapsulamento-e-visibilidade","text":"Um dos pilares da POO, encapsulamento \u00e9 o isolamento de componentes da implementa\u00e7\u00e3o, permitindo que esses componentes sejam utilizados, mas sem que o seu interior seja exposto. Em outras palavras, \u00e9 o ato de esconder o interior de algum objeto ou fun\u00e7\u00e3o, impedindo que programas que os acessem vejam o interior desses componentes. Os modificadores de visibilidade indicam o n\u00edvel de acesso de partes do programa a determinados elementos de uma classe. Esses n\u00edveis de acesso s\u00e3o: - P\u00fablico (+): Os atributos podem ser acessados e modificados fora da classe que ele pertence - Privado (-): Os atributos s\u00f3 podem ser acessados ou modificados dentro da pr\u00f3pria classe, por m\u00e9todos - Protegido(#): Os atributos podem ser acessados ou modificados pela classe que ele pertence e por suas subclasses Por meio dos modificadores de visibilidade, \u00e9 poss\u00edvel encapsular partes do c\u00f3digo, de forma que eles fiquem isolados de outras partes do c\u00f3digo. Algumas das vantagens do encapsulamento s\u00e3o: * As mudan\u00e7as realizadas no objeto encapsulado s\u00e3o invis\u00edveis ao exterior, de forma que mesmo com altera\u00e7\u00f5es a ele, sua funcionalidade permanece a mesma. * \u00c9 poss\u00edvel reaproveitar melhor o c\u00f3digo de componentes encapsulados entre diferentes projetos * A redu\u00e7\u00e3o de poss\u00edveis erros e altera\u00e7\u00f5es durante a escrita ou a execu\u00e7\u00e3o do c\u00f3digo, pois evita a modifica\u00e7\u00e3o indesejada de valores nessas ocasi\u00f5es.","title":"Encapsulamento e visibilidade"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/#a-linguagem-java","text":"-Escrever depois-","title":"A linguagem Java"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/","text":"Classes e objetos Classes Classes \"definem atributos e m\u00e9todos comuns que ser\u00e3o compartilhados por um objeto.\" Classes s\u00e3o justamente formas de se identificar e gerar, de forma gen\u00e9rica, um objeto. Classes precisam ter, assim como objetos, caracter\u00edsticas (atributos), comportamentos (m\u00e9todos) e estados poss\u00edveis. [!Dica] Classes funcionam de forma similar (mas n\u00e3o igual) a structs da linguagem C. A diferen\u00e7a \u00e9 que, enquanto structs possuem apenas atributos , classes tamb\u00e9m incorporam os m\u00e9todos e conceitos essenciais da Orienta\u00e7\u00e3o a objetos, como os 3 pilares (Encapsulamento, Heran\u00e7a e polimorfismo), que ser\u00e3o abordados nos documentos seguintes. Objetos Objetos s\u00e3o inst\u00e2ncias de uma classe, com valores de atributos e comportamentos definidos, e podendo usar m\u00e9todos de sua classe, podendo utilizar esses m\u00e9todos e atributos para interagir com outros objetos. Atributos Atributos s\u00e3o caracter\u00edsticas do objeto. Do que ele \u00e9 feito, ou o uso apropriado, entre outras caracter\u00edsticas. Voltando ao exemplo da cadeira, podemos definir uma classe Cadeira, com atributos material , estofado , uso externo? , vazada , n\u00famero de p\u00e9s . Perceba que nem todos os atributos aceitam dados de um mesmo tipo. material aceita uma palavra ou frase, como madeira ou pl\u00e1stico. uso externo \u00e9 uma pergunta de sim ou n\u00e3o (booleano). n\u00famero de p\u00e9s aceita n\u00fameros inteiros. M\u00e9todos M\u00e9todos s\u00e3o as a\u00e7\u00f5es poss\u00edveis com aquele objeto. Ent\u00e3o \u00e9 poss\u00edvel que a cadeira tenha um m\u00e9todo chamado sentar() , que permite que a pessoa se sente, levantar() , que permite que a pessoa se levante, ou at\u00e9 mesmo derrubar() e levantarCadeira() , que permite que a cadeira seja derrubada ou levantada do ch\u00e3o Dentro dos m\u00e9todos, haver\u00e3o algoritmos para a realiza\u00e7\u00e3o dessas a\u00e7\u00f5es. Ent\u00e3o, para o m\u00e9todo sentar() , por exemplo, podemos elaborar um algoritmo que determine que, caso ningu\u00e9m esteja sentado na cadeira, o usu\u00e1rio pode se sentar nela. Ou ent\u00e3o, no m\u00e9todo levantarCadeira() , caso a cadeira esteja no ch\u00e3o, o usu\u00e1rio pode levant\u00e1-la. Perceba que \u00e9 necess\u00e1rio averiguar os estados da cadeira para tal Estados O estado dos objetos \u00e9 determinado em momentos espec\u00edficos. Uma cadeira pode estar ocupada ou desocupada, pode estar ca\u00edda no ch\u00e3o ou n\u00e3o. Note a rela\u00e7\u00e3o que, se a cadeira estiver no ch\u00e3o, ela n\u00e3o pode estar ocupada.","title":"Classes e objetos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#classes-e-objetos","text":"","title":"Classes e objetos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#classes","text":"Classes \"definem atributos e m\u00e9todos comuns que ser\u00e3o compartilhados por um objeto.\" Classes s\u00e3o justamente formas de se identificar e gerar, de forma gen\u00e9rica, um objeto. Classes precisam ter, assim como objetos, caracter\u00edsticas (atributos), comportamentos (m\u00e9todos) e estados poss\u00edveis. [!Dica] Classes funcionam de forma similar (mas n\u00e3o igual) a structs da linguagem C. A diferen\u00e7a \u00e9 que, enquanto structs possuem apenas atributos , classes tamb\u00e9m incorporam os m\u00e9todos e conceitos essenciais da Orienta\u00e7\u00e3o a objetos, como os 3 pilares (Encapsulamento, Heran\u00e7a e polimorfismo), que ser\u00e3o abordados nos documentos seguintes.","title":"Classes"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#objetos","text":"Objetos s\u00e3o inst\u00e2ncias de uma classe, com valores de atributos e comportamentos definidos, e podendo usar m\u00e9todos de sua classe, podendo utilizar esses m\u00e9todos e atributos para interagir com outros objetos.","title":"Objetos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#atributos","text":"Atributos s\u00e3o caracter\u00edsticas do objeto. Do que ele \u00e9 feito, ou o uso apropriado, entre outras caracter\u00edsticas. Voltando ao exemplo da cadeira, podemos definir uma classe Cadeira, com atributos material , estofado , uso externo? , vazada , n\u00famero de p\u00e9s . Perceba que nem todos os atributos aceitam dados de um mesmo tipo. material aceita uma palavra ou frase, como madeira ou pl\u00e1stico. uso externo \u00e9 uma pergunta de sim ou n\u00e3o (booleano). n\u00famero de p\u00e9s aceita n\u00fameros inteiros.","title":"Atributos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#metodos","text":"M\u00e9todos s\u00e3o as a\u00e7\u00f5es poss\u00edveis com aquele objeto. Ent\u00e3o \u00e9 poss\u00edvel que a cadeira tenha um m\u00e9todo chamado sentar() , que permite que a pessoa se sente, levantar() , que permite que a pessoa se levante, ou at\u00e9 mesmo derrubar() e levantarCadeira() , que permite que a cadeira seja derrubada ou levantada do ch\u00e3o Dentro dos m\u00e9todos, haver\u00e3o algoritmos para a realiza\u00e7\u00e3o dessas a\u00e7\u00f5es. Ent\u00e3o, para o m\u00e9todo sentar() , por exemplo, podemos elaborar um algoritmo que determine que, caso ningu\u00e9m esteja sentado na cadeira, o usu\u00e1rio pode se sentar nela. Ou ent\u00e3o, no m\u00e9todo levantarCadeira() , caso a cadeira esteja no ch\u00e3o, o usu\u00e1rio pode levant\u00e1-la. Perceba que \u00e9 necess\u00e1rio averiguar os estados da cadeira para tal","title":"M\u00e9todos"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/#estados","text":"O estado dos objetos \u00e9 determinado em momentos espec\u00edficos. Uma cadeira pode estar ocupada ou desocupada, pode estar ca\u00edda no ch\u00e3o ou n\u00e3o. Note a rela\u00e7\u00e3o que, se a cadeira estiver no ch\u00e3o, ela n\u00e3o pode estar ocupada.","title":"Estados"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/03%20-%20Abstra%C3%A7%C3%A3o/","text":"Abstra\u00e7\u00e3o A programa\u00e7\u00e3o orientada a objetos modela problemas e os aproxima do mundo real, utilizando de abstra\u00e7\u00e3o para tal. Para criar Classes e objetos em POO, \u00e9 necess\u00e1rio identificar os atributos e m\u00e9todos relevantes para o contexto em que esses objetos est\u00e3o sendo aplicados, afinal, n\u00e3o seria necess\u00e1rio identificar, por exemplo, o peso de uma pessoa para a matr\u00edcula em uma faculdade. Essa identifica\u00e7\u00e3o recebe o nome de Abstra\u00e7\u00e3o , e \u00e9 um conceito muito importante na Orienta\u00e7\u00e3o a Objetos.","title":"Abstra\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/03%20-%20Abstra%C3%A7%C3%A3o/#abstracao","text":"A programa\u00e7\u00e3o orientada a objetos modela problemas e os aproxima do mundo real, utilizando de abstra\u00e7\u00e3o para tal. Para criar Classes e objetos em POO, \u00e9 necess\u00e1rio identificar os atributos e m\u00e9todos relevantes para o contexto em que esses objetos est\u00e3o sendo aplicados, afinal, n\u00e3o seria necess\u00e1rio identificar, por exemplo, o peso de uma pessoa para a matr\u00edcula em uma faculdade. Essa identifica\u00e7\u00e3o recebe o nome de Abstra\u00e7\u00e3o , e \u00e9 um conceito muito importante na Orienta\u00e7\u00e3o a Objetos.","title":"Abstra\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/04%20-%20Encapsulamento/","text":"Encapsulamento Encapsulamento \u00e9 o isolamento de componentes da implementa\u00e7\u00e3o, permitindo que esses componentes sejam utilizados, mas sem que o seu interior seja exposto. Em outras palavras, \u00e9 o ato de esconder o interior de algum objeto ou fun\u00e7\u00e3o, impedindo que programas que os acessem vejam o interior desses componentes. Uma das vantagens do encapsulamento \u00e9 que as mudan\u00e7as realizadas ao componente encapsulado s\u00e3o invis\u00edveis ao mundo exterior, desde que sua interface opere da mesma forma. Isso significa que, ao atualiza\u00e7\u00f5es e corre\u00e7\u00f5es de bugs, a funcionalidade e o modo de opera\u00e7\u00e3o do componente encapsulado permanecem os mesmos. A segunda vantagem \u00e9 a reutiliza\u00e7\u00e3o do c\u00f3digo, afinal, \u00e9 poss\u00edvel reutilizar componentes encapsulados em outros projetos que necessitem realizar procedimentos semelhantes entre programas. A terceira e \u00faltima \u00e9 a redu\u00e7\u00e3o de efeitos colaterais \u00e0 execu\u00e7\u00e3o do c\u00f3digo, afinal, objetos encapsulados mant\u00e9m protegidas as suas partes interiores, impedindo altera\u00e7\u00f5es indesejadas na escrita ou durante a execu\u00e7\u00e3o do programa.","title":"Encapsulamento"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/04%20-%20Encapsulamento/#encapsulamento","text":"Encapsulamento \u00e9 o isolamento de componentes da implementa\u00e7\u00e3o, permitindo que esses componentes sejam utilizados, mas sem que o seu interior seja exposto. Em outras palavras, \u00e9 o ato de esconder o interior de algum objeto ou fun\u00e7\u00e3o, impedindo que programas que os acessem vejam o interior desses componentes. Uma das vantagens do encapsulamento \u00e9 que as mudan\u00e7as realizadas ao componente encapsulado s\u00e3o invis\u00edveis ao mundo exterior, desde que sua interface opere da mesma forma. Isso significa que, ao atualiza\u00e7\u00f5es e corre\u00e7\u00f5es de bugs, a funcionalidade e o modo de opera\u00e7\u00e3o do componente encapsulado permanecem os mesmos. A segunda vantagem \u00e9 a reutiliza\u00e7\u00e3o do c\u00f3digo, afinal, \u00e9 poss\u00edvel reutilizar componentes encapsulados em outros projetos que necessitem realizar procedimentos semelhantes entre programas. A terceira e \u00faltima \u00e9 a redu\u00e7\u00e3o de efeitos colaterais \u00e0 execu\u00e7\u00e3o do c\u00f3digo, afinal, objetos encapsulados mant\u00e9m protegidas as suas partes interiores, impedindo altera\u00e7\u00f5es indesejadas na escrita ou durante a execu\u00e7\u00e3o do programa.","title":"Encapsulamento"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/05%20-%20Rela%C3%A7%C3%A3o%20cliente-Servidor/","text":"","title":"05   Rela\u00e7\u00e3o cliente Servidor"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/06-/","text":"","title":"06 "},{"location":"Pr%C3%A1tica%20em%20Sistemas%20Digitais/00%20-%20Introdu%C3%A7%C3%A3o/","text":"Introdu\u00e7\u00e3o Panorama da disciplina","title":"Introdu\u00e7\u00e3o"},{"location":"Pr%C3%A1tica%20em%20Sistemas%20Digitais/00%20-%20Introdu%C3%A7%C3%A3o/#introducao","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"Pr%C3%A1tica%20em%20Sistemas%20Digitais/00%20-%20Introdu%C3%A7%C3%A3o/#panorama-da-disciplina","text":"","title":"Panorama da disciplina"}]}