{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ArquivosUFS Bem vindo ao site de ARQUIVOS DA UFS Reposit\u00f3rio com anota\u00e7\u00f5es de disciplinas dos cursos de Computa\u00e7\u00e3o da UFS Disciplinas Disciplina Programa\u00e7\u00e3o Funcional Programa\u00e7\u00e3o Imperativa Programa\u00e7\u00e3o Orientada a Objetos Feito por Gustavo Gomes","title":"ArquivosUFS"},{"location":"#arquivosufs","text":"Bem vindo ao site de ARQUIVOS DA UFS Reposit\u00f3rio com anota\u00e7\u00f5es de disciplinas dos cursos de Computa\u00e7\u00e3o da UFS","title":"ArquivosUFS"},{"location":"#disciplinas","text":"Disciplina Programa\u00e7\u00e3o Funcional Programa\u00e7\u00e3o Imperativa Programa\u00e7\u00e3o Orientada a Objetos Feito por Gustavo Gomes","title":"Disciplinas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/","text":"Conceitos B\u00e1sicos PF <- Voltar Defini\u00e7\u00e3o e aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o Uma fun\u00e7\u00e3o \u00e9 definida utilizando a palavra function ou a nota\u00e7\u00e3o arrow (como demonstrado em fun\u00e7\u00f5es como express\u00f5es ). A aplica\u00e7\u00e3o \u00e9 o uso dessa fun\u00e7\u00e3o. Exemplo: function areaCirc(r){ /*###############*/ const pi = 3.14 /*## DEFINI\u00c7\u00c3O ##*/ return pi*r**2 /*##############*/ } console.log(areacirc(3)) // ## APLICA\u00c7\u00c3O ## */ Pureza const pi = 3.14 function areaCirc(r){ return pi*r**2 } Uma fun\u00e7\u00e3o \u00e9 pura quando recebe todas as constantes no escopo local. A fun\u00e7\u00e3o acima \u00e9 IMPURA , pois recebe um par\u00e2metro (pi) do escopo global. Essa fun\u00e7\u00e3o pode ser considerada pura como abaixo function areaCircPura(r){ const pi = 3.14 return pi*r**2 } acima, a constante pi \u00e9 definida no escopo LOCAL da fun\u00e7\u00e3o function areaCircImpEst(r){ return Math.PI*r**2 } Essa outra fun\u00e7\u00e3o pode ser considerada IMPURA EST\u00c1VEL , pois recebe uma constante n\u00e3o definida no escopo ( Math.PI ), mas que existe na pr\u00f3pria linguagem. Fun\u00e7\u00e3o como Express\u00e3o As fun\u00e7\u00f5es declaradas usando a palavra function (como todas acima) n\u00e3o s\u00e3o consideradas \"Cidad\u00e3s de primeira classe\", n\u00e3o estando no mesmo n\u00edvel de uma constante ou um valor qualquer. para elevar o n\u00edvel da fun\u00e7\u00e3o ao mesmo de outro, utiliza-se a chamada NOTA\u00c7\u00c3O ARROW ( => ), podendo ser utilizada da seguinte forma: const areaCircArrow = (r) => 3.14*r**2 //<-- representa\u00e7\u00e3o da fun\u00e7\u00e3o como express\u00e3o // ^constante ^nome ^express\u00e3o de mapeamento agora a fun\u00e7\u00e3o \u00e9 uma \"Cidad\u00e3 de primeira classe\" a aplica\u00e7\u00e3o da fun\u00e7\u00e3o ocorre da mesma forma [ areaCircArrow() ]. no caso de a fun\u00e7\u00e3o ter uma linha, n\u00e3o \u00e9 necess\u00e1rio usar \"return\". const areaCircArrowchaves = (r) =>{ return 3.14*r**2 } mas no caso acima(entre chaves e com mais de uma linha), \u00e9 obrigat\u00f3rio. A partir de agora, usaremos apenas fun\u00e7\u00f5es desse jeito. Fun\u00e7\u00f5es como Argumento fun\u00e7\u00f5es podem ser passadas como argumento em outras fun\u00e7\u00f5es. fun\u00e7\u00f5es que recebem e/ou retornam outras fun\u00e7\u00f5es s\u00e3o chamadas de FUN\u00c7\u00d5ES DE ALTA ORDEM . const exec = (f,x,y) => f(x,y) const pot = (b,e) => b**e console.log(exec(pot,2,3)) A fun\u00e7\u00e3o exec() acima recebe uma fun\u00e7\u00e3o e dois par\u00e2metros para aplicar na fun\u00e7\u00e3o escolhida, no caso pot() . Fun\u00e7\u00f5es como retorno, currying e aplica\u00e7\u00e3o parcial Fun\u00e7\u00f5es tamb\u00e9m podem ser retornadas por outras fun\u00e7\u00f5es, a exemplo do uso de currying junto \u00e0 aplica\u00e7\u00e3o parcial. CURRYING \u00e9 a organiza\u00e7\u00e3o de fun\u00e7\u00f5es para que seus par\u00e2metros (ou argumentos) sejam passados de forma gradual/desagregada (ou seja, com APLICA\u00c7\u00c3O PARCIAL da fun\u00e7\u00e3o). Fun\u00e7\u00e3o n\u00e3o \"currificada\" const pot = (b,e) => b**e console.log(pot(5,2)) A fun\u00e7\u00e3o que define a pot\u00eancia de forma geral, dessa forma, n\u00e3o pode ser utilizada para fazer uma nova fun\u00e7\u00e3o para calcular o quadrado ou o cubo, etc. Agora, vamos ver a vers\u00e3o \"currificada\" e apresentando aplica\u00e7\u00e3o parcial. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados const quad = potCurry(2) //exemplos de aplica\u00e7\u00e3o parcial const cubo = potCurry(3) const base = 5 console.log(quad(base), cubo(base)) Aqui, a fun\u00e7\u00e3o utiliza tanto currying quanto aplica\u00e7\u00e3o parcial, mas \u00e9 poss\u00edvel fazer a aplica\u00e7\u00e3o total da fun\u00e7\u00e3o. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados console.log(potCurry(5)(2)) //aplica\u00e7\u00e3o total de uma fun\u00e7\u00e3o desagregada Fun\u00e7\u00f5es An\u00f4nimas S\u00e3o fun\u00e7\u00f5es sem nome, podendo ser definidas na execu\u00e7\u00e3o. const exec = (f, ...nconst) => f(...nconst) console.log(exec((x,y) => x**y,5,2)) console.log(exec((a,b,c)=> a+b+c , 3,4,5)) console.log(exec((a,b,c,d)=> a+b+c+d , 3,4,5,6)) A fun\u00e7\u00e3o exec , que recebe n par\u00e2metros (uma fun\u00e7\u00e3o, qualquer n\u00famero de par\u00e2metros*), \u00e9 aplicada utilizando fun\u00e7\u00f5es an\u00f4nimas, a exemplo de (x,y) => x**y . *A aplica\u00e7\u00e3o para receber qualquer n\u00famero de par\u00e2metros (denominada par\u00e2metro REST) pode ser representada por ...nomeDaConst , sendo nomeDaConst qualquer nome para o conjunto de par\u00e2metros recebidos. ATEN\u00c7\u00c3O! Por meio disso, n\u00e3o \u00e9 poss\u00edvel utilizar aplica\u00e7\u00e3o parcial.","title":"Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#conceitos-basicos","text":"","title":"Conceitos B\u00e1sicos"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#pf","text":"<- Voltar","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#definicao-e-aplicacao-de-uma-funcao","text":"Uma fun\u00e7\u00e3o \u00e9 definida utilizando a palavra function ou a nota\u00e7\u00e3o arrow (como demonstrado em fun\u00e7\u00f5es como express\u00f5es ). A aplica\u00e7\u00e3o \u00e9 o uso dessa fun\u00e7\u00e3o. Exemplo: function areaCirc(r){ /*###############*/ const pi = 3.14 /*## DEFINI\u00c7\u00c3O ##*/ return pi*r**2 /*##############*/ } console.log(areacirc(3)) // ## APLICA\u00c7\u00c3O ## */","title":"Defini\u00e7\u00e3o e aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#pureza","text":"const pi = 3.14 function areaCirc(r){ return pi*r**2 } Uma fun\u00e7\u00e3o \u00e9 pura quando recebe todas as constantes no escopo local. A fun\u00e7\u00e3o acima \u00e9 IMPURA , pois recebe um par\u00e2metro (pi) do escopo global. Essa fun\u00e7\u00e3o pode ser considerada pura como abaixo function areaCircPura(r){ const pi = 3.14 return pi*r**2 } acima, a constante pi \u00e9 definida no escopo LOCAL da fun\u00e7\u00e3o function areaCircImpEst(r){ return Math.PI*r**2 } Essa outra fun\u00e7\u00e3o pode ser considerada IMPURA EST\u00c1VEL , pois recebe uma constante n\u00e3o definida no escopo ( Math.PI ), mas que existe na pr\u00f3pria linguagem.","title":"Pureza"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcao-como-expressao","text":"As fun\u00e7\u00f5es declaradas usando a palavra function (como todas acima) n\u00e3o s\u00e3o consideradas \"Cidad\u00e3s de primeira classe\", n\u00e3o estando no mesmo n\u00edvel de uma constante ou um valor qualquer. para elevar o n\u00edvel da fun\u00e7\u00e3o ao mesmo de outro, utiliza-se a chamada NOTA\u00c7\u00c3O ARROW ( => ), podendo ser utilizada da seguinte forma: const areaCircArrow = (r) => 3.14*r**2 //<-- representa\u00e7\u00e3o da fun\u00e7\u00e3o como express\u00e3o // ^constante ^nome ^express\u00e3o de mapeamento agora a fun\u00e7\u00e3o \u00e9 uma \"Cidad\u00e3 de primeira classe\" a aplica\u00e7\u00e3o da fun\u00e7\u00e3o ocorre da mesma forma [ areaCircArrow() ]. no caso de a fun\u00e7\u00e3o ter uma linha, n\u00e3o \u00e9 necess\u00e1rio usar \"return\". const areaCircArrowchaves = (r) =>{ return 3.14*r**2 } mas no caso acima(entre chaves e com mais de uma linha), \u00e9 obrigat\u00f3rio. A partir de agora, usaremos apenas fun\u00e7\u00f5es desse jeito.","title":"Fun\u00e7\u00e3o como Express\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-como-argumento","text":"fun\u00e7\u00f5es podem ser passadas como argumento em outras fun\u00e7\u00f5es. fun\u00e7\u00f5es que recebem e/ou retornam outras fun\u00e7\u00f5es s\u00e3o chamadas de FUN\u00c7\u00d5ES DE ALTA ORDEM . const exec = (f,x,y) => f(x,y) const pot = (b,e) => b**e console.log(exec(pot,2,3)) A fun\u00e7\u00e3o exec() acima recebe uma fun\u00e7\u00e3o e dois par\u00e2metros para aplicar na fun\u00e7\u00e3o escolhida, no caso pot() .","title":"Fun\u00e7\u00f5es como Argumento"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-como-retorno-currying-e-aplicacao-parcial","text":"Fun\u00e7\u00f5es tamb\u00e9m podem ser retornadas por outras fun\u00e7\u00f5es, a exemplo do uso de currying junto \u00e0 aplica\u00e7\u00e3o parcial. CURRYING \u00e9 a organiza\u00e7\u00e3o de fun\u00e7\u00f5es para que seus par\u00e2metros (ou argumentos) sejam passados de forma gradual/desagregada (ou seja, com APLICA\u00c7\u00c3O PARCIAL da fun\u00e7\u00e3o). Fun\u00e7\u00e3o n\u00e3o \"currificada\" const pot = (b,e) => b**e console.log(pot(5,2)) A fun\u00e7\u00e3o que define a pot\u00eancia de forma geral, dessa forma, n\u00e3o pode ser utilizada para fazer uma nova fun\u00e7\u00e3o para calcular o quadrado ou o cubo, etc. Agora, vamos ver a vers\u00e3o \"currificada\" e apresentando aplica\u00e7\u00e3o parcial. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados const quad = potCurry(2) //exemplos de aplica\u00e7\u00e3o parcial const cubo = potCurry(3) const base = 5 console.log(quad(base), cubo(base)) Aqui, a fun\u00e7\u00e3o utiliza tanto currying quanto aplica\u00e7\u00e3o parcial, mas \u00e9 poss\u00edvel fazer a aplica\u00e7\u00e3o total da fun\u00e7\u00e3o. const potCurry = (e) => (b) => b**e //par\u00e2metros desagregados console.log(potCurry(5)(2)) //aplica\u00e7\u00e3o total de uma fun\u00e7\u00e3o desagregada","title":"Fun\u00e7\u00f5es como retorno, currying e aplica\u00e7\u00e3o parcial"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/#funcoes-anonimas","text":"S\u00e3o fun\u00e7\u00f5es sem nome, podendo ser definidas na execu\u00e7\u00e3o. const exec = (f, ...nconst) => f(...nconst) console.log(exec((x,y) => x**y,5,2)) console.log(exec((a,b,c)=> a+b+c , 3,4,5)) console.log(exec((a,b,c,d)=> a+b+c+d , 3,4,5,6)) A fun\u00e7\u00e3o exec , que recebe n par\u00e2metros (uma fun\u00e7\u00e3o, qualquer n\u00famero de par\u00e2metros*), \u00e9 aplicada utilizando fun\u00e7\u00f5es an\u00f4nimas, a exemplo de (x,y) => x**y . *A aplica\u00e7\u00e3o para receber qualquer n\u00famero de par\u00e2metros (denominada par\u00e2metro REST) pode ser representada por ...nomeDaConst , sendo nomeDaConst qualquer nome para o conjunto de par\u00e2metros recebidos. ATEN\u00c7\u00c3O! Por meio disso, n\u00e3o \u00e9 poss\u00edvel utilizar aplica\u00e7\u00e3o parcial.","title":"Fun\u00e7\u00f5es An\u00f4nimas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/","text":"Listas e Registros PF <- Voltar \u00c9 poss\u00edvel fazer cole\u00e7\u00f5es de dados em linguagens de programa\u00e7\u00e3o como o JavaScript. As cole\u00e7\u00f5es que utilizaremos aqui s\u00e3o as listas (arrays) e registros. Tamb\u00e9m ser\u00e3o vistas opera\u00e7\u00f5es as quais \u00e9 poss\u00edvel realizar com essas cole\u00e7\u00f5es de dados. Listas As listas s\u00e3o cole\u00e7\u00f5es ordenadas de dados. Esses dados podem ser de qualquer tipo, incluindo outras cole\u00e7\u00f5es de dados const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] A estrutura acima \u00e9 uma lista que cont\u00e9m diferentes strings . e cada item da lista pode ser acessado por meio de nomes[x] , sendo x o \u00edndice (sendo 0 o primeiro item) que representa cada item. const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] console.log(nomes[0]) O c\u00f3digo acima retorna: 'Jo\u00e3o' Pode existir listas dentro de listas, como no exemplo abaixo const multiplos = [[3,1],[6,3,1],[9,6,3,1],[12,9,6,3,1]] Opera\u00e7\u00f5es com Listas Podemos fazer 3 opera\u00e7\u00f5es com listas: Mapeamento Uma opera\u00e7\u00e3o de mapeamento cria uma nova lista com o mesmo n\u00famero de elementos. Esses elementos s\u00e3o modificados de acordo com uma fun\u00e7\u00e3o ou express\u00e3o definida const numeros = [2,3,5,8,10,12] const dobroLista = (lista) => lista.map((x) => x * 2) console.log(dobrolista(numeros)) O c\u00f3digo acima retorna [4,6,10,16,20,24] Para entender o c\u00f3digo anterior, \u00e9 necess\u00e1rio apontar algumas coisas: Na express\u00e3o lista.map((x) => x * 2) , x representa o elemento a ser operado na lista. Ou seja, para o caso do 2 (primeiro elemento da lista), a opera\u00e7\u00e3o realizada \u00e9 (2)= 2 * 2 , que retorna 4 A quantidade de elementos na lista N\u00c3O \u00e9 modificada S\u00e3o geradas novas listas contendo os novos valores do mapeamento. Filtragem As opera\u00e7\u00f5es de filtragem retomam uma nova lista com elementos cuja fun\u00e7\u00e3o ou express\u00e3o tenha condi\u00e7\u00e3o satisfeita. Logo, as express\u00f5es utilizadas na opera\u00e7\u00e3o s\u00e3o de valor Booleano (Verdadeiro ou Falso) const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael', 'J\u00falio'] const filtroLetra = (lista) => lista.filter((x) => x[0] == 'J') console.log(filtroLetra(nomes)) A opera\u00e7\u00e3o acima filtra os nomes cuja inicial \u00e9 a letra 'J', ent\u00e3o retorna a lista abaixo: ['Jo\u00e3o','Jos\u00e9','J\u00falio'] Perceba que: * Assim como nas express\u00f5es de mapeamento, o x na express\u00e3o de filtragem representa os elementos a serem operados na lista. Assim, caso o valor l\u00f3gico do item corresponda ao valor declarado na express\u00e3o, o item \u00e9 incluso na nova lista. Caso contr\u00e1rio, o item \u00e9 ignorado. * Caso haja apenas um item na lista, ainda assim ser\u00e1 retornada uma nova lista com o item que satisfaz a condi\u00e7\u00e3o. * Caso nenhum item da lista a ser filtrada satisfa\u00e7a a condi\u00e7\u00e3o, ser\u00e1 retomada uma lista vazia ( [] ) Redu\u00e7\u00e3o As opera\u00e7\u00f5es de redu\u00e7\u00e3o s\u00e3o opera\u00e7\u00f5es que reduzem todos os elementos da lista a um \u00fanico valor baseado na fun\u00e7\u00e3o ou express\u00e3o utilizada. Tamb\u00e9m se faz uso de um acumulador , que aqui, soma e retoma o valor desejado ao realizar a opera\u00e7\u00e3o de redu\u00e7\u00e3o (como a soma de todos os itens ou a concatena\u00e7\u00e3o de strings) const listaString = ['The', 'Quick', 'Brown', 'Fox', 'Jumps', 'Over', 'The', 'Lazy', 'Dog'] const concat = (acc, x) => `${acc} ${x}` const reducaoConcat = (lista) => lista.reduce(concat,'') console.log(reducaoConcat(listaFrase)) A opera\u00e7\u00e3o acima concatena os itens da lista (todos de tipo string ) em apenas uma string com um espa\u00e7o entre cada item. Ela retorna 'The Quick Brown Fox Jumps Over The Lazy Dog' Perceba que: * O acc \"junta\" os itens de cada lista at\u00e9 formar a frase final. * O acc tamb\u00e9m \u00e9 operado e alterado diretamente pela opera\u00e7\u00e3o de redu\u00e7\u00e3o * Dentro da declara\u00e7\u00e3o da redu\u00e7\u00e3o, o que vem ap\u00f3s a v\u00edrgula (no exemplo acima, '' ) \u00e9 o valor inicial do acumulador. As tr\u00eas opera\u00e7\u00f5es conceituadas podem ser usadas em conjunto para fazer diversas opera\u00e7\u00f5es com listas, possibilitando a ampla manipula\u00e7\u00e3o desses valores. Registros Os registros s\u00e3o estruturas de cole\u00e7\u00e3o de dados que permitem o agrupamento de informa\u00e7\u00f5es de diversos tipos ou aspectos de um mesmo objeto. const livro = { nome: 'Quinze Dias', autor: 'Vitor Martins', ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira', 'Jovem-Adulto'] } O exemplo acima \u00e9 um registro de um livro. Os atributos da lista podem ser acessados da seguinte forma: //Ex.: nome console.log(livro.nome) console.log(livro.ISBN) Isso retorna 'Quinze Dias' 8525063150 \u00c9 poss\u00edvel criar listas de registros const livros = [ { nome: \"Quinze Dias\", autor: \"Vitor Martins\", ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira']}, { nome: 'O Vampiro que Descobriu o Brasil', autor: 'Ivan Jaf', ano: 1999, ISBN: 9788508111176, temas: ['Fic\u00e7\u00e3o','Hist\u00f3ria do Brasil', 'Literatura Brasileira']} ] Para acessar os itens dos registros, pode-se utilizar-se da seguinte sintaxe console.log(livros[1].nome) O comando acima retoma: 'O Vampiro que Descobriu o Brasil' Tamb\u00e9m \u00e9 poss\u00edvel, quando relevante, utilizar registros dentro de outros registros const pessoa = { nome: 'Fernando', idade: 24, medioConcluido: true, endereco: { rua: 'Etelvino de Souza', numero: 44, bairro: 'Jabotiana', cidade: 'Aracaju', estado: 'Sergipe' } } Para acessar as informa\u00e7\u00f5es de registros dentro de registros, utiliza-se console.log(pessoa.endereco.rua) O c\u00f3digo retorna 'Etelvino de Souza' Imutabilidade de Listas e Registros O paradigma funcional considera que todos os objetos s\u00e3o imut\u00e1veis (por isso a declara\u00e7\u00e3o com uso de const ), e por isso n\u00e3o podem ser modificados ap\u00f3s declarados... Exceto listas e registros. Listas e registros, mesmo com a declara\u00e7\u00e3o usando const , podem ter seus valores modificados, como no exemplo abaixo const lista1 = [1,4,3,10,6] const lista2 = lista1.sort((a,b) => a-b) console.log(lista2) console.log(lista1) Ao contr\u00e1rio do que se espera, ambas as listas foram operadas. [1,3,4,6,10] //Lista2 [1,3,4,6,10] //Lista1 Isso ocorre porque lista2 n\u00e3o \u00e9 uma nova lista, e sim um novo \"nome\" para a lista1 . Ent\u00e3o a lista pode ser chamada pelos dois \"nomes\" atribuidos a ela. Isso prova que, mesmo que a estrutura da lista em si seja imut\u00e1vel, o conte\u00fado pode ser modificado. Para evitar que isso aconte\u00e7a, \u00e9 poss\u00edvel fazer o seguinte: Fazer uma c\u00f3pia da lista utilizando par\u00e2metros Spread [...x] const lista1 = [1,4,3,10,6] const lista2 = [...lista1].sort((a,b) => a-b) console.log(lista2) console.log(lista1) Com o uso do par\u00e2metro Spread , uma nova lista \u00e9 criada e operada sem interfer\u00eancias na original. [1,3,4,6,10] //Lista2 [1,4,3,10,6] //Lista1 Utilizar o m\u00e9todo Object.freeze() O recurso Object.freeze() congela os itens das listas (e dos registros), retornando a lista n\u00e3o modificada, mesmo que se tenha associado outro nome e modificado ela. Isso garante o princ\u00edpio de imutabilidade para listas requerido pelo paradigma funcional. Para acessar a lista e criar uma nova lista com ela, utiliza-se o m\u00e9todo anterior para copi\u00e1-la. const lista1 = Object.freeze([1,4,3,10,6]) const lista2 = lista1.sort() //retorna um erro Uso de opera\u00e7\u00f5es de mapeamento, filtragem e redu\u00e7\u00e3o, etc const lista1 = [1,4,3,10,6] const lista2 = lista1.map((x) => x**2) console.log(lista2) console.log(lista1) As opera\u00e7\u00f5es com listas retomam sempre uma nova lista com os novos valores [1,16,9,100,36] //Lista2 [1,4,3,10,6] //Lista1 Outra opera\u00e7\u00e3o que cria uma nova lista \u00e9 o slice() , que cria uma nova lista a partir de uma sele\u00e7\u00e3o de um ponto inicial e um ponto final em qualquer \u00edndice da lista. const lista1 = ['Eu', 'amo', 'pizza','de','queijo'] const lista2 = lista1.slice(2,5) console.log(lista2) console.log(lista1) O exemplo acima retorna: [ 'pizza', 'de', 'queijo' ] [ 'Eu', 'amo', 'pizza', 'de', 'queijo' ] Registros No caso de registros, as op\u00e7\u00f5es de imutabilidade se assemelham com as listas. Aqui temos o Object.freeze() e o {...x} (Spread). Note que aqui, o par\u00e2metro Spread utiliza chaves, indicando que um registro est\u00e1 sendo copiado. const cachorro = Object.freeze({ nome: 'Luma', ra\u00e7a: 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }) const cachorro2 = {...cachorro} //Spread cachorro2.nome = 'Doki' cachorro2.peso = 8.1 console.log(cachorro2) console.log(cachorro) O c\u00f3digo retorna { nome: 'Doki', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'Amarelo', peso: 8.1 } { nome: 'Luma', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }","title":"Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#listas-e-registros","text":"","title":"Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#pf","text":"<- Voltar \u00c9 poss\u00edvel fazer cole\u00e7\u00f5es de dados em linguagens de programa\u00e7\u00e3o como o JavaScript. As cole\u00e7\u00f5es que utilizaremos aqui s\u00e3o as listas (arrays) e registros. Tamb\u00e9m ser\u00e3o vistas opera\u00e7\u00f5es as quais \u00e9 poss\u00edvel realizar com essas cole\u00e7\u00f5es de dados.","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#listas","text":"As listas s\u00e3o cole\u00e7\u00f5es ordenadas de dados. Esses dados podem ser de qualquer tipo, incluindo outras cole\u00e7\u00f5es de dados const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] A estrutura acima \u00e9 uma lista que cont\u00e9m diferentes strings . e cada item da lista pode ser acessado por meio de nomes[x] , sendo x o \u00edndice (sendo 0 o primeiro item) que representa cada item. const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael'] console.log(nomes[0]) O c\u00f3digo acima retorna: 'Jo\u00e3o' Pode existir listas dentro de listas, como no exemplo abaixo const multiplos = [[3,1],[6,3,1],[9,6,3,1],[12,9,6,3,1]]","title":"Listas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#operacoes-com-listas","text":"Podemos fazer 3 opera\u00e7\u00f5es com listas:","title":"Opera\u00e7\u00f5es com Listas"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#mapeamento","text":"Uma opera\u00e7\u00e3o de mapeamento cria uma nova lista com o mesmo n\u00famero de elementos. Esses elementos s\u00e3o modificados de acordo com uma fun\u00e7\u00e3o ou express\u00e3o definida const numeros = [2,3,5,8,10,12] const dobroLista = (lista) => lista.map((x) => x * 2) console.log(dobrolista(numeros)) O c\u00f3digo acima retorna [4,6,10,16,20,24] Para entender o c\u00f3digo anterior, \u00e9 necess\u00e1rio apontar algumas coisas: Na express\u00e3o lista.map((x) => x * 2) , x representa o elemento a ser operado na lista. Ou seja, para o caso do 2 (primeiro elemento da lista), a opera\u00e7\u00e3o realizada \u00e9 (2)= 2 * 2 , que retorna 4 A quantidade de elementos na lista N\u00c3O \u00e9 modificada S\u00e3o geradas novas listas contendo os novos valores do mapeamento.","title":"Mapeamento"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#filtragem","text":"As opera\u00e7\u00f5es de filtragem retomam uma nova lista com elementos cuja fun\u00e7\u00e3o ou express\u00e3o tenha condi\u00e7\u00e3o satisfeita. Logo, as express\u00f5es utilizadas na opera\u00e7\u00e3o s\u00e3o de valor Booleano (Verdadeiro ou Falso) const nomes = ['Jo\u00e3o','Maria','Jos\u00e9','Silvano','Raphael', 'J\u00falio'] const filtroLetra = (lista) => lista.filter((x) => x[0] == 'J') console.log(filtroLetra(nomes)) A opera\u00e7\u00e3o acima filtra os nomes cuja inicial \u00e9 a letra 'J', ent\u00e3o retorna a lista abaixo: ['Jo\u00e3o','Jos\u00e9','J\u00falio'] Perceba que: * Assim como nas express\u00f5es de mapeamento, o x na express\u00e3o de filtragem representa os elementos a serem operados na lista. Assim, caso o valor l\u00f3gico do item corresponda ao valor declarado na express\u00e3o, o item \u00e9 incluso na nova lista. Caso contr\u00e1rio, o item \u00e9 ignorado. * Caso haja apenas um item na lista, ainda assim ser\u00e1 retornada uma nova lista com o item que satisfaz a condi\u00e7\u00e3o. * Caso nenhum item da lista a ser filtrada satisfa\u00e7a a condi\u00e7\u00e3o, ser\u00e1 retomada uma lista vazia ( [] )","title":"Filtragem"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#reducao","text":"As opera\u00e7\u00f5es de redu\u00e7\u00e3o s\u00e3o opera\u00e7\u00f5es que reduzem todos os elementos da lista a um \u00fanico valor baseado na fun\u00e7\u00e3o ou express\u00e3o utilizada. Tamb\u00e9m se faz uso de um acumulador , que aqui, soma e retoma o valor desejado ao realizar a opera\u00e7\u00e3o de redu\u00e7\u00e3o (como a soma de todos os itens ou a concatena\u00e7\u00e3o de strings) const listaString = ['The', 'Quick', 'Brown', 'Fox', 'Jumps', 'Over', 'The', 'Lazy', 'Dog'] const concat = (acc, x) => `${acc} ${x}` const reducaoConcat = (lista) => lista.reduce(concat,'') console.log(reducaoConcat(listaFrase)) A opera\u00e7\u00e3o acima concatena os itens da lista (todos de tipo string ) em apenas uma string com um espa\u00e7o entre cada item. Ela retorna 'The Quick Brown Fox Jumps Over The Lazy Dog' Perceba que: * O acc \"junta\" os itens de cada lista at\u00e9 formar a frase final. * O acc tamb\u00e9m \u00e9 operado e alterado diretamente pela opera\u00e7\u00e3o de redu\u00e7\u00e3o * Dentro da declara\u00e7\u00e3o da redu\u00e7\u00e3o, o que vem ap\u00f3s a v\u00edrgula (no exemplo acima, '' ) \u00e9 o valor inicial do acumulador. As tr\u00eas opera\u00e7\u00f5es conceituadas podem ser usadas em conjunto para fazer diversas opera\u00e7\u00f5es com listas, possibilitando a ampla manipula\u00e7\u00e3o desses valores.","title":"Redu\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#registros","text":"Os registros s\u00e3o estruturas de cole\u00e7\u00e3o de dados que permitem o agrupamento de informa\u00e7\u00f5es de diversos tipos ou aspectos de um mesmo objeto. const livro = { nome: 'Quinze Dias', autor: 'Vitor Martins', ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira', 'Jovem-Adulto'] } O exemplo acima \u00e9 um registro de um livro. Os atributos da lista podem ser acessados da seguinte forma: //Ex.: nome console.log(livro.nome) console.log(livro.ISBN) Isso retorna 'Quinze Dias' 8525063150 \u00c9 poss\u00edvel criar listas de registros const livros = [ { nome: \"Quinze Dias\", autor: \"Vitor Martins\", ano: 2017, ISBN: 8525063150, temas: ['Romance', 'Literatura Brasileira']}, { nome: 'O Vampiro que Descobriu o Brasil', autor: 'Ivan Jaf', ano: 1999, ISBN: 9788508111176, temas: ['Fic\u00e7\u00e3o','Hist\u00f3ria do Brasil', 'Literatura Brasileira']} ] Para acessar os itens dos registros, pode-se utilizar-se da seguinte sintaxe console.log(livros[1].nome) O comando acima retoma: 'O Vampiro que Descobriu o Brasil' Tamb\u00e9m \u00e9 poss\u00edvel, quando relevante, utilizar registros dentro de outros registros const pessoa = { nome: 'Fernando', idade: 24, medioConcluido: true, endereco: { rua: 'Etelvino de Souza', numero: 44, bairro: 'Jabotiana', cidade: 'Aracaju', estado: 'Sergipe' } } Para acessar as informa\u00e7\u00f5es de registros dentro de registros, utiliza-se console.log(pessoa.endereco.rua) O c\u00f3digo retorna 'Etelvino de Souza'","title":"Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#imutabilidade-de-listas-e-registros","text":"O paradigma funcional considera que todos os objetos s\u00e3o imut\u00e1veis (por isso a declara\u00e7\u00e3o com uso de const ), e por isso n\u00e3o podem ser modificados ap\u00f3s declarados... Exceto listas e registros. Listas e registros, mesmo com a declara\u00e7\u00e3o usando const , podem ter seus valores modificados, como no exemplo abaixo const lista1 = [1,4,3,10,6] const lista2 = lista1.sort((a,b) => a-b) console.log(lista2) console.log(lista1) Ao contr\u00e1rio do que se espera, ambas as listas foram operadas. [1,3,4,6,10] //Lista2 [1,3,4,6,10] //Lista1 Isso ocorre porque lista2 n\u00e3o \u00e9 uma nova lista, e sim um novo \"nome\" para a lista1 . Ent\u00e3o a lista pode ser chamada pelos dois \"nomes\" atribuidos a ela. Isso prova que, mesmo que a estrutura da lista em si seja imut\u00e1vel, o conte\u00fado pode ser modificado. Para evitar que isso aconte\u00e7a, \u00e9 poss\u00edvel fazer o seguinte:","title":"Imutabilidade de Listas e Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#fazer-uma-copia-da-lista-utilizando-parametros-spread-x","text":"const lista1 = [1,4,3,10,6] const lista2 = [...lista1].sort((a,b) => a-b) console.log(lista2) console.log(lista1) Com o uso do par\u00e2metro Spread , uma nova lista \u00e9 criada e operada sem interfer\u00eancias na original. [1,3,4,6,10] //Lista2 [1,4,3,10,6] //Lista1","title":"Fazer uma c\u00f3pia da lista utilizando par\u00e2metros Spread [...x]"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#utilizar-o-metodo-objectfreeze","text":"O recurso Object.freeze() congela os itens das listas (e dos registros), retornando a lista n\u00e3o modificada, mesmo que se tenha associado outro nome e modificado ela. Isso garante o princ\u00edpio de imutabilidade para listas requerido pelo paradigma funcional. Para acessar a lista e criar uma nova lista com ela, utiliza-se o m\u00e9todo anterior para copi\u00e1-la. const lista1 = Object.freeze([1,4,3,10,6]) const lista2 = lista1.sort() //retorna um erro","title":"Utilizar o m\u00e9todo Object.freeze()"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#uso-de-operacoes-de-mapeamento-filtragem-e-reducao-etc","text":"const lista1 = [1,4,3,10,6] const lista2 = lista1.map((x) => x**2) console.log(lista2) console.log(lista1) As opera\u00e7\u00f5es com listas retomam sempre uma nova lista com os novos valores [1,16,9,100,36] //Lista2 [1,4,3,10,6] //Lista1 Outra opera\u00e7\u00e3o que cria uma nova lista \u00e9 o slice() , que cria uma nova lista a partir de uma sele\u00e7\u00e3o de um ponto inicial e um ponto final em qualquer \u00edndice da lista. const lista1 = ['Eu', 'amo', 'pizza','de','queijo'] const lista2 = lista1.slice(2,5) console.log(lista2) console.log(lista1) O exemplo acima retorna: [ 'pizza', 'de', 'queijo' ] [ 'Eu', 'amo', 'pizza', 'de', 'queijo' ]","title":"Uso de opera\u00e7\u00f5es de mapeamento, filtragem e redu\u00e7\u00e3o, etc"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/#registros_1","text":"No caso de registros, as op\u00e7\u00f5es de imutabilidade se assemelham com as listas. Aqui temos o Object.freeze() e o {...x} (Spread). Note que aqui, o par\u00e2metro Spread utiliza chaves, indicando que um registro est\u00e1 sendo copiado. const cachorro = Object.freeze({ nome: 'Luma', ra\u00e7a: 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }) const cachorro2 = {...cachorro} //Spread cachorro2.nome = 'Doki' cachorro2.peso = 8.1 console.log(cachorro2) console.log(cachorro) O c\u00f3digo retorna { nome: 'Doki', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'Amarelo', peso: 8.1 } { nome: 'Luma', 'ra\u00e7a': 'Poodle', idade: 6, cor: 'preto', peso: 7.2 }","title":"Registros"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/","text":"Recursividade PF Conceito Recursividade \u00e9 o ato de resolver um problema por meio da repeti\u00e7\u00e3o de uma mesma fun\u00e7\u00e3o, chamada de passo indutivo , invocada por ela mesma, at\u00e9 que se chegue ao chamado caso base O CASO BASE \u00e9 o valor inicial de uma sequ\u00eancia recursiva. Ele \u00e9 respons\u00e1vel por definir o fim da cadeia recursiva. J\u00e1 o PASSO INDUTIVO \u00e9 o passo necess\u00e1rio para transitar at\u00e9 o caso base, assim obtendo o resultado esperado. Ex.: Definindo uma sequ\u00eancia aritm\u00e9tica $ {3,5,7,9,11,13...}$, podemos obter qualquer valor dela por meio da fun\u00e7\u00e3o recursiva a seguir $f(0) = 3 $ $ f(n-1) + 2$ A primeira linha \u00e9 o Caso Base (que indica que $3$ \u00e9 o elemento inicial da sequ\u00eancia e que, se o \"contador\" chegar a 0, o valor ser\u00e1 $3$ ) e a segunda \u00e9 o passo indutivo (que indica que, enquanto $f(n)$ for diferente de zero, subtri-se o n em 1 e soma-se 2 ao resultado de $f(n-1)$ ). Assim, para chegar ao quarto elemento da sequ\u00eancia, seriam feitos a seguintes itera\u00e7\u00f5es: \"Ida\" at\u00e9 o caso base $f(3)$ = =$f(2) + 2$ =$f(1) + 2$ =$f(0)$ \u2192 3 \"Volta\" solucionando os passos indutivos recursivamente $f(1) + 2$ \u2192 $3 + 2 $ = 5 $f(2) + 2$ \u2192 $5 + 2$ = 7 $f(3) + 2$ \u2192 $7 + 2$ = 9 Logo, o quarto elemento da lista \u00e9 $9$ Outro exemplo de fun\u00e7\u00e3o recursiva \u00e9 a famosa Sequ\u00eancia de Fibbonacci , que pode ser representada da seguinte forma: $f(0) = 1$ (caso base 1) $f(1) = 1$ (caso base 2) $f(n-1) + f(n-2)$ (passo indutivo) Traduzindo em palavras, os casos base s\u00e3o os primeiros n\u00fameros da sequ\u00eancia $(1,1)$ e todos os outros derivam desses, nesse caso, o elemento $f(3)$ \u00e9 definido por $f(2) + f(1)$, ou melhor, $3 = 2+1$ Na programa\u00e7\u00e3o, utilizando JavaScript essa fun\u00e7\u00e3o pode ser representada por: const fib = (n) => { if (n == 0) return 1 else if (n == 1) return 1 else return fib(n - 1) + fib(n-2) } Note que a fun\u00e7\u00e3o \u00e9 chamada dentro dela mesma, e isso \u00e9 um dos aspectos que caracteriza uma fun\u00e7\u00e3o recursiva. Note tamb\u00e9m que, caso n\u00e3o existissem casos base, a fun\u00e7\u00e3o nunca terminaria de ser executada, resultando em uma \"stack overflow\" ou sobrecarga de pilha. Outro exemplo \u00e9 uma fun\u00e7\u00e3o de pot\u00eancia const potencia = (b,e) => { if (e == 0) {return 1} else return b*potencia(b,e-1) } Aqui, o caso base \u00e9 o caso de o expoente ser $0$ (o resultado \u00e9 $1$), e o passo indutivo \u00e9 que, caso o expoente seja diferente de 0, faz-se o produto da base com a fun\u00e7\u00e3o, at\u00e9 que se chegue no caso base. //fazer o de mdc e o de string Recursividade em lista At\u00e9 agora, vimos a recursividade com casos que n\u00e3o envolvem listas, mas essa funcionalidade \u00e9 extremamente \u00fatil para a manipula\u00e7\u00e3o de listas com o paradigma funcional. Para a recursividade em lista, \u00e9 necess\u00e1rio desestruturar * a lista em dois elementos: * Head (ou cabe\u00e7a): \u00e9 o elemento a ser operado na opera\u00e7\u00e3o recursiva atual. Geralmente, mas n\u00e3o para todos os casos, \u00e9 o primeiro elemento da lista * Tail (ou cauda): \u00e9 o resto da lista, em que as pr\u00f3ximas opera\u00e7\u00f5es recursivas ocorrer\u00e3o, com um dos elementos (novamente, geralmente o primeiro) da tail sendo a head da pr\u00f3xima itera\u00e7\u00e3o recursiva. *A desestrutura\u00e7\u00e3o de par\u00e2metros \u00e9 a separa\u00e7\u00e3o de certos par\u00e2metros de um objeto, uma lista ou algum outro tipo de dado: const lista = [1,2,3,5] const [x,...xs] = lista //desestrutura\u00e7\u00e3o da lista, consistindo nesse caso de pegar o primeiro elemento e associ\u00e1-lo \u00e0 constante x, e o resto da lista associado \u00e0 constante xs. Assim, x = 1 e xs = [2,3,5]. console.log(x) console.log(xs) Voltando \u00e0 recursividade, abaixo temos uma fun\u00e7\u00e3o que retorna a soma de todos os elementos da lista: const somaLista = ([x,...xs]) => { if (typeof x == 'undefined') return 0 else return x + somaLista(xs) } console.log(somaLista([3,4,12,15])) //retorna 34 A depender da fun\u00e7\u00e3o, \u00e9 poss\u00edvel ter duas cabe\u00e7as em uma mesma opera\u00e7\u00e3o recursiva, como no exemplo abaixo, que retorna o maior const maior = ([x,y,...xs]) => { if (typeof y == 'undefined') return x else if (x>y) return maior([x,...xs]) else return maior([y,...xs]) } console.log(`O maior n\u00famero da lista \u00e9 ${maior([3,4,12,15])}`) //retorna \"O maior n\u00famero da lista \u00e9 15\" *OBS: Como \u00e9 poss\u00edvel ver, utilizamos em praticamente todas as fun\u00e7\u00f5es de recursividade em lista a condi\u00e7\u00e3o typeof x == 'undefined' , pois, caso a lista esteja vazia, o tipo dela \u00e9 indefinido, ou 'undefined' . N\u00e3o \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es \u00fateis com isso. Para facilitar o trabalho, \u00e9 poss\u00edvel identificar se certo elemento da lista (a \"cabe\u00e7a\") est\u00e1 vazio, pois se estiver, a lista est\u00e1 vazia (ou no caso acima, resta apenas um elemento, que \u00e9 o que queremos). Assim, \u00e9 poss\u00edvel definir uma fun\u00e7\u00e3o de uso geral: const undef = (x) => typeof x == 'undefined' Essa fun\u00e7\u00e3o verifica se o tipo da constante selecionada \u00e9 undefined e retorna um valor do tipo bool true ou false caso seja ou n\u00e3o seja. A partir da recursividade, \u00e9 poss\u00edvel criar fun\u00e7\u00f5es j\u00e1 existentes, a fim de entender como elas funcionariam no paradigma funcional. Abaixo, temos a fun\u00e7\u00e3o map , implementada em JS: const lista1 = [2,3,8,10] const lista2 = lista1.map((x) => x**2) console.log(lista2) // retorna [4,9,64,100] Como explicado no documento de Listas e registros a fun\u00e7\u00e3o map retorna uma nova lista com os elementos modificados de acordo com a fun\u00e7\u00e3o definida na sua declara\u00e7\u00e3o. Podemos criar uma fun\u00e7\u00e3o map com recursividade, da seguinte forma: const meuMap = ([x,...xs], f) => { if (typeof x == 'undefined') return [] else return [f(x), ...meuMap(xs,f)] }","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#recursividade","text":"","title":"Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#pf","text":"","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#conceito","text":"Recursividade \u00e9 o ato de resolver um problema por meio da repeti\u00e7\u00e3o de uma mesma fun\u00e7\u00e3o, chamada de passo indutivo , invocada por ela mesma, at\u00e9 que se chegue ao chamado caso base O CASO BASE \u00e9 o valor inicial de uma sequ\u00eancia recursiva. Ele \u00e9 respons\u00e1vel por definir o fim da cadeia recursiva. J\u00e1 o PASSO INDUTIVO \u00e9 o passo necess\u00e1rio para transitar at\u00e9 o caso base, assim obtendo o resultado esperado. Ex.: Definindo uma sequ\u00eancia aritm\u00e9tica $ {3,5,7,9,11,13...}$, podemos obter qualquer valor dela por meio da fun\u00e7\u00e3o recursiva a seguir $f(0) = 3 $ $ f(n-1) + 2$ A primeira linha \u00e9 o Caso Base (que indica que $3$ \u00e9 o elemento inicial da sequ\u00eancia e que, se o \"contador\" chegar a 0, o valor ser\u00e1 $3$ ) e a segunda \u00e9 o passo indutivo (que indica que, enquanto $f(n)$ for diferente de zero, subtri-se o n em 1 e soma-se 2 ao resultado de $f(n-1)$ ). Assim, para chegar ao quarto elemento da sequ\u00eancia, seriam feitos a seguintes itera\u00e7\u00f5es: \"Ida\" at\u00e9 o caso base $f(3)$ = =$f(2) + 2$ =$f(1) + 2$ =$f(0)$ \u2192 3 \"Volta\" solucionando os passos indutivos recursivamente $f(1) + 2$ \u2192 $3 + 2 $ = 5 $f(2) + 2$ \u2192 $5 + 2$ = 7 $f(3) + 2$ \u2192 $7 + 2$ = 9 Logo, o quarto elemento da lista \u00e9 $9$ Outro exemplo de fun\u00e7\u00e3o recursiva \u00e9 a famosa Sequ\u00eancia de Fibbonacci , que pode ser representada da seguinte forma: $f(0) = 1$ (caso base 1) $f(1) = 1$ (caso base 2) $f(n-1) + f(n-2)$ (passo indutivo) Traduzindo em palavras, os casos base s\u00e3o os primeiros n\u00fameros da sequ\u00eancia $(1,1)$ e todos os outros derivam desses, nesse caso, o elemento $f(3)$ \u00e9 definido por $f(2) + f(1)$, ou melhor, $3 = 2+1$ Na programa\u00e7\u00e3o, utilizando JavaScript essa fun\u00e7\u00e3o pode ser representada por: const fib = (n) => { if (n == 0) return 1 else if (n == 1) return 1 else return fib(n - 1) + fib(n-2) } Note que a fun\u00e7\u00e3o \u00e9 chamada dentro dela mesma, e isso \u00e9 um dos aspectos que caracteriza uma fun\u00e7\u00e3o recursiva. Note tamb\u00e9m que, caso n\u00e3o existissem casos base, a fun\u00e7\u00e3o nunca terminaria de ser executada, resultando em uma \"stack overflow\" ou sobrecarga de pilha. Outro exemplo \u00e9 uma fun\u00e7\u00e3o de pot\u00eancia const potencia = (b,e) => { if (e == 0) {return 1} else return b*potencia(b,e-1) } Aqui, o caso base \u00e9 o caso de o expoente ser $0$ (o resultado \u00e9 $1$), e o passo indutivo \u00e9 que, caso o expoente seja diferente de 0, faz-se o produto da base com a fun\u00e7\u00e3o, at\u00e9 que se chegue no caso base. //fazer o de mdc e o de string","title":"Conceito"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/#recursividade-em-lista","text":"At\u00e9 agora, vimos a recursividade com casos que n\u00e3o envolvem listas, mas essa funcionalidade \u00e9 extremamente \u00fatil para a manipula\u00e7\u00e3o de listas com o paradigma funcional. Para a recursividade em lista, \u00e9 necess\u00e1rio desestruturar * a lista em dois elementos: * Head (ou cabe\u00e7a): \u00e9 o elemento a ser operado na opera\u00e7\u00e3o recursiva atual. Geralmente, mas n\u00e3o para todos os casos, \u00e9 o primeiro elemento da lista * Tail (ou cauda): \u00e9 o resto da lista, em que as pr\u00f3ximas opera\u00e7\u00f5es recursivas ocorrer\u00e3o, com um dos elementos (novamente, geralmente o primeiro) da tail sendo a head da pr\u00f3xima itera\u00e7\u00e3o recursiva. *A desestrutura\u00e7\u00e3o de par\u00e2metros \u00e9 a separa\u00e7\u00e3o de certos par\u00e2metros de um objeto, uma lista ou algum outro tipo de dado: const lista = [1,2,3,5] const [x,...xs] = lista //desestrutura\u00e7\u00e3o da lista, consistindo nesse caso de pegar o primeiro elemento e associ\u00e1-lo \u00e0 constante x, e o resto da lista associado \u00e0 constante xs. Assim, x = 1 e xs = [2,3,5]. console.log(x) console.log(xs) Voltando \u00e0 recursividade, abaixo temos uma fun\u00e7\u00e3o que retorna a soma de todos os elementos da lista: const somaLista = ([x,...xs]) => { if (typeof x == 'undefined') return 0 else return x + somaLista(xs) } console.log(somaLista([3,4,12,15])) //retorna 34 A depender da fun\u00e7\u00e3o, \u00e9 poss\u00edvel ter duas cabe\u00e7as em uma mesma opera\u00e7\u00e3o recursiva, como no exemplo abaixo, que retorna o maior const maior = ([x,y,...xs]) => { if (typeof y == 'undefined') return x else if (x>y) return maior([x,...xs]) else return maior([y,...xs]) } console.log(`O maior n\u00famero da lista \u00e9 ${maior([3,4,12,15])}`) //retorna \"O maior n\u00famero da lista \u00e9 15\" *OBS: Como \u00e9 poss\u00edvel ver, utilizamos em praticamente todas as fun\u00e7\u00f5es de recursividade em lista a condi\u00e7\u00e3o typeof x == 'undefined' , pois, caso a lista esteja vazia, o tipo dela \u00e9 indefinido, ou 'undefined' . N\u00e3o \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es \u00fateis com isso. Para facilitar o trabalho, \u00e9 poss\u00edvel identificar se certo elemento da lista (a \"cabe\u00e7a\") est\u00e1 vazio, pois se estiver, a lista est\u00e1 vazia (ou no caso acima, resta apenas um elemento, que \u00e9 o que queremos). Assim, \u00e9 poss\u00edvel definir uma fun\u00e7\u00e3o de uso geral: const undef = (x) => typeof x == 'undefined' Essa fun\u00e7\u00e3o verifica se o tipo da constante selecionada \u00e9 undefined e retorna um valor do tipo bool true ou false caso seja ou n\u00e3o seja. A partir da recursividade, \u00e9 poss\u00edvel criar fun\u00e7\u00f5es j\u00e1 existentes, a fim de entender como elas funcionariam no paradigma funcional. Abaixo, temos a fun\u00e7\u00e3o map , implementada em JS: const lista1 = [2,3,8,10] const lista2 = lista1.map((x) => x**2) console.log(lista2) // retorna [4,9,64,100] Como explicado no documento de Listas e registros a fun\u00e7\u00e3o map retorna uma nova lista com os elementos modificados de acordo com a fun\u00e7\u00e3o definida na sua declara\u00e7\u00e3o. Podemos criar uma fun\u00e7\u00e3o map com recursividade, da seguinte forma: const meuMap = ([x,...xs], f) => { if (typeof x == 'undefined') return [] else return [f(x), ...meuMap(xs,f)] }","title":"Recursividade em lista"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/Menu/","text":"PF T\u00edtulo Conceitos B\u00e1sicos Listas e Registros Recursividade","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Funcional/Menu/#pf","text":"T\u00edtulo Conceitos B\u00e1sicos Listas e Registros Recursividade","title":"PF"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/","text":"01 - Conceitos iniciais <- Voltar Programa e algoritmo Algoritmos s\u00e3o sequ\u00eancias de passos a serem executados. Esses passos s\u00e3o bem descritos, sem ambiguidades, e que podem ser executados de alguma forma. Por exemplo, para calcular a soma de dois n\u00fameros, voc\u00ea toma esses dois n\u00famero, processa-os de forma a som\u00e1-los, e retoma o resultado dessa soma. Um programa \u00e9 uma sequ\u00eancia de passos escrita em uma linguagem de computador para executar a\u00e7\u00f5es ou resolver problemas. Eles s\u00e3o essenciais para o funcionamento de um computador, afinal sem programas, a m\u00e1quina \u00e9 in\u00fatil. Seu Sistema Operacional(Windows,Linux, Mac OS ou BSD) s\u00e3o programas; seu aplicativo de calculadora \u00e9 um programa; o navegador pelo qual voc\u00ea provavelmente l\u00ea isso \u00e9 um programa. Para a cria\u00e7\u00e3o de programas, \u00e9 necess\u00e1ria alguma interface entre o programador e o computador. Monitores, terminais de computador, ou impressoras para ver os comandos digitados e os resultados; dispositivos para a entrada de dados (um teclado, por exemplo); e algo que seja poss\u00edvel escrever esses programas de forma que o computador entenda. \u00c9 a\u00ed que entram as linguagens de programa\u00e7\u00e3o. O computador s\u00f3 entende instru\u00e7\u00f5es em bin\u00e1rio, isto \u00e9, 0 e 1, sim ou n\u00e3o. \u00c9 com sequ\u00eancias de zeros e uns que os programas rodam no computador. Mas escrever em bin\u00e1rio (tamb\u00e9m chamado de linguagem de m\u00e1quina) \u00e9 trabalhoso e dif\u00edcil. Por isso, foram inventadas diferentes linguagens de programa\u00e7\u00e3o, como assembly, que, mesmo sendo mais f\u00e1cil que linguagem de m\u00e1quina, ainda \u00e9 complicado para padr\u00f5es atuais. Ent\u00e3o, ao longo do tempo, diferentes linguagens foram constru\u00eddas de forma a facilitar ainda mais a constru\u00e7\u00e3o e a cria\u00e7\u00e3o de programas, como COBOL, Fortran, Lisp, C, Java, entre outras. Aqui, daremos enfoque na linguagem C. Trin\u00f4mio Para o funcionamento do programa, \u00e9 necess\u00e1rio entender o objetivo desse programa, e assim entender: A entrada: Os dados inseridos para cumprir o objetivo O processamento: A manipula\u00e7\u00e3o dos dados para obter o resultado desejado A sa\u00edda: O resultado do algoritmo A linguagem C C foi criada nos Laborat\u00f3rios Bell (AT&T) por Denis Ritchie e Ken Thompson em 1970. \u00c9 uma linguagem de alto n\u00edvel, mesmo que considerada por alguns como de n\u00edvel m\u00e9dio devido ao acesso de mem\u00f3ria. \u00c9 compilada, estruturada e fortemente tipada. Ser uma linguagem compilada significa que o c\u00f3digo do programa \u00e9 convertido para linguagem de m\u00e1quina por inteiro. Isso \u00e9 diferente de linguagens interpretadas,como python, que l\u00ea o c\u00f3digo e o converte linha a linha. Termos C\u00f3digo fonte: \u00e9 o c\u00f3digo do programa. Um exemplo \u00e9 um c\u00f3digo em C C\u00f3digo objeto: O c\u00f3digo objeto \u00e9 o produto da compila\u00e7\u00e3o de um c\u00f3digo fonte, que agora \u00e9 transformado em linguagem de m\u00e1quina. Comp\u00f5e uma parte do execut\u00e1vel gerado pelo compilador do C Linkeditor: \u00c9 o respons\u00e1vel por requisitar e agregar todas as partes necess\u00e1rias para a execu\u00e7\u00e3o de um programa. \u00c9 o respons\u00e1vel por incluir as bibliotecas necess\u00e1rias para compilar o problema C\u00f3digo execut\u00e1vel: \u00c9 o produto final da compila\u00e7\u00e3o. \u00c9 esse o arquivo que o usu\u00e1rio tem acesso e pode executar a l\u00f3gica do programa. Biblioteca: \u00c9 um conjunto de instru\u00e7\u00f5es e fun\u00e7\u00f5es que podem ser utilizados em diferentes programas, para diferentes prop\u00f3sitos Tempo de compila\u00e7\u00e3o: \u00c9 o momento em que o c\u00f3digo fonte \u00e9 lido pelo compilador. Aqui, o compilador pode indicar erros que o impedem de ser transformado em c\u00f3digo objeto (a aus\u00eancia de um ;, por exemplo). Tempo de execu\u00e7\u00e3o (runtime): Aqui \u00e9 onde podem ser indicados erros ocorridos durante a execu\u00e7\u00e3o do programa, como uma exce\u00e7\u00e3o de ponto flutuante. Exemplo de programa em C #include <stdio.h> /*Biblioteca*/ int main(){ //fun\u00e7\u00e3o main printf(\"Hello world!\"); } O include <stdio.h> significa que a biblioteca stdio.h (standard Input/Output) \u00e9 requisitada para a execu\u00e7\u00e3o do programa. Essa biblioteca \u00e9 a principal biblioteca da linguagem, pois cont\u00e9m todas as fun\u00e7\u00f5es b\u00e1sicas. A fun\u00e7\u00e3o main() \u00e9 a principal fun\u00e7\u00e3o do C. Ela executa as fun\u00e7\u00f5es subsequentes necess\u00e1rias para executar o programa. Vari\u00e1veis Vari\u00e1veis s\u00e3o dados guardados de forma provis\u00f3ria na mem\u00f3ria RAM da m\u00e1quina. Cada um desses dados \u00e9 endere\u00e7ado. As vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria. Ex.: Um caractere ocupa 1 byte, enquanto um n\u00famero inteiro (int) ocupa 4 bytes. No caso da linguagem C, as regras de nomenclatura s\u00e3o: O primeiro caractere pode ser uma letra ou _(underline) Caracteres mai\u00fasculos e min\u00fasculos s\u00e3o diferentenciados (Case sensitive) As vari\u00e1veis n\u00e3o podem ser iguais a palavras reservadas da linguagem Os nomes das vari\u00e1veis n\u00e3o podem possuir espa\u00e7os em branco As vari\u00e1veis podem ser: * Locais (declaradas dentro de fun\u00e7\u00f5es) * Na defini\u00e7\u00e3o de par\u00e3metros de fun\u00e7\u00e3o * Fora de todas as fun\u00e7\u00f5es (vari\u00e1veis globais) * Tipos de dados Como indicado antes, as vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria a depender do tipo de dado armazenado nela. Os tipos de dados podem ser usados para determinar a quantidade de mem\u00f3ria ocupada e para determinar se \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es com outras vari\u00e1veis. (Ex.: uma vari\u00e1vel de tipo int n\u00e3o pode realizar opera\u00e7\u00f5es com uma vari\u00e1vel do tipo char) Tipo Representa Tamanho em bits Tamanho em bytes Int n\u00famero inteiro 16 ou 32 2 ou 4 float n\u00famero racional 32 4 double n\u00famero racional 64 8 long int n\u00famero inteiro 64 8 char valores alfanum\u00e9ricos 8 1 Coment\u00e1rios em C Os coment\u00e1rios em C s\u00e3o feitos com /* coment\u00e1rio */ Operadores aritm\u00e9ticos C, assim como diversas linguagens, possui diversos operadores aritm\u00e9ticos, l\u00f3gicos e relacionais. aritm\u00e9ticos L\u00f3gicos Relacionais + (adi\u00e7\u00e3o) && (AND) == (igual a) - (subtra\u00e7\u00e3o) || (OR) < (menor que) * (multiplica\u00e7\u00e3o) ! (NOT) > (menor que) / (divis\u00e3o) \u02c6(XOR) != (diferente de) <= (menor ou igual) >= (maior ou igual) M\u00e1scaras de formata\u00e7\u00e3o de E/S %d: Int %f: Float %c: Char %s: String Essas m\u00e1scaras s\u00e3o usadas para capturar ou exibir dados de vari\u00e1veis. Ex.: int numero = 3; printf(\"%d\", numero); Entrada e Sa\u00edda A entrada de dados se d\u00e1 da seguinte forma: int numero; scanf(\"%d\", &numero); O & \u00e9 o operador de endere\u00e7amento de valores na mem\u00f3ria. J\u00e1 a sa\u00edda se d\u00e1 da seguinte forma int numero = 3; printf(\"%d\", n\u00famero) (Programa) C\u00e1lculo de m\u00e9dia aritm\u00e9tica da nota de dois alunos #include <stdio.h> float nota1,nota2,media; void main(){ printf(\"Insira a primeira nota: \"); scanf(\"%f\", &nota1); printf(\"\\n Insira a segunda nota: \"); scanf(\"%f\",&nota2); media = (nota1 + nota2)/2; printf(\"\\n A m\u00e9dia das notas \u00e9 %f\",media); } PI (tag)","title":"01 - Conceitos iniciais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#01-conceitos-iniciais","text":"<- Voltar","title":"01 - Conceitos iniciais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#programa-e-algoritmo","text":"Algoritmos s\u00e3o sequ\u00eancias de passos a serem executados. Esses passos s\u00e3o bem descritos, sem ambiguidades, e que podem ser executados de alguma forma. Por exemplo, para calcular a soma de dois n\u00fameros, voc\u00ea toma esses dois n\u00famero, processa-os de forma a som\u00e1-los, e retoma o resultado dessa soma. Um programa \u00e9 uma sequ\u00eancia de passos escrita em uma linguagem de computador para executar a\u00e7\u00f5es ou resolver problemas. Eles s\u00e3o essenciais para o funcionamento de um computador, afinal sem programas, a m\u00e1quina \u00e9 in\u00fatil. Seu Sistema Operacional(Windows,Linux, Mac OS ou BSD) s\u00e3o programas; seu aplicativo de calculadora \u00e9 um programa; o navegador pelo qual voc\u00ea provavelmente l\u00ea isso \u00e9 um programa. Para a cria\u00e7\u00e3o de programas, \u00e9 necess\u00e1ria alguma interface entre o programador e o computador. Monitores, terminais de computador, ou impressoras para ver os comandos digitados e os resultados; dispositivos para a entrada de dados (um teclado, por exemplo); e algo que seja poss\u00edvel escrever esses programas de forma que o computador entenda. \u00c9 a\u00ed que entram as linguagens de programa\u00e7\u00e3o. O computador s\u00f3 entende instru\u00e7\u00f5es em bin\u00e1rio, isto \u00e9, 0 e 1, sim ou n\u00e3o. \u00c9 com sequ\u00eancias de zeros e uns que os programas rodam no computador. Mas escrever em bin\u00e1rio (tamb\u00e9m chamado de linguagem de m\u00e1quina) \u00e9 trabalhoso e dif\u00edcil. Por isso, foram inventadas diferentes linguagens de programa\u00e7\u00e3o, como assembly, que, mesmo sendo mais f\u00e1cil que linguagem de m\u00e1quina, ainda \u00e9 complicado para padr\u00f5es atuais. Ent\u00e3o, ao longo do tempo, diferentes linguagens foram constru\u00eddas de forma a facilitar ainda mais a constru\u00e7\u00e3o e a cria\u00e7\u00e3o de programas, como COBOL, Fortran, Lisp, C, Java, entre outras. Aqui, daremos enfoque na linguagem C.","title":"Programa e algoritmo"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#trinomio","text":"Para o funcionamento do programa, \u00e9 necess\u00e1rio entender o objetivo desse programa, e assim entender: A entrada: Os dados inseridos para cumprir o objetivo O processamento: A manipula\u00e7\u00e3o dos dados para obter o resultado desejado A sa\u00edda: O resultado do algoritmo","title":"Trin\u00f4mio"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#a-linguagem-c","text":"C foi criada nos Laborat\u00f3rios Bell (AT&T) por Denis Ritchie e Ken Thompson em 1970. \u00c9 uma linguagem de alto n\u00edvel, mesmo que considerada por alguns como de n\u00edvel m\u00e9dio devido ao acesso de mem\u00f3ria. \u00c9 compilada, estruturada e fortemente tipada. Ser uma linguagem compilada significa que o c\u00f3digo do programa \u00e9 convertido para linguagem de m\u00e1quina por inteiro. Isso \u00e9 diferente de linguagens interpretadas,como python, que l\u00ea o c\u00f3digo e o converte linha a linha.","title":"A linguagem C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#termos","text":"C\u00f3digo fonte: \u00e9 o c\u00f3digo do programa. Um exemplo \u00e9 um c\u00f3digo em C C\u00f3digo objeto: O c\u00f3digo objeto \u00e9 o produto da compila\u00e7\u00e3o de um c\u00f3digo fonte, que agora \u00e9 transformado em linguagem de m\u00e1quina. Comp\u00f5e uma parte do execut\u00e1vel gerado pelo compilador do C Linkeditor: \u00c9 o respons\u00e1vel por requisitar e agregar todas as partes necess\u00e1rias para a execu\u00e7\u00e3o de um programa. \u00c9 o respons\u00e1vel por incluir as bibliotecas necess\u00e1rias para compilar o problema C\u00f3digo execut\u00e1vel: \u00c9 o produto final da compila\u00e7\u00e3o. \u00c9 esse o arquivo que o usu\u00e1rio tem acesso e pode executar a l\u00f3gica do programa. Biblioteca: \u00c9 um conjunto de instru\u00e7\u00f5es e fun\u00e7\u00f5es que podem ser utilizados em diferentes programas, para diferentes prop\u00f3sitos Tempo de compila\u00e7\u00e3o: \u00c9 o momento em que o c\u00f3digo fonte \u00e9 lido pelo compilador. Aqui, o compilador pode indicar erros que o impedem de ser transformado em c\u00f3digo objeto (a aus\u00eancia de um ;, por exemplo). Tempo de execu\u00e7\u00e3o (runtime): Aqui \u00e9 onde podem ser indicados erros ocorridos durante a execu\u00e7\u00e3o do programa, como uma exce\u00e7\u00e3o de ponto flutuante.","title":"Termos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#exemplo-de-programa-em-c","text":"#include <stdio.h> /*Biblioteca*/ int main(){ //fun\u00e7\u00e3o main printf(\"Hello world!\"); } O include <stdio.h> significa que a biblioteca stdio.h (standard Input/Output) \u00e9 requisitada para a execu\u00e7\u00e3o do programa. Essa biblioteca \u00e9 a principal biblioteca da linguagem, pois cont\u00e9m todas as fun\u00e7\u00f5es b\u00e1sicas. A fun\u00e7\u00e3o main() \u00e9 a principal fun\u00e7\u00e3o do C. Ela executa as fun\u00e7\u00f5es subsequentes necess\u00e1rias para executar o programa.","title":"Exemplo de programa em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#variaveis","text":"Vari\u00e1veis s\u00e3o dados guardados de forma provis\u00f3ria na mem\u00f3ria RAM da m\u00e1quina. Cada um desses dados \u00e9 endere\u00e7ado. As vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria. Ex.: Um caractere ocupa 1 byte, enquanto um n\u00famero inteiro (int) ocupa 4 bytes. No caso da linguagem C, as regras de nomenclatura s\u00e3o: O primeiro caractere pode ser uma letra ou _(underline) Caracteres mai\u00fasculos e min\u00fasculos s\u00e3o diferentenciados (Case sensitive) As vari\u00e1veis n\u00e3o podem ser iguais a palavras reservadas da linguagem Os nomes das vari\u00e1veis n\u00e3o podem possuir espa\u00e7os em branco As vari\u00e1veis podem ser: * Locais (declaradas dentro de fun\u00e7\u00f5es) * Na defini\u00e7\u00e3o de par\u00e3metros de fun\u00e7\u00e3o * Fora de todas as fun\u00e7\u00f5es (vari\u00e1veis globais) *","title":"Vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#tipos-de-dados","text":"Como indicado antes, as vari\u00e1veis podem ocupar diferentes quantidades de mem\u00f3ria a depender do tipo de dado armazenado nela. Os tipos de dados podem ser usados para determinar a quantidade de mem\u00f3ria ocupada e para determinar se \u00e9 poss\u00edvel realizar opera\u00e7\u00f5es com outras vari\u00e1veis. (Ex.: uma vari\u00e1vel de tipo int n\u00e3o pode realizar opera\u00e7\u00f5es com uma vari\u00e1vel do tipo char) Tipo Representa Tamanho em bits Tamanho em bytes Int n\u00famero inteiro 16 ou 32 2 ou 4 float n\u00famero racional 32 4 double n\u00famero racional 64 8 long int n\u00famero inteiro 64 8 char valores alfanum\u00e9ricos 8 1","title":"Tipos de dados"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#comentarios-em-c","text":"Os coment\u00e1rios em C s\u00e3o feitos com /* coment\u00e1rio */","title":"Coment\u00e1rios em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#operadores-aritmeticos","text":"C, assim como diversas linguagens, possui diversos operadores aritm\u00e9ticos, l\u00f3gicos e relacionais. aritm\u00e9ticos L\u00f3gicos Relacionais + (adi\u00e7\u00e3o) && (AND) == (igual a) - (subtra\u00e7\u00e3o) || (OR) < (menor que) * (multiplica\u00e7\u00e3o) ! (NOT) > (menor que) / (divis\u00e3o) \u02c6(XOR) != (diferente de) <= (menor ou igual) >= (maior ou igual)","title":"Operadores aritm\u00e9ticos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#mascaras-de-formatacao-de-es","text":"%d: Int %f: Float %c: Char %s: String Essas m\u00e1scaras s\u00e3o usadas para capturar ou exibir dados de vari\u00e1veis. Ex.: int numero = 3; printf(\"%d\", numero);","title":"M\u00e1scaras de formata\u00e7\u00e3o de E/S"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#entrada-e-saida","text":"A entrada de dados se d\u00e1 da seguinte forma: int numero; scanf(\"%d\", &numero); O & \u00e9 o operador de endere\u00e7amento de valores na mem\u00f3ria. J\u00e1 a sa\u00edda se d\u00e1 da seguinte forma int numero = 3; printf(\"%d\", n\u00famero)","title":"Entrada e Sa\u00edda"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#programa-calculo-de-media-aritmetica-da-nota-de-dois-alunos","text":"#include <stdio.h> float nota1,nota2,media; void main(){ printf(\"Insira a primeira nota: \"); scanf(\"%f\", &nota1); printf(\"\\n Insira a segunda nota: \"); scanf(\"%f\",&nota2); media = (nota1 + nota2)/2; printf(\"\\n A m\u00e9dia das notas \u00e9 %f\",media); }","title":"(Programa) C\u00e1lculo de m\u00e9dia aritm\u00e9tica da nota de dois alunos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/#pi-tag","text":"","title":"PI (tag)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/","text":"02 - Operadores relacionais e condicionais <- Voltar Operadores relacionais A linguagem C possui operadores chamados, operadores relacionais, que servem para comparar dados (vari\u00e1veis, inteiros, strings, etc.). Alguns operadores relacionais s\u00e3o: < (Menor que) > (Maior que) <= (Menor ou igual) >= (Maior ou igual) == (igual) != (diferente de) Baseado nisso, podemos realizar opera\u00e7\u00f5es de compara\u00e7\u00e3o em chamadas estruturas de decis\u00e3o . Estruturas de decis\u00e3o simples As estruturas de decis\u00e3o simples interrompem o fluxo de tempo de execu\u00e7\u00e3o do programa a depender dos valores passados. Elas s\u00e3o representadas pelas palavras if ... if (\"condi\u00e7\u00e3o\"){ print(\"condi\u00e7\u00e3o satisfeita\"); } ... No c\u00f3digo acima, a palavra \"condi\u00e7\u00e3o\" pode ser substituida por alguma compara\u00e7\u00e3o, e caso satisfeita, ela executar\u00e1 o c\u00f3digo determinado, nesse caso print(\"Condi\u00e7\u00e3o satisfeita\"); . Veja o exemplo abaixo int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois n\u00fameros \u00e9 %i\",z); } O c\u00f3digo acima recebe dois n\u00fameros digitados pelo usu\u00e1rio, e os soma. Caso a soma desses n\u00fameros seja superior a 10, ele exibe o resultado. Estruturas de decis\u00e3o compostas Em compara\u00e7\u00e3o com as estruturas de decis\u00e3o simples, aqui, possu\u00edmos a condicional else int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois numeros e %i\",z); } else{ printf(\"numero menor que 10 :(\\n\"); } Diferente da primeira vez que vimos este bloco de c\u00f3digo, com o uso do else , podemos definir uma a\u00e7\u00e3o para o caso de a condi\u00e7\u00e3o n\u00e3o ser satisfeita. Nesse caso, caso a entrada n\u00e3o corresponda \u00e0 condi\u00e7\u00e3o definida (se a soma dos dois n\u00fameros n\u00e3o for maior que 10), o programa retorna que o n\u00famero \u00e9 menor que 10. \u00c9 poss\u00edvel aninhar condicionais e estabelecer diferentes condi\u00e7\u00f5es a serem verificadas int x; printf(\"\\nNumero maior, menor ou igual a 20\"); printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if(x == 20){ printf(\"\\nIgual a 20.\\n\"); } else if(x> 20){ printf(\"\\nMaior que 20\\n\"); } else if(x< 20){ printf(\"\\nMenor que 20\\n\"); } No caso acima, 3 condi\u00e7\u00f5es podem ser possivelmente satisfeitas (o n\u00famero ser igual a 20, maior que 20 ou menor que 20) int x; printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if (x<20){ if(x<30){ printf(\"numero maior que 30\"); } else{ printf(\"numero maior que 20, mas menor que 30\"); } } else{ printf(\"numero menor que ou igual a 20\"); } Agora, ele testa a primeira condi\u00e7\u00e3o (numero maior que 20), e se satisfeita, testa a segunda (numero maior que 30). Caso a segunda n\u00e3o seja satisfeita, ele retorna que o n\u00famero \u00e9 maior que 20, e caso nenhuma delas seja satisfeita, ele retorna que o n\u00famero \u00e9 menor que 20. O switch case Al\u00e9m das estruturas de decis\u00e3o if e else , existe a estrutura de decis\u00e3o m\u00faltipla switch : switch(vari\u00e1vel){ case constante1: comando; break; case constante2: comando; break; default: comando; } A palavra switch \u00e9 acompanhada de uma vari\u00e1vel discreta (char ou int e derivados), a qual a condi\u00e7\u00e3o ser\u00e1 testada. O uso da palavra case determina os casos a serem testados, isto \u00e9, os casos em que o valor da vari\u00e1vel corresponde ao valor desejado. A palavra default representa o conjunto de a\u00e7\u00f5es que ser\u00e1 executado caso nenhuma das condi\u00e7\u00f5es testadas seja satisfeita. Seu uso \u00e9 opcional. OBS\u00b9: Para executar apenas o primeiro case correspondente a um valor, \u00e9 necess\u00e1rio utilizar a palavra reservada break OBS\u00b2: O switch n\u00e3o aceita strings ou floats. Para testar condi\u00e7\u00f5es com vari\u00e1veis desses tipos, \u00e9 necess\u00e1rio utilizar \u00ecf e else . PI","title":"02 - Operadores relacionais e condicionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#02-operadores-relacionais-e-condicionais","text":"<- Voltar","title":"02 - Operadores relacionais e condicionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#operadores-relacionais","text":"A linguagem C possui operadores chamados, operadores relacionais, que servem para comparar dados (vari\u00e1veis, inteiros, strings, etc.). Alguns operadores relacionais s\u00e3o: < (Menor que) > (Maior que) <= (Menor ou igual) >= (Maior ou igual) == (igual) != (diferente de) Baseado nisso, podemos realizar opera\u00e7\u00f5es de compara\u00e7\u00e3o em chamadas estruturas de decis\u00e3o .","title":"Operadores relacionais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#estruturas-de-decisao-simples","text":"As estruturas de decis\u00e3o simples interrompem o fluxo de tempo de execu\u00e7\u00e3o do programa a depender dos valores passados. Elas s\u00e3o representadas pelas palavras if ... if (\"condi\u00e7\u00e3o\"){ print(\"condi\u00e7\u00e3o satisfeita\"); } ... No c\u00f3digo acima, a palavra \"condi\u00e7\u00e3o\" pode ser substituida por alguma compara\u00e7\u00e3o, e caso satisfeita, ela executar\u00e1 o c\u00f3digo determinado, nesse caso print(\"Condi\u00e7\u00e3o satisfeita\"); . Veja o exemplo abaixo int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois n\u00fameros \u00e9 %i\",z); } O c\u00f3digo acima recebe dois n\u00fameros digitados pelo usu\u00e1rio, e os soma. Caso a soma desses n\u00fameros seja superior a 10, ele exibe o resultado.","title":"Estruturas de decis\u00e3o simples"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#estruturas-de-decisao-compostas","text":"Em compara\u00e7\u00e3o com as estruturas de decis\u00e3o simples, aqui, possu\u00edmos a condicional else int x, y, z; printf(\"Bem vindo\"); printf(\"\\nInsira o primeiro valor:\"); scanf(\"%i\", &x); printf(\"\\nInsira o segundo valor:\"); scanf(\"%i\", &y); z = x+y; if(z > 10){ printf(\"A soma dos dois numeros e %i\",z); } else{ printf(\"numero menor que 10 :(\\n\"); } Diferente da primeira vez que vimos este bloco de c\u00f3digo, com o uso do else , podemos definir uma a\u00e7\u00e3o para o caso de a condi\u00e7\u00e3o n\u00e3o ser satisfeita. Nesse caso, caso a entrada n\u00e3o corresponda \u00e0 condi\u00e7\u00e3o definida (se a soma dos dois n\u00fameros n\u00e3o for maior que 10), o programa retorna que o n\u00famero \u00e9 menor que 10. \u00c9 poss\u00edvel aninhar condicionais e estabelecer diferentes condi\u00e7\u00f5es a serem verificadas int x; printf(\"\\nNumero maior, menor ou igual a 20\"); printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if(x == 20){ printf(\"\\nIgual a 20.\\n\"); } else if(x> 20){ printf(\"\\nMaior que 20\\n\"); } else if(x< 20){ printf(\"\\nMenor que 20\\n\"); } No caso acima, 3 condi\u00e7\u00f5es podem ser possivelmente satisfeitas (o n\u00famero ser igual a 20, maior que 20 ou menor que 20) int x; printf(\"\\nInsira um numero: \"); scanf(\"%d\", &x); if (x<20){ if(x<30){ printf(\"numero maior que 30\"); } else{ printf(\"numero maior que 20, mas menor que 30\"); } } else{ printf(\"numero menor que ou igual a 20\"); } Agora, ele testa a primeira condi\u00e7\u00e3o (numero maior que 20), e se satisfeita, testa a segunda (numero maior que 30). Caso a segunda n\u00e3o seja satisfeita, ele retorna que o n\u00famero \u00e9 maior que 20, e caso nenhuma delas seja satisfeita, ele retorna que o n\u00famero \u00e9 menor que 20.","title":"Estruturas de decis\u00e3o compostas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#o-switch-case","text":"Al\u00e9m das estruturas de decis\u00e3o if e else , existe a estrutura de decis\u00e3o m\u00faltipla switch : switch(vari\u00e1vel){ case constante1: comando; break; case constante2: comando; break; default: comando; } A palavra switch \u00e9 acompanhada de uma vari\u00e1vel discreta (char ou int e derivados), a qual a condi\u00e7\u00e3o ser\u00e1 testada. O uso da palavra case determina os casos a serem testados, isto \u00e9, os casos em que o valor da vari\u00e1vel corresponde ao valor desejado. A palavra default representa o conjunto de a\u00e7\u00f5es que ser\u00e1 executado caso nenhuma das condi\u00e7\u00f5es testadas seja satisfeita. Seu uso \u00e9 opcional. OBS\u00b9: Para executar apenas o primeiro case correspondente a um valor, \u00e9 necess\u00e1rio utilizar a palavra reservada break OBS\u00b2: O switch n\u00e3o aceita strings ou floats. Para testar condi\u00e7\u00f5es com vari\u00e1veis desses tipos, \u00e9 necess\u00e1rio utilizar \u00ecf e else .","title":"O switch case"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/","text":"03 - Strings <- Voltar O que s\u00e3o strings? Strings s\u00e3o cadeias de caracteres utilizadas para a entrada e sa\u00edda de texto no programa. Um exemplo de string \u00e9 \"Eu amo macarr\u00e3o com queijo\" . Note que a frase est\u00e1 entre aspas, pois strings sempre s\u00e3o passadas com aspas duplas. Algumas linguagens, como Python, suportam a passagem de strings com aspas simples, mas no C, n\u00e3o. Strings em C Na linguagem C, o tipo string n\u00e3o \u00e9 definido. Para contornar isso, \u00e9 poss\u00edvel declarar uma \"string\" como uma cadeia de caracteres, isto \u00e9, uma matriz unidimensional de caracteres. Ao declarar uma cadeia de caracteres dessa forma, \u00e9 necess\u00e1rio ter em mente que o \u00faltimo caractere da cadeia \u00e9 o \\0 , que indica a termina\u00e7\u00e3o da string. char nome[30]; //note que a matriz unidimensional recebe o tamanho m\u00e1ximo da string, nesse caso, 30 caracteres. Como o \\0 ocupa a \u00faltima posi\u00e7\u00e3o, o tamanho m\u00e1ximo da string neste caso \u00e9 29 caracteres. scanf e biblioteca Observe o c\u00f3digo abaixo: char nome[30]; scanf(\"%s\", &nome); printf(\"Nome: %s\", nome); //Utiliza-se a m\u00e1scara %s para capturar strings Neste excerto de c\u00f3digo, o uso de scanf n\u00e3o gera erros. O problema \u00e9 que o scanf vai capturar o texto digitado apenas at\u00e9 o primeiro espa\u00e7o. Ent\u00e3o caso seja digitado Pedro Luiz da Costa , o scanf armazenar\u00e1 apenas \"Pedro\" . Para contornar essa limita\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar uma fun\u00e7\u00e3o da biblioteca , que adiciona fun\u00e7\u00f5es para o tratamento de strings, como a compara\u00e7\u00e3o do conte\u00fado de strings ( strcmp() ), o comprimento ( strlen() ), a c\u00f3pia do conte\u00fado de uma string para outra ( strcpy() ), etc. Para capturar o texto completo da string, \u00e9 poss\u00edvel utilizar gets e fgets . Aqui, utilizaremos gets , mas fgets \u00e9 mais seguro. #include <string,h> char nome[30]; gets(nome); //fgets(nome, 30, stdin); A sintaxe para utilizar o fgets. O 30 \u00e9 o tamanho m\u00e1ximo a ser capturado printf(\"\\nNome: %s\", nome); OBS: Para utilizar acentua\u00e7\u00e3o em C, \u00e9 necess\u00e1rio incluir a biblioteca <locale.h> e chamar a fun\u00e7\u00e3o setlocale(LC_ALL,\"Portuguese\") . PI","title":"03 - Strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#03-strings","text":"<- Voltar","title":"03 - Strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#o-que-sao-strings","text":"Strings s\u00e3o cadeias de caracteres utilizadas para a entrada e sa\u00edda de texto no programa. Um exemplo de string \u00e9 \"Eu amo macarr\u00e3o com queijo\" . Note que a frase est\u00e1 entre aspas, pois strings sempre s\u00e3o passadas com aspas duplas. Algumas linguagens, como Python, suportam a passagem de strings com aspas simples, mas no C, n\u00e3o.","title":"O que s\u00e3o strings?"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#strings-em-c","text":"Na linguagem C, o tipo string n\u00e3o \u00e9 definido. Para contornar isso, \u00e9 poss\u00edvel declarar uma \"string\" como uma cadeia de caracteres, isto \u00e9, uma matriz unidimensional de caracteres. Ao declarar uma cadeia de caracteres dessa forma, \u00e9 necess\u00e1rio ter em mente que o \u00faltimo caractere da cadeia \u00e9 o \\0 , que indica a termina\u00e7\u00e3o da string. char nome[30]; //note que a matriz unidimensional recebe o tamanho m\u00e1ximo da string, nesse caso, 30 caracteres. Como o \\0 ocupa a \u00faltima posi\u00e7\u00e3o, o tamanho m\u00e1ximo da string neste caso \u00e9 29 caracteres.","title":"Strings em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#scanf-e-biblioteca","text":"Observe o c\u00f3digo abaixo: char nome[30]; scanf(\"%s\", &nome); printf(\"Nome: %s\", nome); //Utiliza-se a m\u00e1scara %s para capturar strings Neste excerto de c\u00f3digo, o uso de scanf n\u00e3o gera erros. O problema \u00e9 que o scanf vai capturar o texto digitado apenas at\u00e9 o primeiro espa\u00e7o. Ent\u00e3o caso seja digitado Pedro Luiz da Costa , o scanf armazenar\u00e1 apenas \"Pedro\" . Para contornar essa limita\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar uma fun\u00e7\u00e3o da biblioteca , que adiciona fun\u00e7\u00f5es para o tratamento de strings, como a compara\u00e7\u00e3o do conte\u00fado de strings ( strcmp() ), o comprimento ( strlen() ), a c\u00f3pia do conte\u00fado de uma string para outra ( strcpy() ), etc. Para capturar o texto completo da string, \u00e9 poss\u00edvel utilizar gets e fgets . Aqui, utilizaremos gets , mas fgets \u00e9 mais seguro. #include <string,h> char nome[30]; gets(nome); //fgets(nome, 30, stdin); A sintaxe para utilizar o fgets. O 30 \u00e9 o tamanho m\u00e1ximo a ser capturado printf(\"\\nNome: %s\", nome); OBS: Para utilizar acentua\u00e7\u00e3o em C, \u00e9 necess\u00e1rio incluir a biblioteca <locale.h> e chamar a fun\u00e7\u00e3o setlocale(LC_ALL,\"Portuguese\") .","title":"scanf e biblioteca"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/","text":"04 - Estrutura de Repeti\u00e7\u00e3o <- Voltar Loops Loops (ou repeti\u00e7\u00f5es) s\u00e3o estruturas que, dada uma uma condi\u00e7\u00e3o, ele testa uma condi\u00e7\u00e3o, e enquanto ela for verdadeira, um determinado bloco de c\u00f3digo ser\u00e1 repetido. while O while \u00e9 uma estrutura que testa uma condi\u00e7\u00e3o ao in\u00edcio da execu\u00e7\u00e3o de um bloco de c\u00f3digo, e se ela for verdadeira, ele ser\u00e1 executado. Ao fim de cada execu\u00e7\u00e3o, essa condi\u00e7\u00e3o ser\u00e1 testada. Se, em determinada execu\u00e7\u00e3o, esta condi\u00e7\u00e3o n\u00e3o for satisfeita, o bloco de c\u00f3digo deixa de ser executado. int x = 1; while (x < 10){ printf(\"%d\",x); x++; } O c\u00f3digo acima executa a impress\u00e3o do n\u00famero da vari\u00e1vel x, e acresce 1 a essa vari\u00e1vel, enquanto x \u00e9 menor que 10. Similar ao conceito de recursividade, aqui, temos um caso base (x menor que 10) e um passo indutivo (x++), al\u00e9m dos comandos envolvidos. do-while Diferente do while , o do while testa a condi\u00e7\u00e3o desejada ao fim do loop: int x = 1; do{ printf(\"%d\",x); x++; }while (x < 10) No exemplo acima, o c\u00f3digo ser\u00e1 executado uma vez independente da condi\u00e7\u00e3o ser satisfeita. Ap\u00f3s essa vez, ele testa a condi\u00e7\u00e3o, e, enquanto for verdadeura, ele a continua executando. Quando ela for falsa, o c\u00f3digo deixa de ser executado. for O for funciona como um contador. Para cada execu\u00e7\u00e3o do c\u00f3digo dentro do seu escopo, a vari\u00e1vel utilizada como contador ser\u00e1 incrementada ou decrementada. A sintaxe do for funciona da seguinte forma: for(contador;teste; modifica\u00e7\u00e3o no contador){ comando; } Aqui, o contador \u00e9 uma vari\u00e1vel, o teste \u00e9 a condif\u00e7\u00e3o que ser\u00e1 verificada para que o c\u00f3digo continue sendo executado, e a modifica\u00e7\u00e3o no contador \u00e9 a opera\u00e7\u00e3o realizada no contador a cada vez que o c\u00f3digo \u00e9 executado. Agora, um exemplo pr\u00e1tico: int contador = 0; for(contador;contador< 10; contador++){ printf(\"\\nO contador esta no numero %d\", contador); } printf(\"\\nO contador parou de crescer em %d\",contador); PI","title":"04 - Estrutura de Repeti\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#04-estrutura-de-repeticao","text":"<- Voltar","title":"04 - Estrutura de Repeti\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#loops","text":"Loops (ou repeti\u00e7\u00f5es) s\u00e3o estruturas que, dada uma uma condi\u00e7\u00e3o, ele testa uma condi\u00e7\u00e3o, e enquanto ela for verdadeira, um determinado bloco de c\u00f3digo ser\u00e1 repetido.","title":"Loops"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#while","text":"O while \u00e9 uma estrutura que testa uma condi\u00e7\u00e3o ao in\u00edcio da execu\u00e7\u00e3o de um bloco de c\u00f3digo, e se ela for verdadeira, ele ser\u00e1 executado. Ao fim de cada execu\u00e7\u00e3o, essa condi\u00e7\u00e3o ser\u00e1 testada. Se, em determinada execu\u00e7\u00e3o, esta condi\u00e7\u00e3o n\u00e3o for satisfeita, o bloco de c\u00f3digo deixa de ser executado. int x = 1; while (x < 10){ printf(\"%d\",x); x++; } O c\u00f3digo acima executa a impress\u00e3o do n\u00famero da vari\u00e1vel x, e acresce 1 a essa vari\u00e1vel, enquanto x \u00e9 menor que 10. Similar ao conceito de recursividade, aqui, temos um caso base (x menor que 10) e um passo indutivo (x++), al\u00e9m dos comandos envolvidos.","title":"while"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#do-while","text":"Diferente do while , o do while testa a condi\u00e7\u00e3o desejada ao fim do loop: int x = 1; do{ printf(\"%d\",x); x++; }while (x < 10) No exemplo acima, o c\u00f3digo ser\u00e1 executado uma vez independente da condi\u00e7\u00e3o ser satisfeita. Ap\u00f3s essa vez, ele testa a condi\u00e7\u00e3o, e, enquanto for verdadeura, ele a continua executando. Quando ela for falsa, o c\u00f3digo deixa de ser executado.","title":"do-while"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#for","text":"O for funciona como um contador. Para cada execu\u00e7\u00e3o do c\u00f3digo dentro do seu escopo, a vari\u00e1vel utilizada como contador ser\u00e1 incrementada ou decrementada. A sintaxe do for funciona da seguinte forma: for(contador;teste; modifica\u00e7\u00e3o no contador){ comando; } Aqui, o contador \u00e9 uma vari\u00e1vel, o teste \u00e9 a condif\u00e7\u00e3o que ser\u00e1 verificada para que o c\u00f3digo continue sendo executado, e a modifica\u00e7\u00e3o no contador \u00e9 a opera\u00e7\u00e3o realizada no contador a cada vez que o c\u00f3digo \u00e9 executado. Agora, um exemplo pr\u00e1tico: int contador = 0; for(contador;contador< 10; contador++){ printf(\"\\nO contador esta no numero %d\", contador); } printf(\"\\nO contador parou de crescer em %d\",contador);","title":"for"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/","text":"05 - Vetores(Arrays) <- Voltar Vetores e Matrizes Vetores e Matrizes s\u00e3o conjuntos de dados homog\u00eaneos (de um mesmo tipo). Esses dados terminar Vetor de strings Como em C, o tipo string n\u00e3o \u00e9 definido, um vetor de strings \u00e9 um vetor bidimensional. Isso significa que ele funciona como uma matriz (sintaxe abaixo). Com isso, ele tamb\u00e9m possui algumas limita\u00e7\u00f5es, como a seguinte: * O n\u00famero de caracteres em cada string tem que ser igual para todos os itens da lista O exemplo abaixo demonstra o uso de strings //N\u00famero de strings armazenadas na lista // v v tamanho das strings char listaNomes[6][10]; // listaNomes[0] = 'Luiz'; //<--- Sintaxe para atribuir uma string a um lugar na lista (neste caso, no \u00edndice 0) printf(\"%s\",listanomes[0]); //<-- Imprime o nome naquele \u00edndice PI","title":"05 - Vetores(Arrays)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#05-vetoresarrays","text":"<- Voltar","title":"05 - Vetores(Arrays)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#vetores-e-matrizes","text":"Vetores e Matrizes s\u00e3o conjuntos de dados homog\u00eaneos (de um mesmo tipo). Esses dados terminar","title":"Vetores e Matrizes"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#vetor-de-strings","text":"Como em C, o tipo string n\u00e3o \u00e9 definido, um vetor de strings \u00e9 um vetor bidimensional. Isso significa que ele funciona como uma matriz (sintaxe abaixo). Com isso, ele tamb\u00e9m possui algumas limita\u00e7\u00f5es, como a seguinte: * O n\u00famero de caracteres em cada string tem que ser igual para todos os itens da lista O exemplo abaixo demonstra o uso de strings //N\u00famero de strings armazenadas na lista // v v tamanho das strings char listaNomes[6][10]; // listaNomes[0] = 'Luiz'; //<--- Sintaxe para atribuir uma string a um lugar na lista (neste caso, no \u00edndice 0) printf(\"%s\",listanomes[0]); //<-- Imprime o nome naquele \u00edndice","title":"Vetor de strings"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/","text":"06 - Matrizes com mais de uma dimens\u00e3o <- Voltar Matrizes em C podem ser declaradas com qualquer quantidade de dimens\u00f5es int matriz1[3][3]; //Matriz bidimensional int matriz2[4][2][5]; //Matriz tridimensional int matriz3[5][12][20][24][15]; //Matriz de dimens\u00e3o 5 O uso de matrizes com mais de uma dimens\u00e3o j\u00e1 podia ser visto com a declara\u00e7\u00e3o de listas de strings: char nomes[15][30]; No exemplo de vari\u00e1vel declarada acima, o primeiro valor entre colchetes representa o n\u00famero de linhas. O segundo, o n\u00famero de colunas. Nesse caso, o n\u00famero de colunas \u00e9 o n\u00famero de caracteres de cada linha da lista, ou melhor ainda, de cada nome. PI","title":"06 - Matrizes com mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/#06-matrizes-com-mais-de-uma-dimensao","text":"<- Voltar Matrizes em C podem ser declaradas com qualquer quantidade de dimens\u00f5es int matriz1[3][3]; //Matriz bidimensional int matriz2[4][2][5]; //Matriz tridimensional int matriz3[5][12][20][24][15]; //Matriz de dimens\u00e3o 5 O uso de matrizes com mais de uma dimens\u00e3o j\u00e1 podia ser visto com a declara\u00e7\u00e3o de listas de strings: char nomes[15][30]; No exemplo de vari\u00e1vel declarada acima, o primeiro valor entre colchetes representa o n\u00famero de linhas. O segundo, o n\u00famero de colunas. Nesse caso, o n\u00famero de colunas \u00e9 o n\u00famero de caracteres de cada linha da lista, ou melhor ainda, de cada nome.","title":"06 - Matrizes com mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/","text":"07 - Estruturas Heterog\u00eaneas de Dados (Structs) <- Voltar PI","title":"07 - Estruturas Heterog\u00eaneas de Dados (Structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/#07-estruturas-heterogeneas-de-dados-structs","text":"<- Voltar","title":"07 - Estruturas Heterog\u00eaneas de Dados (Structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/","text":"08 - Fun\u00e7\u00f5es e Escopos <- Voltar Fun\u00e7\u00f5es Apesar de j\u00e1 usarmos fun\u00e7\u00f5es desde quando come\u00e7amos a programar, \u00e9 poss\u00edvel tamb\u00e9m criarmos nossas pr\u00f3ximas fun\u00e7\u00f5es. \u00c9 altamente recomendado criar fun\u00e7\u00f5es para c\u00f3digos que se repetem. Tamb\u00e9m \u00e9 considerada uma boa p\u0155atica que fun\u00e7\u00f5es realizem uma \u00fanica tarefa, e seu nome reflita essa tarefa. Defini\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o Fun\u00e7\u00f5es podem ser definidas com a seguinte sintaxe void soma(int x, int y){ //<- Declara\u00e7\u00e3o da fun\u00e7\u00e3o com os argumentos a serem manipulados int valorSoma; valorSoma = x+y; printf(\"%d\", valorSoma); } int main(){ soma(3,2); //<- Chamada da fun\u00e7\u00e3o com os par\u00e2metros passados } A sintaxe de defini\u00e7\u00e3o de fun\u00e7\u00f5es deve ter, obrigatoriamente, o tipo do retorno, o nome da fun\u00e7\u00e3o e a lista de par\u00e2metros necess\u00e1rios para execut\u00e1-la. Quando a fun\u00e7\u00e3o n\u00e3o necessida de par\u00e2metros, os par\u00eanteses ainda s\u00e3o utilizados (a exemplo da fun\u00e7\u00e3o main). OBS: Cada argumento requisitado por uma fun\u00e7\u00e3o deve conter, em sua defini\u00e7\u00e3o, o tipo da vari\u00e1vel a ser recebida. Ex: int troca(int x, int y){...} . Note que, mesmo com os argumentos sendo do mesmo tipo (int), a palavra reservada para esse tipo \u00e9 utilizada para cada argumento. Caso a fun\u00e7\u00e3o fosse definida como int troca(int x, y){...} , o c\u00f3digo n\u00e3o funcionaria. Vari\u00e1veis declaradas dentro de fun\u00e7\u00f5es de forma est\u00e1tica possuem tempo de vida limitado at\u00e9 o fim da execu\u00e7\u00e3o da fun\u00e7\u00e3o e escopo limitado, n\u00e3o existindo fora da fun\u00e7\u00e3o. Para chamar uma fun\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar o nome desta, junto aos argumentos esperados por ela (definidos quando a fun\u00e7\u00e3o foi definida). Passagem de argumentos para fun\u00e7\u00f5es Argumentos podem ser passados por valor ou por refer\u00eancia. Ao passar um argumento por valor, Ao passar um argumento por refer\u00eancia, Escopos As fun\u00e7\u00f5es, bem como as diferentes estruturas aprendidas at\u00e9 aqui, podem ter vari\u00e1veis declaradas durante a sua execu\u00e7\u00e3o. Essas vari\u00e1veis n\u00e3o podem ser acessadas fora dessas estruturas. Os locais onde essas vari\u00e1veis podem ser acessadas s\u00e3o chamados de escopos . Vari\u00e1veis Locais Considere o c\u00f3digo abaixo: void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero <5; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ int num; //escopo: fun\u00e7\u00e3o main printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nO numero digitado foi: %d\", num); printf(\"\\nContando ate 4...\"); contador(); } No c\u00f3digo acima, a vari\u00e1vel numero , pertencente \u00e0 fun\u00e7\u00e3o contador , s\u00f3 pode ser usada dentro dessa fun\u00e7\u00e3o. Essencialmente, o escopo da vari\u00e1vel numero \u00e9 a fun\u00e7\u00e3o contador . Da mesma forma, o escopo da vari\u00e1vel num \u00e9 a fun\u00e7\u00e3o main. Isso n\u00e3o significa que a vari\u00e1vel pode ser acessada pela fun\u00e7\u00e3o contador , invocada ali. Isso aconteceria apenas se a vari\u00e1vel pudesse ser passada como argumento para a fun\u00e7\u00e3o. De qualquer forma, as vari\u00e1veis num e n\u00famero s\u00e3o chamadas de vari\u00e1veis locais , pois seu acesso s\u00f3 \u00e9 poss\u00edvel em determinadas partes do c\u00f3digo ap\u00f3s sua cria\u00e7\u00e3o. As vari\u00e1veis locais deixam de existir ap\u00f3s o escopo em que elas est\u00e3o situadas deixa de ser executado. Gra\u00e7as a essa caracter\u00edstica, \u00e9 poss\u00edvel criar infinitas vari\u00e1veis de mesmo nome em escopos diferentes, afinal, quase sempre, elas n\u00e3o gerar\u00e3o interfer\u00eancia entre si. Um exemplo b\u00e1sico de uso das vari\u00e1veis locais \u00e9 o for : for(int i = 0; i< 5; i++){ printf(\" %d\", i); } A vari\u00e1vel i \u00e9 declarada no momento em que o for \u00e9 executado, mas deixa de existir ap\u00f3s o loop ser conclu\u00eddo. Vari\u00e1veis Globais Agora, considere o seguinte caso: int num = 0; //escopo: global void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero < num; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nContando ate %d... \", num); contador(); } No caso acima, PI","title":"08 - Fun\u00e7\u00f5es e Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#08-funcoes-e-escopos","text":"<- Voltar","title":"08 - Fun\u00e7\u00f5es e Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#funcoes","text":"Apesar de j\u00e1 usarmos fun\u00e7\u00f5es desde quando come\u00e7amos a programar, \u00e9 poss\u00edvel tamb\u00e9m criarmos nossas pr\u00f3ximas fun\u00e7\u00f5es. \u00c9 altamente recomendado criar fun\u00e7\u00f5es para c\u00f3digos que se repetem. Tamb\u00e9m \u00e9 considerada uma boa p\u0155atica que fun\u00e7\u00f5es realizem uma \u00fanica tarefa, e seu nome reflita essa tarefa.","title":"Fun\u00e7\u00f5es"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#definicao-e-chamada-de-uma-funcao","text":"Fun\u00e7\u00f5es podem ser definidas com a seguinte sintaxe void soma(int x, int y){ //<- Declara\u00e7\u00e3o da fun\u00e7\u00e3o com os argumentos a serem manipulados int valorSoma; valorSoma = x+y; printf(\"%d\", valorSoma); } int main(){ soma(3,2); //<- Chamada da fun\u00e7\u00e3o com os par\u00e2metros passados } A sintaxe de defini\u00e7\u00e3o de fun\u00e7\u00f5es deve ter, obrigatoriamente, o tipo do retorno, o nome da fun\u00e7\u00e3o e a lista de par\u00e2metros necess\u00e1rios para execut\u00e1-la. Quando a fun\u00e7\u00e3o n\u00e3o necessida de par\u00e2metros, os par\u00eanteses ainda s\u00e3o utilizados (a exemplo da fun\u00e7\u00e3o main). OBS: Cada argumento requisitado por uma fun\u00e7\u00e3o deve conter, em sua defini\u00e7\u00e3o, o tipo da vari\u00e1vel a ser recebida. Ex: int troca(int x, int y){...} . Note que, mesmo com os argumentos sendo do mesmo tipo (int), a palavra reservada para esse tipo \u00e9 utilizada para cada argumento. Caso a fun\u00e7\u00e3o fosse definida como int troca(int x, y){...} , o c\u00f3digo n\u00e3o funcionaria. Vari\u00e1veis declaradas dentro de fun\u00e7\u00f5es de forma est\u00e1tica possuem tempo de vida limitado at\u00e9 o fim da execu\u00e7\u00e3o da fun\u00e7\u00e3o e escopo limitado, n\u00e3o existindo fora da fun\u00e7\u00e3o. Para chamar uma fun\u00e7\u00e3o, \u00e9 necess\u00e1rio utilizar o nome desta, junto aos argumentos esperados por ela (definidos quando a fun\u00e7\u00e3o foi definida).","title":"Defini\u00e7\u00e3o e chamada de uma fun\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#passagem-de-argumentos-para-funcoes","text":"Argumentos podem ser passados por valor ou por refer\u00eancia. Ao passar um argumento por valor, Ao passar um argumento por refer\u00eancia,","title":"Passagem de argumentos para fun\u00e7\u00f5es"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#escopos","text":"As fun\u00e7\u00f5es, bem como as diferentes estruturas aprendidas at\u00e9 aqui, podem ter vari\u00e1veis declaradas durante a sua execu\u00e7\u00e3o. Essas vari\u00e1veis n\u00e3o podem ser acessadas fora dessas estruturas. Os locais onde essas vari\u00e1veis podem ser acessadas s\u00e3o chamados de escopos .","title":"Escopos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#variaveis-locais","text":"Considere o c\u00f3digo abaixo: void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero <5; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ int num; //escopo: fun\u00e7\u00e3o main printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nO numero digitado foi: %d\", num); printf(\"\\nContando ate 4...\"); contador(); } No c\u00f3digo acima, a vari\u00e1vel numero , pertencente \u00e0 fun\u00e7\u00e3o contador , s\u00f3 pode ser usada dentro dessa fun\u00e7\u00e3o. Essencialmente, o escopo da vari\u00e1vel numero \u00e9 a fun\u00e7\u00e3o contador . Da mesma forma, o escopo da vari\u00e1vel num \u00e9 a fun\u00e7\u00e3o main. Isso n\u00e3o significa que a vari\u00e1vel pode ser acessada pela fun\u00e7\u00e3o contador , invocada ali. Isso aconteceria apenas se a vari\u00e1vel pudesse ser passada como argumento para a fun\u00e7\u00e3o. De qualquer forma, as vari\u00e1veis num e n\u00famero s\u00e3o chamadas de vari\u00e1veis locais , pois seu acesso s\u00f3 \u00e9 poss\u00edvel em determinadas partes do c\u00f3digo ap\u00f3s sua cria\u00e7\u00e3o. As vari\u00e1veis locais deixam de existir ap\u00f3s o escopo em que elas est\u00e3o situadas deixa de ser executado. Gra\u00e7as a essa caracter\u00edstica, \u00e9 poss\u00edvel criar infinitas vari\u00e1veis de mesmo nome em escopos diferentes, afinal, quase sempre, elas n\u00e3o gerar\u00e3o interfer\u00eancia entre si. Um exemplo b\u00e1sico de uso das vari\u00e1veis locais \u00e9 o for : for(int i = 0; i< 5; i++){ printf(\" %d\", i); } A vari\u00e1vel i \u00e9 declarada no momento em que o for \u00e9 executado, mas deixa de existir ap\u00f3s o loop ser conclu\u00eddo.","title":"Vari\u00e1veis Locais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#variaveis-globais","text":"Agora, considere o seguinte caso: int num = 0; //escopo: global void contador(){ int numero = 0; //escopo: fun\u00e7\u00e3o contador for(numero; numero < num; numero++){ printf(\"\\nEsse e o numero %d\", numero); } } int main(){ printf(\"\\nDigite um n\u00famero:\"); scanf(\"%d\", &num); printf(\"\\nContando ate %d... \", num); contador(); } No caso acima,","title":"Vari\u00e1veis Globais"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Recursividade/","text":"09 - Recursividade <- Voltar Defini\u00e7\u00f5es PI","title":"09 - Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Recursividade/#09-recursividade","text":"<- Voltar","title":"09 - Recursividade"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Recursividade/#definicoes","text":"","title":"Defini\u00e7\u00f5es"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Recursividade/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/","text":"10 - Ponteiros <- Voltar Ponteiros s\u00e3o tipos de dados que armazenam endere\u00e7os de mem\u00f3ria. Declara\u00e7\u00e3o de vari\u00e1veis Em C, o operador & retorna um endere\u00e7o de mem\u00f3ria: scanf(\"%d\",&num); // ^ // Operador ******* Esse operador \u00e9 necess\u00e1rio para informar que a informa\u00e7\u00e3o armazenada naquela vari\u00e1vel est\u00e1 em determinado local da mem\u00f3ria. Declara\u00e7\u00e3o de ponteiros O operador un\u00e1rio * \u00e9 utilizado para a declara\u00e7\u00e3o e o acesso de vari\u00e1veis ponteiro: int num, cont; num = 6; int *pont; // <--- Ponteiro pont = &num; // <--- Ponteiro recebendo o endere\u00e7o de mem\u00f3ria da vari\u00e1vel num cont = *pont;// <--- Vari\u00e1vel recebendo o valor \"desreferenciado\", ou seja, o valor armazenado no endere\u00e7o de mem\u00f3ria armazenado pelo ponteiro Matrizes e ponteiros Na linguagem C, matrizes e ponteiros s\u00e3o relacionados. O nome de uma matriz aponta para o primeiro endere\u00e7o dessa matriz. PI","title":"10 - Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/#10-ponteiros","text":"<- Voltar Ponteiros s\u00e3o tipos de dados que armazenam endere\u00e7os de mem\u00f3ria.","title":"10 - Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/#declaracao-de-variaveis","text":"Em C, o operador & retorna um endere\u00e7o de mem\u00f3ria: scanf(\"%d\",&num); // ^ // Operador ******* Esse operador \u00e9 necess\u00e1rio para informar que a informa\u00e7\u00e3o armazenada naquela vari\u00e1vel est\u00e1 em determinado local da mem\u00f3ria.","title":"Declara\u00e7\u00e3o de vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/#declaracao-de-ponteiros","text":"O operador un\u00e1rio * \u00e9 utilizado para a declara\u00e7\u00e3o e o acesso de vari\u00e1veis ponteiro: int num, cont; num = 6; int *pont; // <--- Ponteiro pont = &num; // <--- Ponteiro recebendo o endere\u00e7o de mem\u00f3ria da vari\u00e1vel num cont = *pont;// <--- Vari\u00e1vel recebendo o valor \"desreferenciado\", ou seja, o valor armazenado no endere\u00e7o de mem\u00f3ria armazenado pelo ponteiro","title":"Declara\u00e7\u00e3o de ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/#matrizes-e-ponteiros","text":"Na linguagem C, matrizes e ponteiros s\u00e3o relacionados. O nome de uma matriz aponta para o primeiro endere\u00e7o dessa matriz.","title":"Matrizes e ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Ponteiros/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/","text":"11 - Alocamento de mem\u00f3ria PI Programa e algoritmo Endere\u00e7os de mem\u00f3ria Toda vari\u00e1vel \u00e9 situada em um endere\u00e7o (uma posi\u00e7\u00e3o) da mem\u00f3ria. Quando queremos nos referir a um endere\u00e7o de mem\u00f3ria relativo a algo, utilizamos o & , como no scanf. Relembrando: Ponteiros (O conte\u00fado deste t\u00f3pico j\u00e1 foi abordado anteriormente) A vari\u00e1vel pont\u00e9iro \u00e9 uma vari\u00e1vel que armazena o endere\u00e7o de outra posi\u00e7\u00e3o na mem\u00f3ria, que pode conter outros dados. Se um ponteiro n\u00e3o armazena nenhum endere\u00e7o v\u00e1lido, o valor \u00e9 NULL Para declarar um ponteiro em C coloca-se * na frente do nome da vari\u00e1vel. Desreferenciamento de um ponteiro Para acessar o conte\u00fado de uma vari\u00e1vel que o ponteiro referencia, utiliza-se * na frente do ponteiro Vari\u00e1veis Est\u00e1ticas: Declaradas convencionalmente em tempo de projeto (ao programar) Din\u00e2micas Podem ser ciradas e destru\u00eddas durante a execu\u00e7\u00e3o do programa A declara\u00e7\u00e3o \u00e9 indireta e a vincula\u00e7\u00e3o, por meio de ponteiros Elas possuem diversas vantagens em rela\u00e7\u00e3o \u00e0s est\u00e1ticas, como a declara\u00e7\u00e3o de vari\u00e1veis sem desperd\u00edcio de mem\u00f3ria \u00c1reas da mem\u00f3ria Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Para alocar a mem\u00f3ria de vari\u00e1veis est\u00e1ticas, \u00e9 necess\u00e1rio saber a quantidade de mem\u00f3ria a ser alocada previamente. O problema disso \u00e9 que, em muitos casos, s\u00f3 \u00e9 poss\u00edvel saber a quantidade de mem\u00f3ria necess\u00e1ria durante a execu\u00e7\u00e3o do programa. Um dos maiores usos do alocamento din\u00e2mico \u00e9 com os blocos de dados (vetores e matrizes), para evitar o desperd\u00edcio ou a falta de mem\u00f3ria. Em C malloc : recebe como par\u00e2metro a quantidade de mem\u00f3rias que desejamos alocar, reservando a mem\u00f3ria perdida e retomando um ponteiro void para o primeiro byte alocado. ponteiro = (int*) malloc(12); //alocamento de 12 bytes para um ponteiro com cast int (armazena n\u00fameros de t) Para descobrir a quantidade de bytes necess\u00e1rios, existe a fun\u00e7\u00e3o sizeof() , que retorna o n\u00famero de bytes utlizados para algum elemento (tipo ou struct) ponteiro = (int*) malloc(sizeof(int)); //alocamento da quantidade de bytes necess\u00e1rios para uma vari\u00e1vel int ponteiro = (int*) malloc(sizeof(int)*4 );//alocamento da quantidade de bytes necess\u00e1rios para 4 vari\u00e1veis do tipo int Tamb\u00e9m existe a fun\u00e7\u00e3o calloc, que al\u00e9m de permitir a indica\u00e7\u00e3o do n\u00famero de elementos para alocar mem\u00f3ria, define o valor de cada um dos valores para 0. ponteiro = calloc(3, sizeof(int)); //aloca 3 int e declara todos eles como 0 Ap\u00f3s utilizar o ponteiro, \u00e9 ideal utilizar free(ponteiro) Aloca\u00e7\u00e3o din\u00e2mica de matrizes de mais de uma dimens\u00e3o A forma como declaramos vari\u00e1veis din\u00e2micas demonstrada anteriormente cria uma matriz unidimensional para o armazenamento dessas informa\u00e7\u00f5es. Agora, poderemos criar \"matrizes bidimensionais\" (com uma pegadinha). Para declarar matrizes bidimensionais, podemos utilizar o seguinte: matriz = (int*) malloc(2*3*sizeof(int)); // ^ ^ // | Aloca\u00e7\u00e3o dos bytes necess\u00e1rios para o tamanho de uma \"matriz\" 2x3 // Casting do tipo //genericamente: //matriz = (int*) malloc(linhas*colunas*sizeof(int)); Apesar de ser considerada uma matriz 3x2, n\u00e3o \u00e9 poss\u00edvel utilizar printf(\"%d\", matriz[1][2]); //genericamente, //printf(\"%d\", matriz[x][y]); para chamar o elemento da 2\u00aa linha e 3\u00aa coluna. Em vez disso, \u00e9 necess\u00e1rio utilizar aritm\u00e9tica de ponteiros: printf(\"%d\", matriz[(1*3)+2]); //genericamente, //printf(\"%d\", matriz[(x*colunas)+2]); Existe outra maneira de declarar uma matriz, dessa vez no formato convencional. Para tal, utiliza-se um ponteiro de um ponteiro Aloca\u00e7\u00e3o din\u00e2mica de estruturas (structs) A aloca\u00e7\u00e3o de structs funciona de forma similar ao de vari\u00e1veis, utilizando malloc ou calloc: struct areaRet{ float altura; float comprimento; float area; } struct s_circulo *p; p = (struct s_circulo *)malloc(sizeof(struct s_circulo)); //adicionar como acessar depois","title":"11 - Alocamento de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#11-alocamento-de-memoria","text":"","title":"11 - Alocamento de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#programa-e-algoritmo","text":"","title":"Programa e algoritmo"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#enderecos-de-memoria","text":"Toda vari\u00e1vel \u00e9 situada em um endere\u00e7o (uma posi\u00e7\u00e3o) da mem\u00f3ria. Quando queremos nos referir a um endere\u00e7o de mem\u00f3ria relativo a algo, utilizamos o & , como no scanf.","title":"Endere\u00e7os de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#relembrando-ponteiros","text":"(O conte\u00fado deste t\u00f3pico j\u00e1 foi abordado anteriormente) A vari\u00e1vel pont\u00e9iro \u00e9 uma vari\u00e1vel que armazena o endere\u00e7o de outra posi\u00e7\u00e3o na mem\u00f3ria, que pode conter outros dados. Se um ponteiro n\u00e3o armazena nenhum endere\u00e7o v\u00e1lido, o valor \u00e9 NULL Para declarar um ponteiro em C coloca-se * na frente do nome da vari\u00e1vel.","title":"Relembrando: Ponteiros"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#desreferenciamento-de-um-ponteiro","text":"Para acessar o conte\u00fado de uma vari\u00e1vel que o ponteiro referencia, utiliza-se * na frente do ponteiro","title":"Desreferenciamento de um ponteiro"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#variaveis","text":"","title":"Vari\u00e1veis"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#estaticas","text":"Declaradas convencionalmente em tempo de projeto (ao programar)","title":"Est\u00e1ticas:"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#dinamicas","text":"Podem ser ciradas e destru\u00eddas durante a execu\u00e7\u00e3o do programa A declara\u00e7\u00e3o \u00e9 indireta e a vincula\u00e7\u00e3o, por meio de ponteiros Elas possuem diversas vantagens em rela\u00e7\u00e3o \u00e0s est\u00e1ticas, como a declara\u00e7\u00e3o de vari\u00e1veis sem desperd\u00edcio de mem\u00f3ria","title":"Din\u00e2micas"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#areas-da-memoria","text":"","title":"\u00c1reas da mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-memoria","text":"Para alocar a mem\u00f3ria de vari\u00e1veis est\u00e1ticas, \u00e9 necess\u00e1rio saber a quantidade de mem\u00f3ria a ser alocada previamente. O problema disso \u00e9 que, em muitos casos, s\u00f3 \u00e9 poss\u00edvel saber a quantidade de mem\u00f3ria necess\u00e1ria durante a execu\u00e7\u00e3o do programa. Um dos maiores usos do alocamento din\u00e2mico \u00e9 com os blocos de dados (vetores e matrizes), para evitar o desperd\u00edcio ou a falta de mem\u00f3ria.","title":"Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#em-c","text":"malloc : recebe como par\u00e2metro a quantidade de mem\u00f3rias que desejamos alocar, reservando a mem\u00f3ria perdida e retomando um ponteiro void para o primeiro byte alocado. ponteiro = (int*) malloc(12); //alocamento de 12 bytes para um ponteiro com cast int (armazena n\u00fameros de t) Para descobrir a quantidade de bytes necess\u00e1rios, existe a fun\u00e7\u00e3o sizeof() , que retorna o n\u00famero de bytes utlizados para algum elemento (tipo ou struct) ponteiro = (int*) malloc(sizeof(int)); //alocamento da quantidade de bytes necess\u00e1rios para uma vari\u00e1vel int ponteiro = (int*) malloc(sizeof(int)*4 );//alocamento da quantidade de bytes necess\u00e1rios para 4 vari\u00e1veis do tipo int Tamb\u00e9m existe a fun\u00e7\u00e3o calloc, que al\u00e9m de permitir a indica\u00e7\u00e3o do n\u00famero de elementos para alocar mem\u00f3ria, define o valor de cada um dos valores para 0. ponteiro = calloc(3, sizeof(int)); //aloca 3 int e declara todos eles como 0 Ap\u00f3s utilizar o ponteiro, \u00e9 ideal utilizar free(ponteiro)","title":"Em C"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-matrizes-de-mais-de-uma-dimensao","text":"A forma como declaramos vari\u00e1veis din\u00e2micas demonstrada anteriormente cria uma matriz unidimensional para o armazenamento dessas informa\u00e7\u00f5es. Agora, poderemos criar \"matrizes bidimensionais\" (com uma pegadinha). Para declarar matrizes bidimensionais, podemos utilizar o seguinte: matriz = (int*) malloc(2*3*sizeof(int)); // ^ ^ // | Aloca\u00e7\u00e3o dos bytes necess\u00e1rios para o tamanho de uma \"matriz\" 2x3 // Casting do tipo //genericamente: //matriz = (int*) malloc(linhas*colunas*sizeof(int)); Apesar de ser considerada uma matriz 3x2, n\u00e3o \u00e9 poss\u00edvel utilizar printf(\"%d\", matriz[1][2]); //genericamente, //printf(\"%d\", matriz[x][y]); para chamar o elemento da 2\u00aa linha e 3\u00aa coluna. Em vez disso, \u00e9 necess\u00e1rio utilizar aritm\u00e9tica de ponteiros: printf(\"%d\", matriz[(1*3)+2]); //genericamente, //printf(\"%d\", matriz[(x*colunas)+2]); Existe outra maneira de declarar uma matriz, dessa vez no formato convencional. Para tal, utiliza-se um ponteiro de um ponteiro","title":"Aloca\u00e7\u00e3o din\u00e2mica de matrizes de mais de uma dimens\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/#alocacao-dinamica-de-estruturas-structs","text":"A aloca\u00e7\u00e3o de structs funciona de forma similar ao de vari\u00e1veis, utilizando malloc ou calloc: struct areaRet{ float altura; float comprimento; float area; } struct s_circulo *p; p = (struct s_circulo *)malloc(sizeof(struct s_circulo)); //adicionar como acessar depois","title":"Aloca\u00e7\u00e3o din\u00e2mica de estruturas (structs)"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/","text":"12 - Entrada e Sa\u00edda de Arquivos <- Voltar PI","title":"12 - Entrada e Sa\u00edda de Arquivos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#12-entrada-e-saida-de-arquivos","text":"<- Voltar","title":"12 - Entrada e Sa\u00edda de Arquivos"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/#pi","text":"","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/","text":"13 - Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o <- Voltar Um algoritmo de ordena\u00e7\u00e3o possibilita a organiza\u00e7\u00e3o PI #Extra","title":"13 - Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#13-apendice-algoritmos-de-ordenacao","text":"<- Voltar Um algoritmo de ordena\u00e7\u00e3o possibilita a organiza\u00e7\u00e3o","title":"13 - Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/#pi-extra","text":"","title":"PI #Extra"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/","text":"Menu PI <- Menu inicial Menu de navega\u00e7\u00e3o Aula Nome 1. Conceitos iniciais 2. Operadores relacionais e condicionais 3. Strings 4. Estruturas de Repeti\u00e7\u00e3o 5. Vetores(Arrays) 6. Matrizes nDimensionais 7. Estruturas Heterog\u00eaneas de Dados (Structs) 8. Fun\u00e7\u00f5es e Escopos 9. Recursividade 10. Ponteiros 11. Alocamento de mem\u00f3ria 12. Entrada e Sa\u00edda de Arquivos 13. Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o","title":"Menu"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#menu","text":"","title":"Menu"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#pi","text":"<- Menu inicial","title":"PI"},{"location":"Programa%C3%A7%C3%A3o%20Imperativa/Menu/#menu-de-navegacao","text":"Aula Nome 1. Conceitos iniciais 2. Operadores relacionais e condicionais 3. Strings 4. Estruturas de Repeti\u00e7\u00e3o 5. Vetores(Arrays) 6. Matrizes nDimensionais 7. Estruturas Heterog\u00eaneas de Dados (Structs) 8. Fun\u00e7\u00f5es e Escopos 9. Recursividade 10. Ponteiros 11. Alocamento de mem\u00f3ria 12. Entrada e Sa\u00edda de Arquivos 13. Ap\u00eandice - Algoritmos de ordena\u00e7\u00e3o","title":"Menu de navega\u00e7\u00e3o"},{"location":"Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/Menu/","text":"","title":"Menu"}]}