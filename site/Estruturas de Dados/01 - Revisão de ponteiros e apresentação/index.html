<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Revisão e introdução - Arquivos da UFS</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Arquivos da UFS</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">ArquivosUFS</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../Sem%20t%C3%ADtulo/" class="nav-link">Sem título</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Estruturas de Dados</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../00%20-%20Ementa/" class="dropdown-item">Bruno.</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">Revisão e introdução</a>
</li>
                                    
<li>
    <a href="../02%20-%20Complexidade/" class="dropdown-item">Análise de complexidade</a>
</li>
                                    
<li>
    <a href="../03-%20Recorr%C3%AAncia/" class="dropdown-item">Recorrência</a>
</li>
                                    
<li>
    <a href="../04%20-%20Estrutura%20de%20lista/" class="dropdown-item">Estrutura de lista</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Fundamentos de Sistemas Digitais</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Fundamentos%20de%20Sistemas%20Digitais/01%20-%20Conceitos%20de%20sistemas%20digitais/" class="dropdown-item">Conceitos de sistemas digitais</a>
</li>
                                    
<li>
    <a href="../../Fundamentos%20de%20Sistemas%20Digitais/02%20-%20Sistemas%20de%20numera%C3%A7%C3%A3o%20e%20circuitos%20digitais%20l%C3%B3gicos/" class="dropdown-item">Sistemas de numeração</a>
</li>
                                    
<li>
    <a href="../../Fundamentos%20de%20Sistemas%20Digitais/03%20-%20Circuitos%20Digitais-l%C3%B3gicos/" class="dropdown-item">Circuitos Digitais-Lógicos</a>
</li>
                                    
<li>
    <a href="../../Fundamentos%20de%20Sistemas%20Digitais/05%20-%20Aula%2027-05/" class="dropdown-item">Aula 27/05</a>
</li>
                                    
<li>
    <a href="../../Fundamentos%20de%20Sistemas%20Digitais/06%20-%20Aula%2029-05/" class="dropdown-item">Aula 29/05</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">MTPC</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../MTPC/01-%20Introdu%C3%A7%C3%A3o/" class="dropdown-item">Introdução</a>
</li>
                                    
<li>
    <a href="../../MTPC/02%20-%20especifica%C3%A7%C3%B5es%20do%20TCC/" class="dropdown-item">Especificação do TCC</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Programação Funcional</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Funcional/01%20-%20Conceitos%20B%C3%A1sicos/" class="dropdown-item">Conceitos Básicos</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Funcional/02%20-%20Listas%20e%20Registros/" class="dropdown-item">Listas e Registros</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Funcional/03%20-%20Recursividade/" class="dropdown-item">Recursividade</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Funcional/Menu/" class="dropdown-item">PF</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Programação Imperativa</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/01%20-%20Conceitos%20iniciais/" class="dropdown-item">Conceitos iniciais</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/02%20-%20Operadores%20relacionais%20e%20condicionais/" class="dropdown-item">Operadores relacionais e condicionais</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/03%20-%20Strings/" class="dropdown-item">Strings</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/04%20-%20Estruturas%20de%20Repeti%C3%A7%C3%A3o/" class="dropdown-item">Estrutura de Repetição</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/05%20-%20Vetores%28Arrays%29/" class="dropdown-item">Vetores(Arrays)</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/06%20-%20Matrizes%20nDimensionais/" class="dropdown-item">Matrizes com mais de uma dimensão</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/07%20-%20Estruturas%20Heterog%C3%AAneas%20de%20Dados%20%28Structs%29/" class="dropdown-item">Estruturas Heterogêneas de Dados (Structs)</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/08%20-%20Ponteiros/" class="dropdown-item">Ponteiros</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/09%20-%20Fun%C3%A7%C3%B5es%20e%20Escopos/" class="dropdown-item">Funções e Escopos</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/10%20-%20Recursividade/" class="dropdown-item">Recursividade</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/11%20-%20Alocamento%20de%20mem%C3%B3ria/" class="dropdown-item">Alocamento de memória</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/12%20-%20Entrada%20e%20Sa%C3%ADda%20de%20Arquivos/" class="dropdown-item">Entrada e Saída de Arquivos</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/13%20-%20Ap%C3%AAndice%20-%20Algoritmos%20de%20ordena%C3%A7%C3%A3o/" class="dropdown-item">Apêndice - Algoritmos de ordenação</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Imperativa/Menu/" class="dropdown-item">Menu</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Programação Orientada a Objetos</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/01%20-%20Introdu%C3%A7%C3%A3o/" class="dropdown-item">Aula 1 - Conceitos Básicos</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/02%20-%20Classes%20e%20Objetos/" class="dropdown-item">Classes e objetos</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/03%20-%20Abstra%C3%A7%C3%A3o/" class="dropdown-item">Abstração</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/04%20-%20Encapsulamento/" class="dropdown-item">Encapsulamento</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/05%20-%20Rela%C3%A7%C3%A3o%20cliente-Servidor/" class="dropdown-item">05   Relação cliente Servidor</a>
</li>
                                    
<li>
    <a href="../../Programa%C3%A7%C3%A3o%20Orientada%20a%20Objetos/06-/" class="dropdown-item">06 </a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Prática em Sistemas Digitais</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../Pr%C3%A1tica%20em%20Sistemas%20Digitais/00%20-%20Introdu%C3%A7%C3%A3o/" class="dropdown-item">Introdução</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../00%20-%20Ementa/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../02%20-%20Complexidade/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#revisao-e-introducao" class="nav-link">Revisão e introdução</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#tipos" class="nav-link">Tipos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#organizacao-dos-bytes-na-memoria-endianess" class="nav-link">Organização dos bytes na memória (endianess)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#segmentos-de-memoria" class="nav-link">Segmentos de memória</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ponteiros" class="nav-link">Ponteiros</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#passagem-de-parametros-por-valor-e-por-referencia" class="nav-link">Passagem de parâmetros por valor e por referência</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#por-valor" class="nav-link">Por valor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#modificador-const" class="nav-link">Modificador const</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ponteiro-de-ponteiro" class="nav-link">Ponteiro de ponteiro</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ponteiro-de-funcao" class="nav-link">Ponteiro de função</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#alocacao-dinamica-x-estatica" class="nav-link">Alocação dinâmica x estática</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#alocacao-dinamica-na-pratica-em-c" class="nav-link">Alocação dinâmica na prática em C</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="revisao-e-introducao">Revisão e introdução</h1>
<h2 id="tipos">Tipos</h2>
<p>Existem diversos tipos (tipos primitivos), (float, int, char, long int, etc ), de forma que cada um ocupa espaços diferentes na memória.</p>
<table>
<thead>
<tr>
<th>tipo</th>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Bytes</th>
<th style="text-align: center;">Alcance (máx e min)</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$-2^{7} \leftrightarrow 2^{7}-1$</td>
</tr>
<tr>
<td>int*</td>
<td style="text-align: center;">16-64</td>
<td style="text-align: center;">2-8</td>
<td style="text-align: center;">$-2^{63} \leftrightarrow 2^{63} -1$</td>
</tr>
<tr>
<td>long int*</td>
<td style="text-align: center;">32-64</td>
<td style="text-align: center;">4-8</td>
<td style="text-align: center;">$-2^{63} \leftrightarrow 2^{63} -1$</td>
</tr>
<tr>
<td>long long int*</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">$-2^{63} \leftrightarrow 2^{63} -1$</td>
</tr>
<tr>
<td>short int</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$-2^{15} \leftrightarrow 2^{15}-1$</td>
</tr>
<tr>
<td>float</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">$1.2^{-38}\leftrightarrow 3.4^{38}$</td>
</tr>
<tr>
<td>double</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">$2.3^{-308}\leftrightarrow 1.7^{308}$</td>
</tr>
<tr>
<td>long double*</td>
<td style="text-align: center;">80-128</td>
<td style="text-align: center;">10-16</td>
<td style="text-align: center;">$3.4^{-4932}\leftrightarrow 1.1^{4932}$</td>
</tr>
<tr>
<td>*<strong>tamanho e alcance dependentes da plataforma</strong></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>Agora, temos os tipos <em>unsigned</em>, cujo valor vai de 0 até o seu valor máximo positivo, ao contrário dos tipos <em>signed</em>, que possuem valores negativos e positivos.</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>tipo</th>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Bytes</th>
<th style="text-align: center;">Alcance (máx e min)</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned char</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">$0 \leftrightarrow 2^{8}-1$</td>
</tr>
<tr>
<td>unsigned int*</td>
<td style="text-align: center;">16-64</td>
<td style="text-align: center;">2-8</td>
<td style="text-align: center;">$0 \leftrightarrow 2^{64}-1$</td>
</tr>
<tr>
<td>unsigned long int*</td>
<td style="text-align: center;">32-64</td>
<td style="text-align: center;">4-8</td>
<td style="text-align: center;">$0 \leftrightarrow 2^{64}-1$</td>
</tr>
<tr>
<td>unsigned long long int*</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">$0 \leftrightarrow 2^{64}-1$</td>
</tr>
<tr>
<td>unsigned short int</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">$0 \leftrightarrow 2^{16}-1$</td>
</tr>
<tr>
<td>*<strong>tamanho e alcance dependentes da plataforma</strong></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>A partir do tamanho desses tipos, é possível alocar a quantidade necessária de memória para um valor que se deseja armazenar ou um grupo de valores, seja essa alocação estática ou dinâmica.</p>
<blockquote>
<p>[!Dica]
Existe uma biblioteca chamada <code>stdint.h</code> que padroniza o tamanho dos inteiros, garantindo que a precisão e o tamanho máximo dos números seja o mesmo em todas as plataformas executadas, e assim, que código seja portável.</p>
</blockquote>
<h2 id="organizacao-dos-bytes-na-memoria-endianess">Organização dos bytes na memória (<em>endianess</em>)</h2>
<p><em>Endianess</em> é o termo que se refere à organização sequencial dos bytes de alguma estrutura na memória. Essa organização é importante para que os dados sejam trocados corretamente entre programas e sistemas diferentes. </p>
<blockquote>
<p>[!Importante]
A ordem de importância (byte mais ou menos significativo) é determinada olhando para os dados e observando a ordem dos bytes. Então por exemplo, no número <code>0x12345678</code>, em que <code>0x12</code>, <code>0x34</code>, <code>0x56</code> e <code>0x78</code> são bytes diferentes, <code>0x12</code> é o byte mais significativo e <code>0x78</code>, o menos significativo.</p>
</blockquote>
<p>Existem dois tipos de <em>endianess:</em></p>
<h3 id="little-endian">Little endian</h3>
<p>No formato <em>little endian</em>, o <em>byte</em> menos significativo é armazenado primeiro, e os outros bytes são armazenados em ordem crescente de importância.</p>
<p>Suponha um dado  <code>0xAABBCCDD</code> (cada letra representa um <em>byte</em>). Na notação <em>little endian</em>, isso seria armazenado da seguinte maneira</p>
<table>
<thead>
<tr>
<th>ordem</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td><code>0xDD</code></td>
<td><code>0xCC</code></td>
<td><code>0xBB</code></td>
<td><code>0xAA</code></td>
</tr>
</tbody>
</table>
<h3 id="big-endian">Big endian</h3>
<p>Na formatação <em>big endian</em>, o contrário acontece. Isto é, o <em>byte</em> mais significativo é armazenado primeiro, e os outros são armazenados em ordem decrescente de importância.</p>
<p>Podemos representar <code>0xAABBCCDD</code> na notação <em>Big endian</em> da seguinte forma:</p>
<table>
<thead>
<tr>
<th>ordem</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td><code>0xAA</code></td>
<td><code>0xBB</code></td>
<td><code>0xCC</code></td>
<td><code>0xDD</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!NOTE]
A ordem dos <strong>bits</strong> em qualquer byte geralmente segue o formato <em>little endian</em></p>
</blockquote>
<p>Para descobrir a <em>endianess</em> de um sistema, basta utilizar o código a seguir:</p>
<pre><code class="language-c">int main(void)
{
    unsigned int i = 1;
    char *c;

    c = (char *) &amp;i;
}
</code></pre>
<p>Caso o</p>
<h2 id="segmentos-de-memoria">Segmentos de memória</h2>
<p><img src='./assets/SegmentosDaMemoria.png' height= 500></p>
<h3 id="pilha">Pilha</h3>
<p>A pilha (stack) é a região da memória onde são armazenadas as variáveis locais no escopo executado em determinado momento, as chamadas de funções e parâmetros. Assim que esses processos ou variáveis terminam de ser executados ou usados, a pilha é liberada.</p>
<p>A pilha já possui tamanho predefinido, e é gerenciada pelo próprio computador, não requerendo intervenção do programador para liberar memória.</p>
<p>A ordem em que os dados são processados é chamadas de <em>LIFO</em> (Last In, First Out), que significa que os últimos dados adicionados serão os primeiros processados. Na prática, para a execução de uma função que requer outra para funcionar, não faz sentido que a primeira seja executada antes da segunda, pois faltaria informação.</p>
<blockquote>
<p>[!Erro associado à pilha] 
Quando recebemos um erro de "Stack Overflow" (estouro de pilha), é porque muitas chamadas foram feitas, de forma que o espaço requerido para armazená-las é maior do que há na pilha. Isso pode acontecer com funções recursivas mal elaboradas, por exemplo.</p>
</blockquote>
<h3 id="heap">Heap</h3>
<p>O heap é a parte da memória alocada dinamicamente durante a execução do programa. Ao contrário da pilha, ela é controlada pelo programador ou por um <em>garbage collector</em>, pois não é liberada automaticamente.</p>
<p>Para acessar dados armazenados no heap, utilizamos tipos de dados que <em>apontam</em> (sim, ponteiros) para os endereços nesse espaço da memória, permitindo que diferentes tipos de dados sejam armazenados ali. </p>
<p>O heap é mais lento que a pilha, devido à alocação e à liberação manual, mas é mais flexível, pois permite o armazenamento de coleções de dados (arrays) ou de classes e objetos.</p>
<p>Ao mexer com o heap, é necessário ter cuidado com vazamentos de memória. Como a alocação é realizada dinamicamente, um programa com <em>memory leaks</em> pode ocupar toda a memória do computador se rodar por tempo suficiente para isso.</p>
<blockquote>
<p>[!Erro associado a ponteiros]
Quando recebemos um erro de "Segmentation Fault" (Falha de segmentação), é porque algum ponteiro está tentando acessar um local indevido (ou nulo) da memória. Por exemplo, se tentamos escrever uma parte da memória destinada apenas a leitura, ocupada por outro programa, ou até mesmo, nula.</p>
</blockquote>
<h3 id="dados">Dados</h3>
<p>A memória de dados possui as variáveis estáticas declaradas no programa, com valores inicializados ou definidos pela plataforma</p>
<h3 id="codigo">Código</h3>
<p>A memória de código possui as operações lógicas e aritméticas, junto com os controles de fluxo (condicionais e loops), chamadas de funções, entre outros. É a parte compilada do programa.</p>
<h2 id="ponteiros">Ponteiros</h2>
<p>Ponteiros são tipos de dados que armazenam um <strong>endereço de memória</strong>. Esse endereço de memória é onde está localizado algum conteúdo a ser acessado por meio desse ponteiro.</p>
<pre><code class="language-C">int num =  24; //variável do tipo int
int *pointer; //ponteiro para variável int inicializado

pointer = &amp;num; //o ponteiro px recebe o endereço da variável num
</code></pre>
<p>Assim como os outros tipos de variáveis, os ponteiros são armazenados na pilha, possuindo endereços próprios. Então é possível, por exemplo, que exista um ponteiro apontando para outro ponteiro.</p>
<blockquote>
<p>[!Dica]
Uma boa prática para a declaração de ponteiros é apontá-los para um endereço nulo, utilizando a palavra reservada <code>NULL</code>. Sem isso, o ponteiro apenas declarado pode apontar para qualquer lugar, inclusive locais aleatórios (e indesejados).</p>
<p>[!Dica]
É importante que o tipo do ponteiro seja o mesmo da variável para a qual ele aponta, pois um ponteiro <code>int</code>, por exemplo, pode acessar o byte inicial da variável e os 3 seguintes, mas se o ponteiro for <code>char</code>, ele só acessará o byte inicial (variável <code>char</code> possui 1 byte).</p>
</blockquote>
<h3 id="operadores">Operadores</h3>
<h4 id="operador-desreferenciamento">Operador <code>*</code> (desreferenciamento)</h4>
<p>O operador <code>*</code> serve para <strong>desreferenciar</strong> o ponteiro, ou seja, acessar a informação armazenada no endereço de memória que o ponteiro guarda. </p>
<pre><code class="language-c">...
int num =  24; //armazenado em 0x87654321
int *pointer;

pointer = &amp;num;

printf(&quot;Pointer: %p \t Value: %d&quot;, pointer, *pointer);
...
</code></pre>
<p>Saída: <code>Pointer: 0x87654321   Value: 24</code></p>
<p>No exemplo acima, é possível observar que, caso utilizemos apenas o nome do ponteiro <code>pointer</code>, o valor impresso é o endereço armazenado no ponteiro. Utilizando <code>*pointer</code>, imprimimos o valor armazenado no endereço armazenado do ponteiro. </p>
<h4 id="operador-enderecamento">Operador &amp; (endereçamento)</h4>
<p>O operador <code>&amp;</code> serve para obter o <strong>endereço</strong> de uma variável. No exemplo anterior, <code>&amp;num</code> representa o endereço da variável num.</p>
<h2 id="passagem-de-parametros-por-valor-e-por-referencia">Passagem de parâmetros por valor e por referência</h2>
<h2 id="por-valor">Por valor</h2>
<p>Podemos, na execução de uma função, passar um parâmetro por valor. Ou seja, passamos diretamente o valor daquela variável. </p>
<pre><code class="language-C">...
void func(int x){

    x*=3;
    printf(&quot;func: %d\n&quot;, x);
}

int main(){
    int x = 10;

    func(x);

    printf(&quot;main: %d\n&quot;, x);
    ...
}
</code></pre>
<p>Retorno:</p>
<pre><code>func: 30
main: 10
</code></pre>
<p>Com o exemplo acima, é possível perceber que, na passagem por valor, os valores passados são "copiados" para uma variável interna à função, e a variável original se mantém inalterada. Apesar de ter seus usos, para muitas aplicações, a passagem por valor não é adequada. Por isso, temos a passagem de parâmetros por referência</p>
<h3 id="por-referencia">Por referência</h3>
<p>Aqui, ao invés de passarmos a variável diretamente, passamos o endereço daquela variável, permitindo que ela seja modificada. </p>
<p>diretamente o valor daquela variável. </p>
<pre><code class="language-C">...
void func(int *x){

    *x *=3;
    printf(&quot;func: %d\n&quot;, *x);
}

int main(){
    int x = 10;

    func(&amp;x);

    printf(&quot;main: %d\n&quot;, x);

}
</code></pre>
<p>Retorno:</p>
<pre><code>func: 30
main: 30
</code></pre>
<p>Diferente do exemplo anterior, aqui, o valor da variável foi alterado para quaisquer escopos que a acessem, pois o valor passado não foi o valor da variável, mas sim, o endereço daquela variável na memória, cujo valor armazenado foi alterado pela função.</p>
<h2 id="modificador-const">Modificador const</h2>
<p>O uso de <code>const</code> antes do tipo da variável garante que o valor não seja alterado, mesmo na passagem por referência, por exemplo. Caso haja uma tentativa de modificação do valor, o compilador aponta um erro, pois o valor é de <em>somente leitura</em>.</p>
<h2 id="ponteiro-de-ponteiro">Ponteiro de ponteiro</h2>
<p>É possível que um ponteiro aponte para outro ponteiro. Assim, um ponteiro duplo (como também pode ser chamado) é um ponteiro que aponta para o endereço de outro ponteiro, e este aponta para o endereço de alguma variável ou algum outro dado.</p>
<pre><code class="language-c">int main(){

    char letra = 'l';
    char* pont1 = &amp;letra;
    char** pont2 = &amp;pont1;
}
</code></pre>
<p>No excerto acima, o ponteiro <code>pont2</code> aponta para o endereço de <code>pont1</code>, e esse aponta para o endereço de <code>letra</code>.</p>
<h3 id="argc-e-argv-em-c"><code>argc</code> e <code>argv</code> (em C)</h3>
<p>A função main em C pode possuir os argumentos <code>argc</code> e <code>argv</code>. Enquanto <code>argc</code> é o número de argumentos para a execução do código, <code>argv</code> representa os argumentos recebidos. Detalhe que <code>argc</code> por padrão é 1, que representa o nome do programa. Esse número pode aumentar a depender da quantidade de argumentos utilizados. Por exemplo, o programa <code>pessoas</code>, demonstrado abaixo:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char* argv[]){

    //informações sobre cada pessoa
    char nome[3][10] = {&quot;Gustavo&quot;,&quot;Joao&quot;, &quot;Gabriel&quot;};
    int idade[3] = {23,15,20};
    char status[3][13] = {&quot;Dormindo&quot;,&quot;Acordado&quot;,&quot;Trabalhando&quot;};

    //Caso o número de argumentos seja menor que 2 (apenas o nome do programa)
    if(argc &lt; 2){
        printf(&quot;Insira um nome!!\nSaindo...\n&quot;);
        return 1;
    }
    else{
        for(int i=0; i&lt;argc+1; i++){
            //compara o segundo elemento do argv com cada item da lista de nomes
            if(!strcmp(nome[i],argv[1])){
                printf(&quot;Nome: %s\n&quot;, nome[i]);
                printf(&quot;Idade: %d\n&quot;, idade[i]);
                printf(&quot;Status: %s\n&quot;, status[i]);
                return 0; //acaba o programa aqui
            }   
        }
        //caso o segundo argumento não corresponda a nenhum nome
        printf(&quot;Nome inválido\n&quot;);
    }
    return 0;
}
</code></pre>
<p>Nesse exemplo, com três listas, cada entrada correspondente à informação de uma pessoa, quando executado no terminal, o programa compilado requer um nome. Então um caso possível é:</p>
<p>`$:./pessoas Gustavo </p>
<p>e o retorno disso seria:</p>
<pre><code>Nome: Gustavo
Idade: 23
Status: Dormindo
</code></pre>
<blockquote>
<p>[!Dica]
Note que <code>argv</code> é um ponteiro de um ponteiro, pois representa uma lista de strings. Como strings em C são listas de caracteres, a lista de argumentos é um <strong>array bidimensional</strong> de caracteres, e cada "linha" da lista é separada por um espaço, na entrada desses argumentos.</p>
</blockquote>
<h2 id="ponteiro-de-funcao">Ponteiro de função</h2>
<h2 id="alocacao-dinamica-x-estatica">Alocação dinâmica x estática</h2>
<p>Aqui temos uma tabela que compara, em termos gerais, os dois tipos de alocação</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Alocação dinâmica</th>
<th style="text-align: center;">Alocação estática</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Variáveis de tamanho conhecido em tempo de execução</td>
<td style="text-align: center;">Variáveis de tamanho fixo previamente conhecido</td>
</tr>
<tr>
<td style="text-align: center;">Alocada dinamicamente no <em>heap</em></td>
<td style="text-align: center;">Alocada estaticamente nos segmentos <em>.data</em> e <em>.bss</em></td>
</tr>
<tr>
<td style="text-align: center;">Gerenciada pelo programador</td>
<td style="text-align: center;">Gerenciada automaticamente pelo computados</td>
</tr>
<tr>
<td style="text-align: center;">Limitado pela memória disponível no sistema</td>
<td style="text-align: center;">Limitado pelo compilador e pelo sistema operacional</td>
</tr>
</tbody>
</table>
<h2 id="alocacao-dinamica-na-pratica-em-c">Alocação dinâmica na prática em C</h2>
<p>Com a alocação dinâmica, podemos utilizar algumas funções úteis: 
- o <code>sizeof()</code> permite que descubramos o tamanho de uma variável pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura).
(padding)
- o <code>malloc()</code> é a função utilizada para alocar memória. Ele aloca o tamanho requisitado (utilizano)
- o <code>calloc()</code> 
- o <code>realloc()</code> 
- o <code>free()</code></p>
<h3 id="o-sizeof">O <code>sizeof()</code></h3>
<p>O <code>sizeof()</code> permite que descubramos o tamanho de uma variável pelo seu tipo (ou se for uma estrutura, o tamanho da estrutura).</p>
<blockquote>
<p>[!Dica]
Caso você possua uma <code>struct</code> <code>tipo</code> com, por exemplo, uma variável do tipo <code>float</code> (de tamanho 4) e outra do tipo <code>char</code> (de tamanho 1), e você utilizar <code>sizeof(tipo)</code>, o valor retornado será 8, e não 5. Isso acontece devido ao <strong>padding</strong>, que é o preenchimento de espaços inutilizados da memória, nesse caso, dos 3 bytes inutilizados. Esses bytes são preenchidos assim pois é mais fácil para o computador trabalhar com múltiplos e potências de 2. Assim, um <code>struct</code> com 2 <code>floats</code> e um <code>char</code> possui 16 bytes, e não 9.</p>
</blockquote>
<h3 id="o-malloc">O <code>malloc()</code></h3>
<p>O <code>malloc()</code> é a função utilizada para alocar memória. Ele aloca o tamanho requisitado (utilizando, inclusive, o retorno da função <code>sizeof()</code>). Note que ele não altera os valores alocados na memória, mesmo se eles possuírem algum tipo de lixo.</p>
<pre><code class="language-c">int main(){
    //declaração do ponteiro
    int *pont

    //alocamento de memória para 2 números inteiros.
    pont = (int*) malloc(2*sizeof(int)); 

    // inicializando os espaços do ponteiro
    p[0] = 2;
    p[1] = 13;

    //imprimindo os valores
    for(int i = 0; i&lt;2; i++){
    printf(&quot;%d &quot;, p[i]);
    }

}
</code></pre>
<p>Retorno <code>2 13</code>.</p>
<h3 id="o-calloc">O <code>calloc()</code></h3>
<p>Assim como o <code>malloc()</code>, o <code>calloc()</code> também serve para alocar memória. Diferente do <code>malloc()</code>, que funciona com aritmética de ponteiros, o <code>calloc()</code> recebe a quantidade de elementos com o tamanho requisitado. Outra diferença é que o <code>calloc()</code> torna os valores de todos o espaço alocado para 0 (nulo), impedindo que algum lixo seja capturado na memória. Um fator importante é que isso consome mais processamento, portanto demandando mais tempo para ser feito.</p>
<pre><code class="language-c">int main(){
    //declaração do ponteiro
    int *pont

    //alocamento de memória para 2 números inteiros.
    pont = (int*) calloc(2,sizeof(int)); 

    // inicializando os espaços do ponteiro
    p[0] = 2;

    //imprimindo os valores
    for(int i = 0; i&lt;2; i++){
    printf(&quot;%d &quot;, p[i]);
    }

}
</code></pre>
<p>Retorno: <code>2 0</code>.</p>
<h3 id="o-realloc">O <code>realloc()</code></h3>
<p>O <code>realloc()</code>, diferente do <code>malloc()</code> e do <code>calloc()</code>, permite alterar a quantidade de memória alocada</p>
<h3 id="o-free">O <code>free()</code></h3></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
